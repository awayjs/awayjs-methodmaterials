var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var AbstractMethodError = require("awayjs-core/lib/errors/AbstractMethodError");
var PointLight = require("awayjs-display/lib/entities/PointLight");
var ShadowMapMethodBase = require("awayjs-methodmaterials/lib/methods/ShadowMapMethodBase");
/**
 * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.
 */
var ShadowMethodBase = (function (_super) {
    __extends(ShadowMethodBase, _super);
    /**
     * Creates a new ShadowMethodBase object.
     * @param castingLight The light used to cast shadows.
     */
    function ShadowMethodBase(castingLight) {
        this._pUsePoint = (castingLight instanceof PointLight);
        _super.call(this, castingLight);
    }
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iInitVO = function (shaderObject, methodVO) {
        methodVO.needsView = true;
        methodVO.needsGlobalVertexPos = true;
        methodVO.needsGlobalFragmentPos = this._pUsePoint;
        methodVO.needsNormals = shaderObject.numLights > 0;
    };
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iInitConstants = function (shaderObject, methodVO) {
        var fragmentData = shaderObject.fragmentConstantData;
        var vertexData = shaderObject.vertexConstantData;
        var index = methodVO.fragmentConstantsIndex;
        fragmentData[index] = 1.0;
        fragmentData[index + 1] = 1 / 255.0;
        fragmentData[index + 2] = 1 / 65025.0;
        fragmentData[index + 3] = 1 / 16581375.0;
        fragmentData[index + 6] = 0;
        fragmentData[index + 7] = 1;
        if (this._pUsePoint) {
            fragmentData[index + 8] = 0;
            fragmentData[index + 9] = 0;
            fragmentData[index + 10] = 0;
            fragmentData[index + 11] = 1;
        }
        index = methodVO.vertexConstantsIndex;
        if (index != -1) {
            vertexData[index] = .5;
            vertexData[index + 1] = .5;
            vertexData[index + 2] = 0.0;
            vertexData[index + 3] = 1.0;
        }
    };
    Object.defineProperty(ShadowMethodBase.prototype, "_iDepthMapCoordReg", {
        /**
         * Wrappers that override the vertex shader need to set this explicitly
         */
        get: function () {
            return this._pDepthMapCoordReg;
        },
        set: function (value) {
            this._pDepthMapCoordReg = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iCleanCompilationData = function () {
        _super.prototype.iCleanCompilationData.call(this);
        this._pDepthMapCoordReg = null;
    };
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iGetVertexCode = function (shaderObject, methodVO, regCache, sharedRegisters) {
        return this._pUsePoint ? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters) : this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);
    };
    /**
     * Gets the vertex code for shadow mapping with a point light.
     *
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     */
    ShadowMethodBase.prototype._pGetPointVertexCode = function (methodVO, regCache, sharedRegisters) {
        methodVO.vertexConstantsIndex = -1;
        return "";
    };
    /**
     * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).
     *
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     */
    ShadowMethodBase.prototype.pGetPlanarVertexCode = function (methodVO, regCache, sharedRegisters) {
        var code = "";
        var temp = regCache.getFreeVertexVectorTemp();
        var dataReg = regCache.getFreeVertexConstant();
        var depthMapProj = regCache.getFreeVertexConstant();
        regCache.getFreeVertexConstant();
        regCache.getFreeVertexConstant();
        regCache.getFreeVertexConstant();
        this._pDepthMapCoordReg = regCache.getFreeVarying();
        methodVO.vertexConstantsIndex = dataReg.index * 4;
        // todo: can epsilon be applied here instead of fragment shader?
        code += "m44 " + temp + ", " + sharedRegisters.globalPositionVertex + ", " + depthMapProj + "\n" + "div " + temp + ", " + temp + ", " + temp + ".w\n" + "mul " + temp + ".xy, " + temp + ".xy, " + dataReg + ".xy\n" + "add " + this._pDepthMapCoordReg + ", " + temp + ", " + dataReg + ".xxwz\n";
        //"sub " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".w\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iGetFragmentCode = function (shaderObject, methodVO, targetReg, registerCache, sharedRegisters) {
        var code = this._pUsePoint ? this._pGetPointFragmentCode(methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(methodVO, targetReg, registerCache, sharedRegisters);
        code += "add " + targetReg + ".w, " + targetReg + ".w, fc" + (methodVO.fragmentConstantsIndex / 4 + 1) + ".y\n" + "sat " + targetReg + ".w, " + targetReg + ".w\n";
        return code;
    };
    /**
     * Gets the fragment code for shadow mapping with a planar shadow map.
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     * @param targetReg The register to contain the shadow coverage
     * @return
     */
    ShadowMethodBase.prototype._pGetPlanarFragmentCode = function (methodVO, targetReg, regCache, sharedRegisters) {
        throw new AbstractMethodError();
        return "";
    };
    /**
     * Gets the fragment code for shadow mapping with a point light.
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     * @param targetReg The register to contain the shadow coverage
     * @return
     */
    ShadowMethodBase.prototype._pGetPointFragmentCode = function (methodVO, targetReg, regCache, sharedRegisters) {
        throw new AbstractMethodError();
        return "";
    };
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iSetRenderState = function (shaderObject, methodVO, renderable, stage, camera) {
        if (!this._pUsePoint)
            this._pShadowMapper.iDepthProjection.copyRawDataTo(shaderObject.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);
    };
    /**
     * Gets the fragment code for combining this method with a cascaded shadow map method.
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     * @param decodeRegister The register containing the data to decode the shadow map depth value.
     * @param depthTexture The texture containing the shadow map.
     * @param depthProjection The projection of the fragment relative to the light.
     * @param targetRegister The register to contain the shadow coverage
     * @return
     */
    ShadowMethodBase.prototype._iGetCascadeFragmentCode = function (shaderObject, methodVO, decodeRegister, depthTexture, depthProjection, targetRegister, registerCache, sharedRegisters) {
        throw new Error("This shadow method is incompatible with cascade shadows");
    };
    /**
     * @inheritDoc
     */
    ShadowMethodBase.prototype.iActivate = function (shaderObject, methodVO, stage) {
        var fragmentData = shaderObject.fragmentConstantData;
        var index = methodVO.fragmentConstantsIndex;
        if (this._pUsePoint)
            fragmentData[index + 4] = -Math.pow(1 / (this._pCastingLight.fallOff * this._pEpsilon), 2);
        else
            shaderObject.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1 / (this._pShadowMapper.depth * this._pEpsilon);
        fragmentData[index + 5] = 1 - this._pAlpha;
        if (this._pUsePoint) {
            var pos = this._pCastingLight.scenePosition;
            fragmentData[index + 8] = pos.x;
            fragmentData[index + 9] = pos.y;
            fragmentData[index + 10] = pos.z;
            // used to decompress distance
            var f = this._pCastingLight.fallOff;
            fragmentData[index + 11] = 1 / (2 * f * f);
        }
        if (!this._pUsePoint)
            stage.activateRenderTexture(methodVO.texturesIndex, this._pCastingLight.shadowMapper.depthMap);
        //else
        //	stage.activateCubeRenderTexture(methodVO.texturesIndex, <CubeTextureBase> this._pCastingLight.shadowMapper.depthMap);
    };
    /**
     * Sets the method state for cascade shadow mapping.
     */
    ShadowMethodBase.prototype.iActivateForCascade = function (shaderObject, methodVO, stage) {
        throw new Error("This shadow method is incompatible with cascade shadows");
    };
    return ShadowMethodBase;
})(ShadowMapMethodBase);
module.exports = ShadowMethodBase;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImF3YXlqcy1tZXRob2RtYXRlcmlhbHMvbGliL21ldGhvZHMvU2hhZG93TWV0aG9kQmFzZS50cyJdLCJuYW1lcyI6WyJTaGFkb3dNZXRob2RCYXNlIiwiU2hhZG93TWV0aG9kQmFzZS5jb25zdHJ1Y3RvciIsIlNoYWRvd01ldGhvZEJhc2UuaUluaXRWTyIsIlNoYWRvd01ldGhvZEJhc2UuaUluaXRDb25zdGFudHMiLCJTaGFkb3dNZXRob2RCYXNlLl9pRGVwdGhNYXBDb29yZFJlZyIsIlNoYWRvd01ldGhvZEJhc2UuaUNsZWFuQ29tcGlsYXRpb25EYXRhIiwiU2hhZG93TWV0aG9kQmFzZS5pR2V0VmVydGV4Q29kZSIsIlNoYWRvd01ldGhvZEJhc2UuX3BHZXRQb2ludFZlcnRleENvZGUiLCJTaGFkb3dNZXRob2RCYXNlLnBHZXRQbGFuYXJWZXJ0ZXhDb2RlIiwiU2hhZG93TWV0aG9kQmFzZS5pR2V0RnJhZ21lbnRDb2RlIiwiU2hhZG93TWV0aG9kQmFzZS5fcEdldFBsYW5hckZyYWdtZW50Q29kZSIsIlNoYWRvd01ldGhvZEJhc2UuX3BHZXRQb2ludEZyYWdtZW50Q29kZSIsIlNoYWRvd01ldGhvZEJhc2UuaVNldFJlbmRlclN0YXRlIiwiU2hhZG93TWV0aG9kQmFzZS5faUdldENhc2NhZGVGcmFnbWVudENvZGUiLCJTaGFkb3dNZXRob2RCYXNlLmlBY3RpdmF0ZSIsIlNoYWRvd01ldGhvZEJhc2UuaUFjdGl2YXRlRm9yQ2FzY2FkZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsSUFBTyxtQkFBbUIsV0FBYSw0Q0FBNEMsQ0FBQyxDQUFDO0FBT3JGLElBQU8sVUFBVSxXQUFlLHdDQUF3QyxDQUFDLENBQUM7QUFhMUUsSUFBTyxtQkFBbUIsV0FBYSx3REFBd0QsQ0FBQyxDQUFDO0FBRWpHLEFBR0E7O0dBREc7SUFDRyxnQkFBZ0I7SUFBU0EsVUFBekJBLGdCQUFnQkEsVUFBNEJBO0lBS2pEQTs7O09BR0dBO0lBQ0hBLFNBVEtBLGdCQUFnQkEsQ0FTVEEsWUFB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QTtJQUVEZDs7T0FFR0E7SUFDSUEsOENBQW1CQSxHQUExQkEsVUFBMkJBLFlBQTZCQSxFQUFFQSxRQUFpQkEsRUFBRUEsS0FBV0E7UUFFdkZlLE1BQU1BLElBQUlBLEtBQUtBLENBQUNBLHlEQUF5REEsQ0FBQ0EsQ0FBQ0E7SUFDNUVBLENBQUNBO0lBQ0ZmLHVCQUFDQTtBQUFEQSxDQWxPQSxBQWtPQ0EsRUFsTzhCLG1CQUFtQixFQWtPakQ7QUFFRCxBQUEwQixpQkFBakIsZ0JBQWdCLENBQUMiLCJmaWxlIjoibWV0aG9kcy9TaGFkb3dNZXRob2RCYXNlLmpzIiwic291cmNlUm9vdCI6Ii4uLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWZWN0b3IzRFx0XHRcdFx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1jb3JlL2xpYi9nZW9tL1ZlY3RvcjNEXCIpO1xuaW1wb3J0IEFic3RyYWN0TWV0aG9kRXJyb3JcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtY29yZS9saWIvZXJyb3JzL0Fic3RyYWN0TWV0aG9kRXJyb3JcIik7XG5pbXBvcnQgQ3ViZVRleHR1cmVCYXNlXHRcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtY29yZS9saWIvdGV4dHVyZXMvQ3ViZVRleHR1cmVCYXNlXCIpO1xuaW1wb3J0IFRleHR1cmUyREJhc2VcdFx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1jb3JlL2xpYi90ZXh0dXJlcy9UZXh0dXJlMkRCYXNlXCIpO1xuXG5pbXBvcnQgTGlnaHRCYXNlXHRcdFx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1kaXNwbGF5L2xpYi9iYXNlL0xpZ2h0QmFzZVwiKTtcbmltcG9ydCBDYW1lcmFcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtZGlzcGxheS9saWIvZW50aXRpZXMvQ2FtZXJhXCIpO1xuaW1wb3J0IERpcmVjdGlvbmFsTGlnaHRcdFx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1kaXNwbGF5L2xpYi9lbnRpdGllcy9EaXJlY3Rpb25hbExpZ2h0XCIpO1xuaW1wb3J0IFBvaW50TGlnaHRcdFx0XHRcdFx0PSByZXF1aXJlKFwiYXdheWpzLWRpc3BsYXkvbGliL2VudGl0aWVzL1BvaW50TGlnaHRcIik7XG5pbXBvcnQgRGlyZWN0aW9uYWxTaGFkb3dNYXBwZXJcdFx0PSByZXF1aXJlKFwiYXdheWpzLWRpc3BsYXkvbGliL21hdGVyaWFscy9zaGFkb3dtYXBwZXJzL0RpcmVjdGlvbmFsU2hhZG93TWFwcGVyXCIpO1xuXG5pbXBvcnQgU3RhZ2VcdFx0XHRcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtc3RhZ2VnbC9saWIvYmFzZS9TdGFnZVwiKTtcblxuaW1wb3J0IFJlbmRlcmFibGVCYXNlXHRcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtcmVuZGVyZXJnbC9saWIvcG9vbC9SZW5kZXJhYmxlQmFzZVwiKTtcbmltcG9ydCBTaGFkZXJMaWdodGluZ09iamVjdFx0XHRcdD0gcmVxdWlyZShcImF3YXlqcy1yZW5kZXJlcmdsL2xpYi9jb21waWxhdGlvbi9TaGFkZXJMaWdodGluZ09iamVjdFwiKTtcbmltcG9ydCBTaGFkZXJPYmplY3RCYXNlXHRcdFx0XHQ9IHJlcXVpcmUoXCJhd2F5anMtcmVuZGVyZXJnbC9saWIvY29tcGlsYXRpb24vU2hhZGVyT2JqZWN0QmFzZVwiKTtcbmltcG9ydCBTaGFkZXJSZWdpc3RlckNhY2hlXHRcdFx0PSByZXF1aXJlKFwiYXdheWpzLXJlbmRlcmVyZ2wvbGliL2NvbXBpbGF0aW9uL1NoYWRlclJlZ2lzdGVyQ2FjaGVcIik7XG5pbXBvcnQgU2hhZGVyUmVnaXN0ZXJEYXRhXHRcdFx0PSByZXF1aXJlKFwiYXdheWpzLXJlbmRlcmVyZ2wvbGliL2NvbXBpbGF0aW9uL1NoYWRlclJlZ2lzdGVyRGF0YVwiKTtcbmltcG9ydCBTaGFkZXJSZWdpc3RlckVsZW1lbnRcdFx0PSByZXF1aXJlKFwiYXdheWpzLXJlbmRlcmVyZ2wvbGliL2NvbXBpbGF0aW9uL1NoYWRlclJlZ2lzdGVyRWxlbWVudFwiKTtcblxuaW1wb3J0IE1ldGhvZFZPXHRcdFx0XHRcdFx0PSByZXF1aXJlKFwiYXdheWpzLW1ldGhvZG1hdGVyaWFscy9saWIvZGF0YS9NZXRob2RWT1wiKTtcbmltcG9ydCBTaGFkb3dNYXBNZXRob2RCYXNlXHRcdFx0PSByZXF1aXJlKFwiYXdheWpzLW1ldGhvZG1hdGVyaWFscy9saWIvbWV0aG9kcy9TaGFkb3dNYXBNZXRob2RCYXNlXCIpO1xuXG4vKipcbiAqIFNoYWRvd01ldGhvZEJhc2UgcHJvdmlkZXMgYW4gYWJzdHJhY3QgbWV0aG9kIGZvciBzaW1wbGUgKG5vbi13cmFwcGluZykgc2hhZG93IG1hcCBtZXRob2RzLlxuICovXG5jbGFzcyBTaGFkb3dNZXRob2RCYXNlIGV4dGVuZHMgU2hhZG93TWFwTWV0aG9kQmFzZVxue1xuXHRwdWJsaWMgX3BEZXB0aE1hcENvb3JkUmVnOlNoYWRlclJlZ2lzdGVyRWxlbWVudDtcblx0cHVibGljIF9wVXNlUG9pbnQ6Ym9vbGVhbjtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBTaGFkb3dNZXRob2RCYXNlIG9iamVjdC5cblx0ICogQHBhcmFtIGNhc3RpbmdMaWdodCBUaGUgbGlnaHQgdXNlZCB0byBjYXN0IHNoYWRvd3MuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihjYXN0aW5nTGlnaHQ6TGlnaHRCYXNlKVxuXHR7XG5cdFx0dGhpcy5fcFVzZVBvaW50ID0gKGNhc3RpbmdMaWdodCBpbnN0YW5jZW9mIFBvaW50TGlnaHQpO1xuXG5cdFx0c3VwZXIoY2FzdGluZ0xpZ2h0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0cHVibGljIGlJbml0Vk8oc2hhZGVyT2JqZWN0OlNoYWRlckxpZ2h0aW5nT2JqZWN0LCBtZXRob2RWTzpNZXRob2RWTylcblx0e1xuXHRcdG1ldGhvZFZPLm5lZWRzVmlldyA9IHRydWU7XG5cdFx0bWV0aG9kVk8ubmVlZHNHbG9iYWxWZXJ0ZXhQb3MgPSB0cnVlO1xuXHRcdG1ldGhvZFZPLm5lZWRzR2xvYmFsRnJhZ21lbnRQb3MgPSB0aGlzLl9wVXNlUG9pbnQ7XG5cdFx0bWV0aG9kVk8ubmVlZHNOb3JtYWxzID0gc2hhZGVyT2JqZWN0Lm51bUxpZ2h0cyA+IDA7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdHB1YmxpYyBpSW5pdENvbnN0YW50cyhzaGFkZXJPYmplY3Q6U2hhZGVyT2JqZWN0QmFzZSwgbWV0aG9kVk86TWV0aG9kVk8pXG5cdHtcblx0XHR2YXIgZnJhZ21lbnREYXRhOkFycmF5PG51bWJlcj4gPSBzaGFkZXJPYmplY3QuZnJhZ21lbnRDb25zdGFudERhdGE7XG5cdFx0dmFyIHZlcnRleERhdGE6QXJyYXk8bnVtYmVyPiA9IHNoYWRlck9iamVjdC52ZXJ0ZXhDb25zdGFudERhdGE7XG5cdFx0dmFyIGluZGV4Om51bWJlciAvKmludCovID0gbWV0aG9kVk8uZnJhZ21lbnRDb25zdGFudHNJbmRleDtcblx0XHRmcmFnbWVudERhdGFbaW5kZXhdID0gMS4wO1xuXHRcdGZyYWdtZW50RGF0YVtpbmRleCArIDFdID0gMS8yNTUuMDtcblx0XHRmcmFnbWVudERhdGFbaW5kZXggKyAyXSA9IDEvNjUwMjUuMDtcblx0XHRmcmFnbWVudERhdGFbaW5kZXggKyAzXSA9IDEvMTY1ODEzNzUuMDtcblxuXHRcdGZyYWdtZW50RGF0YVtpbmRleCArIDZdID0gMDtcblx0XHRmcmFnbWVudERhdGFbaW5kZXggKyA3XSA9IDE7XG5cblx0XHRpZiAodGhpcy5fcFVzZVBvaW50KSB7XG5cdFx0XHRmcmFnbWVudERhdGFbaW5kZXggKyA4XSA9IDA7XG5cdFx0XHRmcmFnbWVudERhdGFbaW5kZXggKyA5XSA9IDA7XG5cdFx0XHRmcmFnbWVudERhdGFbaW5kZXggKyAxMF0gPSAwO1xuXHRcdFx0ZnJhZ21lbnREYXRhW2luZGV4ICsgMTFdID0gMTtcblx0XHR9XG5cblx0XHRpbmRleCA9IG1ldGhvZFZPLnZlcnRleENvbnN0YW50c0luZGV4O1xuXHRcdGlmIChpbmRleCAhPSAtMSkge1xuXHRcdFx0dmVydGV4RGF0YVtpbmRleF0gPSAuNTtcblx0XHRcdHZlcnRleERhdGFbaW5kZXggKyAxXSA9IC41O1xuXHRcdFx0dmVydGV4RGF0YVtpbmRleCArIDJdID0gMC4wO1xuXHRcdFx0dmVydGV4RGF0YVtpbmRleCArIDNdID0gMS4wO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBXcmFwcGVycyB0aGF0IG92ZXJyaWRlIHRoZSB2ZXJ0ZXggc2hhZGVyIG5lZWQgdG8gc2V0IHRoaXMgZXhwbGljaXRseVxuXHQgKi9cblx0cHVibGljIGdldCBfaURlcHRoTWFwQ29vcmRSZWcoKTpTaGFkZXJSZWdpc3RlckVsZW1lbnRcblx0e1xuXHRcdHJldHVybiB0aGlzLl9wRGVwdGhNYXBDb29yZFJlZztcblx0fVxuXG5cdHB1YmxpYyBzZXQgX2lEZXB0aE1hcENvb3JkUmVnKHZhbHVlOlNoYWRlclJlZ2lzdGVyRWxlbWVudClcblx0e1xuXHRcdHRoaXMuX3BEZXB0aE1hcENvb3JkUmVnID0gdmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdHB1YmxpYyBpQ2xlYW5Db21waWxhdGlvbkRhdGEoKVxuXHR7XG5cdFx0c3VwZXIuaUNsZWFuQ29tcGlsYXRpb25EYXRhKCk7XG5cblx0XHR0aGlzLl9wRGVwdGhNYXBDb29yZFJlZyA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG5cdHB1YmxpYyBpR2V0VmVydGV4Q29kZShzaGFkZXJPYmplY3Q6U2hhZGVyT2JqZWN0QmFzZSwgbWV0aG9kVk86TWV0aG9kVk8sIHJlZ0NhY2hlOlNoYWRlclJlZ2lzdGVyQ2FjaGUsIHNoYXJlZFJlZ2lzdGVyczpTaGFkZXJSZWdpc3RlckRhdGEpOnN0cmluZ1xuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX3BVc2VQb2ludD8gdGhpcy5fcEdldFBvaW50VmVydGV4Q29kZShtZXRob2RWTywgcmVnQ2FjaGUsIHNoYXJlZFJlZ2lzdGVycyk6dGhpcy5wR2V0UGxhbmFyVmVydGV4Q29kZShtZXRob2RWTywgcmVnQ2FjaGUsIHNoYXJlZFJlZ2lzdGVycyk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgdmVydGV4IGNvZGUgZm9yIHNoYWRvdyBtYXBwaW5nIHdpdGggYSBwb2ludCBsaWdodC5cblx0ICpcblx0ICogQHBhcmFtIG1ldGhvZFZPIFRoZSBNZXRob2RWTyBvYmplY3QgbGlua2luZyB0aGlzIG1ldGhvZCB3aXRoIHRoZSBwYXNzIGN1cnJlbnRseSBiZWluZyBjb21waWxlZC5cblx0ICogQHBhcmFtIHJlZ0NhY2hlIFRoZSByZWdpc3RlciBjYWNoZSB1c2VkIGR1cmluZyB0aGUgY29tcGlsYXRpb24uXG5cdCAqL1xuXHRwdWJsaWMgX3BHZXRQb2ludFZlcnRleENvZGUobWV0aG9kVk86TWV0aG9kVk8sIHJlZ0NhY2hlOlNoYWRlclJlZ2lzdGVyQ2FjaGUsIHNoYXJlZFJlZ2lzdGVyczpTaGFkZXJSZWdpc3RlckRhdGEpOnN0cmluZ1xuXHR7XG5cdFx0bWV0aG9kVk8udmVydGV4Q29uc3RhbnRzSW5kZXggPSAtMTtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB2ZXJ0ZXggY29kZSBmb3Igc2hhZG93IG1hcHBpbmcgd2l0aCBhIHBsYW5hciBzaGFkb3cgbWFwIChmZTogZGlyZWN0aW9uYWwgbGlnaHRzKS5cblx0ICpcblx0ICogQHBhcmFtIG1ldGhvZFZPIFRoZSBNZXRob2RWTyBvYmplY3QgbGlua2luZyB0aGlzIG1ldGhvZCB3aXRoIHRoZSBwYXNzIGN1cnJlbnRseSBiZWluZyBjb21waWxlZC5cblx0ICogQHBhcmFtIHJlZ0NhY2hlIFRoZSByZWdpc3RlciBjYWNoZSB1c2VkIGR1cmluZyB0aGUgY29tcGlsYXRpb24uXG5cdCAqL1xuXHRwdWJsaWMgcEdldFBsYW5hclZlcnRleENvZGUobWV0aG9kVk86TWV0aG9kVk8sIHJlZ0NhY2hlOlNoYWRlclJlZ2lzdGVyQ2FjaGUsIHNoYXJlZFJlZ2lzdGVyczpTaGFkZXJSZWdpc3RlckRhdGEpOnN0cmluZ1xuXHR7XG5cdFx0dmFyIGNvZGU6c3RyaW5nID0gXCJcIjtcblx0XHR2YXIgdGVtcDpTaGFkZXJSZWdpc3RlckVsZW1lbnQgPSByZWdDYWNoZS5nZXRGcmVlVmVydGV4VmVjdG9yVGVtcCgpO1xuXHRcdHZhciBkYXRhUmVnOlNoYWRlclJlZ2lzdGVyRWxlbWVudCA9IHJlZ0NhY2hlLmdldEZyZWVWZXJ0ZXhDb25zdGFudCgpO1xuXHRcdHZhciBkZXB0aE1hcFByb2o6U2hhZGVyUmVnaXN0ZXJFbGVtZW50ID0gcmVnQ2FjaGUuZ2V0RnJlZVZlcnRleENvbnN0YW50KCk7XG5cdFx0cmVnQ2FjaGUuZ2V0RnJlZVZlcnRleENvbnN0YW50KCk7XG5cdFx0cmVnQ2FjaGUuZ2V0RnJlZVZlcnRleENvbnN0YW50KCk7XG5cdFx0cmVnQ2FjaGUuZ2V0RnJlZVZlcnRleENvbnN0YW50KCk7XG5cdFx0dGhpcy5fcERlcHRoTWFwQ29vcmRSZWcgPSByZWdDYWNoZS5nZXRGcmVlVmFyeWluZygpO1xuXHRcdG1ldGhvZFZPLnZlcnRleENvbnN0YW50c0luZGV4ID0gZGF0YVJlZy5pbmRleCo0O1xuXG5cdFx0Ly8gdG9kbzogY2FuIGVwc2lsb24gYmUgYXBwbGllZCBoZXJlIGluc3RlYWQgb2YgZnJhZ21lbnQgc2hhZGVyP1xuXG5cdFx0Y29kZSArPSBcIm00NCBcIiArIHRlbXAgKyBcIiwgXCIgKyBzaGFyZWRSZWdpc3RlcnMuZ2xvYmFsUG9zaXRpb25WZXJ0ZXggKyBcIiwgXCIgKyBkZXB0aE1hcFByb2ogKyBcIlxcblwiICsgXCJkaXYgXCIgKyB0ZW1wICsgXCIsIFwiICsgdGVtcCArIFwiLCBcIiArIHRlbXAgKyBcIi53XFxuXCIgKyBcIm11bCBcIiArIHRlbXAgKyBcIi54eSwgXCIgKyB0ZW1wICsgXCIueHksIFwiICsgZGF0YVJlZyArIFwiLnh5XFxuXCIgKyBcImFkZCBcIiArIHRoaXMuX3BEZXB0aE1hcENvb3JkUmVnICsgXCIsIFwiICsgdGVtcCArIFwiLCBcIiArIGRhdGFSZWcgKyBcIi54eHd6XFxuXCI7XG5cdFx0Ly9cInN1YiBcIiArIHRoaXMuX3BEZXB0aE1hcENvb3JkUmVnICsgXCIueiwgXCIgKyB0aGlzLl9wRGVwdGhNYXBDb29yZFJlZyArIFwiLnosIFwiICsgdGhpcy5fcERlcHRoTWFwQ29vcmRSZWcgKyBcIi53XFxuXCI7XG5cblx0XHRyZXR1cm4gY29kZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0cHVibGljIGlHZXRGcmFnbWVudENvZGUoc2hhZGVyT2JqZWN0OlNoYWRlck9iamVjdEJhc2UsIG1ldGhvZFZPOk1ldGhvZFZPLCB0YXJnZXRSZWc6U2hhZGVyUmVnaXN0ZXJFbGVtZW50LCByZWdpc3RlckNhY2hlOlNoYWRlclJlZ2lzdGVyQ2FjaGUsIHNoYXJlZFJlZ2lzdGVyczpTaGFkZXJSZWdpc3RlckRhdGEpOnN0cmluZ1xuXHR7XG5cdFx0dmFyIGNvZGU6c3RyaW5nID0gdGhpcy5fcFVzZVBvaW50PyB0aGlzLl9wR2V0UG9pbnRGcmFnbWVudENvZGUobWV0aG9kVk8sIHRhcmdldFJlZywgcmVnaXN0ZXJDYWNoZSwgc2hhcmVkUmVnaXN0ZXJzKTp0aGlzLl9wR2V0UGxhbmFyRnJhZ21lbnRDb2RlKG1ldGhvZFZPLCB0YXJnZXRSZWcsIHJlZ2lzdGVyQ2FjaGUsIHNoYXJlZFJlZ2lzdGVycyk7XG5cdFx0Y29kZSArPSBcImFkZCBcIiArIHRhcmdldFJlZyArIFwiLncsIFwiICsgdGFyZ2V0UmVnICsgXCIudywgZmNcIiArIChtZXRob2RWTy5mcmFnbWVudENvbnN0YW50c0luZGV4LzQgKyAxKSArIFwiLnlcXG5cIiArIFwic2F0IFwiICsgdGFyZ2V0UmVnICsgXCIudywgXCIgKyB0YXJnZXRSZWcgKyBcIi53XFxuXCI7XG5cdFx0cmV0dXJuIGNvZGU7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgZnJhZ21lbnQgY29kZSBmb3Igc2hhZG93IG1hcHBpbmcgd2l0aCBhIHBsYW5hciBzaGFkb3cgbWFwLlxuXHQgKiBAcGFyYW0gbWV0aG9kVk8gVGhlIE1ldGhvZFZPIG9iamVjdCBsaW5raW5nIHRoaXMgbWV0aG9kIHdpdGggdGhlIHBhc3MgY3VycmVudGx5IGJlaW5nIGNvbXBpbGVkLlxuXHQgKiBAcGFyYW0gcmVnQ2FjaGUgVGhlIHJlZ2lzdGVyIGNhY2hlIHVzZWQgZHVyaW5nIHRoZSBjb21waWxhdGlvbi5cblx0ICogQHBhcmFtIHRhcmdldFJlZyBUaGUgcmVnaXN0ZXIgdG8gY29udGFpbiB0aGUgc2hhZG93IGNvdmVyYWdlXG5cdCAqIEByZXR1cm5cblx0ICovXG5cdHB1YmxpYyBfcEdldFBsYW5hckZyYWdtZW50Q29kZShtZXRob2RWTzpNZXRob2RWTywgdGFyZ2V0UmVnOlNoYWRlclJlZ2lzdGVyRWxlbWVudCwgcmVnQ2FjaGU6U2hhZGVyUmVnaXN0ZXJDYWNoZSwgc2hhcmVkUmVnaXN0ZXJzOlNoYWRlclJlZ2lzdGVyRGF0YSk6c3RyaW5nXG5cdHtcblx0XHR0aHJvdyBuZXcgQWJzdHJhY3RNZXRob2RFcnJvcigpO1xuXHRcdHJldHVybiBcIlwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGZyYWdtZW50IGNvZGUgZm9yIHNoYWRvdyBtYXBwaW5nIHdpdGggYSBwb2ludCBsaWdodC5cblx0ICogQHBhcmFtIG1ldGhvZFZPIFRoZSBNZXRob2RWTyBvYmplY3QgbGlua2luZyB0aGlzIG1ldGhvZCB3aXRoIHRoZSBwYXNzIGN1cnJlbnRseSBiZWluZyBjb21waWxlZC5cblx0ICogQHBhcmFtIHJlZ0NhY2hlIFRoZSByZWdpc3RlciBjYWNoZSB1c2VkIGR1cmluZyB0aGUgY29tcGlsYXRpb24uXG5cdCAqIEBwYXJhbSB0YXJnZXRSZWcgVGhlIHJlZ2lzdGVyIHRvIGNvbnRhaW4gdGhlIHNoYWRvdyBjb3ZlcmFnZVxuXHQgKiBAcmV0dXJuXG5cdCAqL1xuXHRwdWJsaWMgX3BHZXRQb2ludEZyYWdtZW50Q29kZShtZXRob2RWTzpNZXRob2RWTywgdGFyZ2V0UmVnOlNoYWRlclJlZ2lzdGVyRWxlbWVudCwgcmVnQ2FjaGU6U2hhZGVyUmVnaXN0ZXJDYWNoZSwgc2hhcmVkUmVnaXN0ZXJzOlNoYWRlclJlZ2lzdGVyRGF0YSk6c3RyaW5nXG5cdHtcblx0XHR0aHJvdyBuZXcgQWJzdHJhY3RNZXRob2RFcnJvcigpO1xuXHRcdHJldHVybiBcIlwiO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRwdWJsaWMgaVNldFJlbmRlclN0YXRlKHNoYWRlck9iamVjdDpTaGFkZXJPYmplY3RCYXNlLCBtZXRob2RWTzpNZXRob2RWTywgcmVuZGVyYWJsZTpSZW5kZXJhYmxlQmFzZSwgc3RhZ2U6U3RhZ2UsIGNhbWVyYTpDYW1lcmEpXG5cdHtcblx0XHRpZiAoIXRoaXMuX3BVc2VQb2ludClcblx0XHRcdCg8RGlyZWN0aW9uYWxTaGFkb3dNYXBwZXI+IHRoaXMuX3BTaGFkb3dNYXBwZXIpLmlEZXB0aFByb2plY3Rpb24uY29weVJhd0RhdGFUbyhzaGFkZXJPYmplY3QudmVydGV4Q29uc3RhbnREYXRhLCBtZXRob2RWTy52ZXJ0ZXhDb25zdGFudHNJbmRleCArIDQsIHRydWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGZyYWdtZW50IGNvZGUgZm9yIGNvbWJpbmluZyB0aGlzIG1ldGhvZCB3aXRoIGEgY2FzY2FkZWQgc2hhZG93IG1hcCBtZXRob2QuXG5cdCAqIEBwYXJhbSBtZXRob2RWTyBUaGUgTWV0aG9kVk8gb2JqZWN0IGxpbmtpbmcgdGhpcyBtZXRob2Qgd2l0aCB0aGUgcGFzcyBjdXJyZW50bHkgYmVpbmcgY29tcGlsZWQuXG5cdCAqIEBwYXJhbSByZWdDYWNoZSBUaGUgcmVnaXN0ZXIgY2FjaGUgdXNlZCBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uLlxuXHQgKiBAcGFyYW0gZGVjb2RlUmVnaXN0ZXIgVGhlIHJlZ2lzdGVyIGNvbnRhaW5pbmcgdGhlIGRhdGEgdG8gZGVjb2RlIHRoZSBzaGFkb3cgbWFwIGRlcHRoIHZhbHVlLlxuXHQgKiBAcGFyYW0gZGVwdGhUZXh0dXJlIFRoZSB0ZXh0dXJlIGNvbnRhaW5pbmcgdGhlIHNoYWRvdyBtYXAuXG5cdCAqIEBwYXJhbSBkZXB0aFByb2plY3Rpb24gVGhlIHByb2plY3Rpb24gb2YgdGhlIGZyYWdtZW50IHJlbGF0aXZlIHRvIHRoZSBsaWdodC5cblx0ICogQHBhcmFtIHRhcmdldFJlZ2lzdGVyIFRoZSByZWdpc3RlciB0byBjb250YWluIHRoZSBzaGFkb3cgY292ZXJhZ2Vcblx0ICogQHJldHVyblxuXHQgKi9cblx0cHVibGljIF9pR2V0Q2FzY2FkZUZyYWdtZW50Q29kZShzaGFkZXJPYmplY3Q6U2hhZGVyT2JqZWN0QmFzZSwgbWV0aG9kVk86TWV0aG9kVk8sIGRlY29kZVJlZ2lzdGVyOlNoYWRlclJlZ2lzdGVyRWxlbWVudCwgZGVwdGhUZXh0dXJlOlNoYWRlclJlZ2lzdGVyRWxlbWVudCwgZGVwdGhQcm9qZWN0aW9uOlNoYWRlclJlZ2lzdGVyRWxlbWVudCwgdGFyZ2V0UmVnaXN0ZXI6U2hhZGVyUmVnaXN0ZXJFbGVtZW50LCByZWdpc3RlckNhY2hlOlNoYWRlclJlZ2lzdGVyQ2FjaGUsIHNoYXJlZFJlZ2lzdGVyczpTaGFkZXJSZWdpc3RlckRhdGEpOnN0cmluZ1xuXHR7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzaGFkb3cgbWV0aG9kIGlzIGluY29tcGF0aWJsZSB3aXRoIGNhc2NhZGUgc2hhZG93c1wiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0cHVibGljIGlBY3RpdmF0ZShzaGFkZXJPYmplY3Q6U2hhZGVyT2JqZWN0QmFzZSwgbWV0aG9kVk86TWV0aG9kVk8sIHN0YWdlOlN0YWdlKVxuXHR7XG5cdFx0dmFyIGZyYWdtZW50RGF0YTpBcnJheTxudW1iZXI+ID0gc2hhZGVyT2JqZWN0LmZyYWdtZW50Q29uc3RhbnREYXRhO1xuXHRcdHZhciBpbmRleDpudW1iZXIgLyppbnQqLyA9IG1ldGhvZFZPLmZyYWdtZW50Q29uc3RhbnRzSW5kZXg7XG5cblx0XHRpZiAodGhpcy5fcFVzZVBvaW50KVxuXHRcdFx0ZnJhZ21lbnREYXRhW2luZGV4ICsgNF0gPSAtTWF0aC5wb3coMS8oKDxQb2ludExpZ2h0PiB0aGlzLl9wQ2FzdGluZ0xpZ2h0KS5mYWxsT2ZmKnRoaXMuX3BFcHNpbG9uKSwgMik7XG5cdFx0ZWxzZVxuXHRcdFx0c2hhZGVyT2JqZWN0LnZlcnRleENvbnN0YW50RGF0YVttZXRob2RWTy52ZXJ0ZXhDb25zdGFudHNJbmRleCArIDNdID0gLTEvKCg8RGlyZWN0aW9uYWxTaGFkb3dNYXBwZXI+IHRoaXMuX3BTaGFkb3dNYXBwZXIpLmRlcHRoKnRoaXMuX3BFcHNpbG9uKTtcblxuXHRcdGZyYWdtZW50RGF0YVtpbmRleCArIDVdID0gMSAtIHRoaXMuX3BBbHBoYTtcblxuXHRcdGlmICh0aGlzLl9wVXNlUG9pbnQpIHtcblx0XHRcdHZhciBwb3M6VmVjdG9yM0QgPSB0aGlzLl9wQ2FzdGluZ0xpZ2h0LnNjZW5lUG9zaXRpb247XG5cdFx0XHRmcmFnbWVudERhdGFbaW5kZXggKyA4XSA9IHBvcy54O1xuXHRcdFx0ZnJhZ21lbnREYXRhW2luZGV4ICsgOV0gPSBwb3MueTtcblx0XHRcdGZyYWdtZW50RGF0YVtpbmRleCArIDEwXSA9IHBvcy56O1xuXHRcdFx0Ly8gdXNlZCB0byBkZWNvbXByZXNzIGRpc3RhbmNlXG5cdFx0XHR2YXIgZjpudW1iZXIgPSAoPFBvaW50TGlnaHQ+IHRoaXMuX3BDYXN0aW5nTGlnaHQpLmZhbGxPZmY7XG5cdFx0XHRmcmFnbWVudERhdGFbaW5kZXggKyAxMV0gPSAxLygyKmYqZik7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9wVXNlUG9pbnQpXG5cdFx0XHRzdGFnZS5hY3RpdmF0ZVJlbmRlclRleHR1cmUobWV0aG9kVk8udGV4dHVyZXNJbmRleCwgPFRleHR1cmUyREJhc2U+IHRoaXMuX3BDYXN0aW5nTGlnaHQuc2hhZG93TWFwcGVyLmRlcHRoTWFwKTtcblx0XHQvL2Vsc2Vcblx0XHQvL1x0c3RhZ2UuYWN0aXZhdGVDdWJlUmVuZGVyVGV4dHVyZShtZXRob2RWTy50ZXh0dXJlc0luZGV4LCA8Q3ViZVRleHR1cmVCYXNlPiB0aGlzLl9wQ2FzdGluZ0xpZ2h0LnNoYWRvd01hcHBlci5kZXB0aE1hcCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgbWV0aG9kIHN0YXRlIGZvciBjYXNjYWRlIHNoYWRvdyBtYXBwaW5nLlxuXHQgKi9cblx0cHVibGljIGlBY3RpdmF0ZUZvckNhc2NhZGUoc2hhZGVyT2JqZWN0OlNoYWRlck9iamVjdEJhc2UsIG1ldGhvZFZPOk1ldGhvZFZPLCBzdGFnZTpTdGFnZSlcblx0e1xuXHRcdHRocm93IG5ldyBFcnJvcihcIlRoaXMgc2hhZG93IG1ldGhvZCBpcyBpbmNvbXBhdGlibGUgd2l0aCBjYXNjYWRlIHNoYWRvd3NcIik7XG5cdH1cbn1cblxuZXhwb3J0ID0gU2hhZG93TWV0aG9kQmFzZTsiXX0=