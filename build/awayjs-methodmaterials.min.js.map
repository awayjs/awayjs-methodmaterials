{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "awayjs-methodmaterials.js",
    "../index.ts",
    "lib/MethodMaterialMode.ts",
    "lib/MethodMaterial.ts",
    "lib/lib/data/MethodVO.ts",
    "lib/data.ts",
    "lib/lib/methods/AmbientBasicMethod.ts",
    "lib/lib/methods/AmbientEnvMapMethod.ts",
    "lib/lib/methods/CurveBasicMethod.ts",
    "lib/lib/methods/DiffuseBasicMethod.ts",
    "lib/lib/methods/DiffuseCelMethod.ts",
    "lib/lib/methods/DiffuseCompositeMethod.ts",
    "lib/lib/methods/DiffuseDepthMethod.ts",
    "lib/lib/methods/DiffuseGradientMethod.ts",
    "lib/lib/methods/DiffuseLightMapMethod.ts",
    "lib/lib/methods/DiffuseSubSurfaceMethod.ts",
    "lib/lib/methods/DiffuseWrapMethod.ts",
    "lib/lib/methods/EffectAlphaMaskMethod.ts",
    "lib/lib/methods/EffectColorMatrixMethod.ts",
    "lib/lib/methods/EffectColorTransformMethod.ts",
    "lib/lib/methods/EffectEnvMapMethod.ts",
    "lib/lib/methods/EffectFogMethod.ts",
    "lib/lib/methods/EffectFresnelEnvMapMethod.ts",
    "lib/lib/methods/EffectLightMapMethod.ts",
    "lib/lib/methods/EffectMethodBase.ts",
    "lib/lib/methods/EffectRefractionEnvMapMethod.ts",
    "lib/lib/methods/EffectRimLightMethod.ts",
    "lib/lib/methods/LightingMethodBase.ts",
    "lib/lib/methods/NormalBasicMethod.ts",
    "lib/lib/methods/NormalHeightMapMethod.ts",
    "lib/lib/methods/NormalSimpleWaterMethod.ts",
    "lib/lib/methods/ShadingMethodBase.ts",
    "lib/lib/methods/ShadowCascadeMethod.ts",
    "lib/lib/methods/ShadowDitheredMethod.ts",
    "lib/lib/methods/ShadowFilteredMethod.ts",
    "lib/lib/methods/ShadowHardMethod.ts",
    "lib/lib/methods/ShadowMapMethodBase.ts",
    "lib/lib/methods/ShadowMethodBase.ts",
    "lib/lib/methods/ShadowNearMethod.ts",
    "lib/lib/methods/ShadowSoftMethod.ts",
    "lib/lib/methods/SpecularAnisotropicMethod.ts",
    "lib/lib/methods/SpecularBasicMethod.ts",
    "lib/lib/methods/SpecularCelMethod.ts",
    "lib/lib/methods/SpecularCompositeMethod.ts",
    "lib/lib/methods/SpecularFresnelMethod.ts",
    "lib/lib/methods/SpecularPhongMethod.ts",
    "lib/methods.ts",
    "lib/lib/surfaces/GL_MethodMaterialSurface.ts",
    "lib/surfaces/lib/surfaces/passes/MethodPassMode.ts",
    "lib/surfaces/lib/surfaces/passes/MethodPass.ts",
    "lib/surfaces/lib/surfaces/passes/SingleObjectDepthPass.ts",
    "lib/surfaces.ts"
  ],
  "names": [
    "require",
    "e",
    "t",
    "n",
    "r",
    "s",
    "o",
    "u",
    "a",
    "i",
    "f",
    "Error",
    "code",
    "l",
    "exports",
    "call",
    "length",
    1,
    "module",
    "data",
    "methods",
    "surfaces",
    "MethodMaterial_1",
    "MethodMaterial",
    "default",
    "MethodMaterialMode_1",
    "MethodMaterialMode",
    "SurfacePool_1",
    "registerAbstraction",
    "GL_MethodMaterialSurface",
    "awayjs-methodmaterials/lib/MethodMaterial",
    "awayjs-methodmaterials/lib/MethodMaterialMode",
    "awayjs-methodmaterials/lib/data",
    "awayjs-methodmaterials/lib/methods",
    "awayjs-methodmaterials/lib/surfaces",
    "awayjs-renderergl/lib/surfaces/SurfacePool",
    "undefined",
    "SINGLE_PASS",
    "MULTI_PASS",
    "Object",
    "defineProperty",
    "value",
    "__extends",
    "this",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "__",
    "constructor",
    "prototype",
    "create",
    "Image2D_1",
    "MaterialBase_1",
    "Single2DTexture_1",
    "ContextGLCompareMode_1",
    "AmbientBasicMethod_1",
    "DiffuseBasicMethod_1",
    "NormalBasicMethod_1",
    "SpecularBasicMethod_1",
    "_super",
    "imageColor",
    "alpha",
    "_effectMethods",
    "Array",
    "_ambientMethod",
    "_diffuseMethod",
    "_normalMethod",
    "_specularMethod",
    "_depthCompareMode",
    "LESS_EQUAL",
    "_mode",
    "iAddOwner",
    "texture",
    "get",
    "assetType",
    "enumerable",
    "configurable",
    "set",
    "invalidate",
    "iRemoveOwner",
    "_shadowMethod",
    "addEffectMethod",
    "method",
    "push",
    "getEffectMethodAt",
    "index",
    "addEffectMethodAt",
    "splice",
    "removeEffectMethod",
    "indexOf",
    "awayjs-core/lib/image/Image2D",
    "awayjs-display/lib/materials/MaterialBase",
    "awayjs-display/lib/textures/Single2DTexture",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod",
    "awayjs-stagegl/lib/base/ContextGLCompareMode",
    "awayjs-methodmaterials/lib/data/MethodVO",
    "MethodVO",
    "pass",
    "useMethod",
    "reset",
    "iReset",
    "vertexConstantsIndex",
    "secondaryVertexConstantsIndex",
    "fragmentConstantsIndex",
    "secondaryFragmentConstantsIndex",
    "needsProjection",
    "needsView",
    "needsNormals",
    "needsTangents",
    "needsGlobalVertexPos",
    "needsGlobalFragmentPos",
    "MethodVO_1",
    "AssetEvent_1",
    "ShadingMethodBase_1",
    "AmbientBasicMethod",
    "_alpha",
    "_colorR",
    "_colorG",
    "_colorB",
    "_strength",
    "iInitVO",
    "shader",
    "methodVO",
    "_texture",
    "textureGL",
    "getAbstraction",
    "uvDependencies",
    "onClear",
    "CLEAR",
    "iInitConstants",
    "_color",
    "numLights",
    "_surface",
    "style",
    "color",
    "updateColor",
    "iRemoveTexture",
    "iAddTexture",
    "iInvalidateShaderProgram",
    "copyFrom",
    "m",
    "iGetFragmentCode",
    "targetReg",
    "registerCache",
    "sharedRegisters",
    "_iGetFragmentCode",
    "uvVarying",
    "alphaThreshold",
    "cutOffReg",
    "getFreeFragmentConstant",
    "ambientInputRegister",
    "iActivate",
    "stage",
    "activate",
    "_render",
    "fragmentConstantData",
    "iSetRenderState",
    "renderable",
    "camera",
    "_setRenderState",
    "awayjs-core/lib/events/AssetEvent",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod",
    "AmbientEnvMapMethod",
    "regCache",
    "normalFragment",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod",
    "CurveBasicMethod",
    "_ambient",
    "LightingMethodBase_1",
    "DiffuseBasicMethod",
    "_multiply",
    "_ambientColorR",
    "_ambientColorG",
    "_ambientColorB",
    "iIsUsed",
    "usesCommonData",
    "_ambientColor",
    "updateAmbientColor",
    "dispose",
    "diff",
    "multiply",
    "iCleanCompilationData",
    "_pTotalLightColorReg",
    "iGetFragmentPreLightingCode",
    "_pIsFirstLight",
    "addFragmentTempUsages",
    "getFreeFragmentVectorTemp",
    "iGetFragmentCodePerLight",
    "lightDirReg",
    "lightColReg",
    "commons",
    "usesLightFallOff",
    "_iModulateMethod",
    "removeFragmentTempUsage",
    "iGetFragmentCodePerProbe",
    "cubeMapReg",
    "weightRegister",
    "iGetFragmentPostLightingCode",
    "diffuseColor",
    "shadowTarget",
    "pApplyShadow",
    "ambientColorRegister",
    "diffuseInputRegister",
    "ambientR",
    "ambientG",
    "ambientB",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod",
    "DiffuseCompositeMethod_1",
    "DiffuseCelMethod",
    "levels",
    "baseMethod",
    "_this",
    "_smoothness",
    "clampDiffuse",
    "_levels",
    "_dataReg",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod",
    "ShadingMethodEvent_1",
    "DiffuseCompositeMethod",
    "modulateMethod",
    "_onShaderInvalidatedDelegate",
    "event",
    "onShaderInvalidated",
    "pBaseMethod",
    "addEventListener",
    "SHADER_INVALIDATED",
    "removeEventListener",
    "owner",
    "iDeactivate",
    "iGetVertexCode",
    "awayjs-renderergl/lib/events/ShadingMethodEvent",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod",
    "DiffuseDepthMethod",
    "temp",
    "decReg",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod",
    "DiffuseGradientMethod",
    "gradient",
    "_gradient",
    "secondaryTextureGL",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod",
    "DiffuseLightMapMethod",
    "lightMap",
    "blendMode",
    "useSecondaryUV",
    "_useSecondaryUV",
    "_lightMap",
    "secondaryUVDependencies",
    "_blendMode",
    "ADD",
    "MULTIPLY",
    "secondaryUVVarying",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod",
    "DiffuseSubSurfaceMethod",
    "depthMapSize",
    "depthMapOffset",
    "_translucency",
    "_scatterColor",
    "_scatterR",
    "_scatterG",
    "_scatterB",
    "scatterLight",
    "_scattering",
    "vertexConstantData",
    "_lightProjVarying",
    "_propReg",
    "_lightColorReg",
    "_colorReg",
    "_decReg",
    "_targetReg",
    "scatterColor",
    "lightProjection",
    "toTexRegister",
    "getFreeVertexVectorTemp",
    "getFreeVertexConstant",
    "getFreeVarying",
    "viewDirFragment",
    "_depthPass",
    "_iGetDepthMap",
    "_iGetProjection",
    "copyRawDataTo",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod",
    "DiffuseWrapMethod",
    "wrapFactor",
    "_wrapDataRegister",
    "_wrapFactor",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod",
    "EffectMethodBase_1",
    "EffectAlphaMaskMethod",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod",
    "EffectColorMatrixMethod",
    "matrix",
    "_matrix",
    "colorMultReg",
    "colorOffsetReg",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod",
    "EffectColorTransformMethod",
    "_colorTransform",
    "colorOffsReg",
    "inv",
    "redMultiplier",
    "greenMultiplier",
    "blueMultiplier",
    "alphaMultiplier",
    "redOffset",
    "greenOffset",
    "blueOffset",
    "alphaOffset",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod",
    "EffectEnvMapMethod",
    "envMap",
    "_envMap",
    "_mask",
    "dataRegister",
    "temp2",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod",
    "EffectFogMethod",
    "minDistance",
    "maxDistance",
    "fogColor",
    "_minDistance",
    "_maxDistance",
    "_fogColor",
    "_fogR",
    "_fogG",
    "_fogB",
    "fogData",
    "projectionFragment",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod",
    "EffectFresnelEnvMapMethod",
    "_fresnelPower",
    "_normalReflectance",
    "viewDirReg",
    "normalReg",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod",
    "EffectLightMapMethod",
    "AbstractMethodError_1",
    "EffectMethodBase",
    "awayjs-core/lib/errors/AbstractMethodError",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod",
    "EffectRefractionEnvMapMethod",
    "refractionIndex",
    "dispersionR",
    "dispersionG",
    "dispersionB",
    "_dispersionR",
    "_dispersionG",
    "_dispersionB",
    "_useDispersion",
    "_refractionIndex",
    "useDispersion",
    "data2",
    "refractionDir",
    "refractionColor",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod",
    "EffectRimLightMethod",
    "strength",
    "power",
    "blend",
    "_power",
    "dataRegister2",
    "MIX",
    "LightingMethodBase",
    "NormalBasicMethod",
    "normalDependencies",
    "iOutputsTangentNormals",
    "bnm",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod",
    "NormalHeightMapMethod",
    "heightMap",
    "worldWidth",
    "worldHeight",
    "worldDepth",
    "_worldXYRatio",
    "_worldXZRatio",
    "image2D",
    "width",
    "height",
    "dataReg",
    "dataReg2",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod",
    "NormalSimpleWaterMethod",
    "normalMap",
    "secondaryNormalMap",
    "_water1OffsetX",
    "_water1OffsetY",
    "_water2OffsetX",
    "_water2OffsetY",
    "_secondaryNormalMap",
    "AssetBase_1",
    "ShadingMethodBase",
    "_textures",
    "_owners",
    "_counts",
    "iUsesTangentSpace",
    "len",
    "addTexture",
    "removeTexture",
    "dispatchEvent",
    "awayjs-core/lib/library/AssetBase",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod",
    "DirectionalLight_1",
    "ShadowMapMethodBase_1",
    "ShadowCascadeMethod",
    "shadowMethodBase",
    "castingLight",
    "_baseMethod",
    "_pCastingLight",
    "_cascadeShadowMapper",
    "shadowMapper",
    "INVALIDATE",
    "onCascadeChange",
    "tempVO",
    "depthMap",
    "fragmentData",
    "vertexData",
    "_cascadeProjections",
    "_depthMapCoordVaryings",
    "initProjectionsRegs",
    "numCascades",
    "globalPositionVertex",
    "planeDistanceReg",
    "planeDistances",
    "inQuad",
    "uvCoord",
    "uvProjection",
    "_iGetCascadeFragmentCode",
    "vertexIndex",
    "depth",
    "_pEpsilon",
    "k",
    "getDepthProjections",
    "fragmentIndex",
    "_pAlpha",
    "nearPlaneDistances",
    "_iNearPlaneDistances",
    "iActivateForCascade",
    "awayjs-display/lib/display/DirectionalLight",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod",
    "BitmapImage2D_1",
    "ShadowMethodBase_1",
    "ShadowDitheredMethod",
    "numSamples",
    "range",
    "_depthMapSize",
    "_grainUsages",
    "_grainTexture",
    "initGrainTexture",
    "_numSamples",
    "_range",
    "_grainBitmapImage2D",
    "vec",
    "step",
    "g",
    "Math",
    "random",
    "floor",
    "setArray",
    "rect",
    "_pGetPlanarFragmentCode",
    "customDataReg",
    "getSampleCode",
    "uvReg",
    "projectionReg",
    "_pDepthMapCoordReg",
    "addSample",
    "decodeRegister",
    "depthProjection",
    "targetRegister",
    "awayjs-core/lib/image/BitmapImage2D",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod",
    "ShadowFilteredMethod",
    "size",
    "depthCol",
    "predicate",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod",
    "ShadowHardMethod",
    "_pGetPointFragmentCode",
    "epsReg",
    "posReg",
    "depthSampleCol",
    "lightDir",
    "globalPositionVarying",
    "ShadowMapMethodBase",
    "shadowsEnabled",
    "_pShadowMapper",
    "PointLight_1",
    "ShadowMethodBase",
    "_pUsePoint",
    "_pGetPointVertexCode",
    "pGetPlanarVertexCode",
    "depthMapProj",
    "iDepthProjection",
    "pow",
    "fallOff",
    "pos",
    "scenePosition",
    "x",
    "y",
    "z",
    "awayjs-display/lib/display/PointLight",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod",
    "ShadowNearMethod",
    "fadeRatio",
    "_fadeRatio",
    "_nearShadowMapper",
    "epsilon",
    "getFreeFragmentSingleTemp",
    "near",
    "projection",
    "far",
    "coverageRatio",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod",
    "PoissonLookup_1",
    "ShadowSoftMethod",
    "_offsets",
    "getDistribution",
    "texRange",
    "offsets",
    "numRegs",
    "reg",
    "awayjs-core/lib/geom/PoissonLookup",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod",
    "SpecularAnisotropicMethod",
    "tangentVarying",
    "_pSpecularTexData",
    "_pSpecularDataRegister",
    "SpecularBasicMethod",
    "_gloss",
    "_iSpecularR",
    "_iSpecularG",
    "_iSpecularB",
    "updateSpecular",
    "bsm",
    "spec",
    "gloss",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod",
    "SpecularCompositeMethod_1",
    "SpecularCelMethod",
    "specularCutOff",
    "_specularCutOff",
    "clampSpecular",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod",
    "SpecularCompositeMethod",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod",
    "SpecularFresnelMethod",
    "basedOnSurface",
    "modulateSpecular",
    "_incidentLight",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod",
    "SpecularPhongMethod",
    "AmbientEnvMapMethod_1",
    "CurveBasicMethod_1",
    "DiffuseCelMethod_1",
    "DiffuseDepthMethod_1",
    "DiffuseGradientMethod_1",
    "DiffuseLightMapMethod_1",
    "DiffuseSubSurfaceMethod_1",
    "DiffuseWrapMethod_1",
    "EffectAlphaMaskMethod_1",
    "EffectColorMatrixMethod_1",
    "EffectColorTransformMethod_1",
    "EffectEnvMapMethod_1",
    "EffectFogMethod_1",
    "EffectFresnelEnvMapMethod_1",
    "EffectLightMapMethod_1",
    "EffectRefractionEnvMapMethod_1",
    "EffectRimLightMethod_1",
    "NormalHeightMapMethod_1",
    "NormalSimpleWaterMethod_1",
    "ShadowCascadeMethod_1",
    "ShadowDitheredMethod_1",
    "ShadowFilteredMethod_1",
    "ShadowHardMethod_1",
    "ShadowNearMethod_1",
    "ShadowSoftMethod_1",
    "SpecularAnisotropicMethod_1",
    "SpecularCelMethod_1",
    "SpecularFresnelMethod_1",
    "SpecularPhongMethod_1",
    "awayjs-methodmaterials/lib/surfaces/GL_MethodMaterialSurface",
    "BlendMode_1",
    "StaticLightPicker_1",
    "GL_SurfaceBase_1",
    "MethodPassMode_1",
    "MethodPass_1",
    "material",
    "elementsClass",
    "pool",
    "_material",
    "lightPicker",
    "numLightProbes",
    "numDirectionalLights",
    "numPointLights",
    "numCastingDirectionalLights",
    "numCastingPointLights",
    "_pUpdateRender",
    "initPasses",
    "setBlendAndCompareModes",
    "_pClearPasses",
    "mode",
    "_casterLightPass",
    "_pAddPass",
    "_nonCasterLightPasses",
    "_pass",
    "numEffectMethods",
    "initEffectPass",
    "removeEffectPass",
    "shadowMethod",
    "initCasterLightPass",
    "removeCasterLightPass",
    "numNonCasters",
    "initNonCasterLightPasses",
    "removeNonCasterLightPasses",
    "forceSeparateMVP",
    "Boolean",
    "setBlendMode",
    "NORMAL",
    "depthCompareMode",
    "firstAdditiveIndex",
    "_pRequiresBlending",
    "EFFECTS",
    "LAYER",
    "alphaBlending",
    "colorTransform",
    "SUPER_SHADER",
    "preserveAlpha",
    "LIGHTING",
    "_elementsClass",
    "_stage",
    "diffuseMethod",
    "ambientMethod",
    "normalMethod",
    "specularMethod",
    "_pRemovePass",
    "numDirLights",
    "dirLightOffset",
    "pointLightOffset",
    "probeOffset",
    "includeCasters",
    "directionalLightsOffset",
    "pointLightsOffset",
    "lightProbesOffset",
    "effectMethod",
    "max",
    "removeEffectMethodAt",
    "awayjs-core/lib/image/BlendMode",
    "awayjs-display/lib/materials/lightpickers/StaticLightPicker",
    "awayjs-methodmaterials/lib/surfaces/passes/MethodPass",
    "awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode",
    "awayjs-renderergl/lib/surfaces/GL_SurfaceBase",
    "PassMode",
    "LightSources_1",
    "LightingShader_1",
    "ShaderBase_1",
    "PassBase_1",
    "MethodPass",
    "render",
    "renderOwner",
    "_maxLights",
    "_includeCasters",
    "_iMethodVOs",
    "_numEffectDependencies",
    "_onLightsChangeDelegate",
    "onLightsChange",
    "_onMethodInvalidatedDelegate",
    "onMethodInvalidated",
    "_shader",
    "_updateShader",
    "_updateLights",
    "_lightPicker",
    "enableLightFallOff",
    "diffuseLightSources",
    "specularLightSources",
    "_iInitConstantData",
    "colorTransformMethod",
    "_iColorTransformMethodVO",
    "_removeDependency",
    "_addDependency",
    "effectsDependency",
    "hasEffectMethod",
    "getDependencyForMethod",
    "_iNormalMethodVO",
    "_iAmbientMethodVO",
    "_iShadowMethodVO",
    "_iDiffuseMethodVO",
    "_iSpecularMethodVO",
    "_iActivate",
    "_iRender",
    "viewProjection",
    "_iDeactivate",
    "_iIncludeDependencies",
    "usesFragmentAnimation",
    "useAlphaPremultiplied",
    "usesBlending",
    "setupAndCountDependencies",
    "usesTangentSpace",
    "outputsNormals",
    "outputsTangentNormals",
    "usesProbes",
    "viewDirDependencies",
    "globalPosDependencies",
    "usesLights",
    "usesGlobalPosFragment",
    "projectionDependencies",
    "tangentDependencies",
    "_iGetPreLightingVertexCode",
    "_iGetPreLightingFragmentCode",
    "shadedTarget",
    "_iGetPerLightDiffuseFragmentCode",
    "diffuseColorReg",
    "_iGetPerLightSpecularFragmentCode",
    "specularColorReg",
    "_iGetPerProbeDiffuseFragmentCode",
    "texReg",
    "weightReg",
    "_iGetPerProbeSpecularFragmentCode",
    "_iGetPostLightingVertexCode",
    "_iGetPostLightingFragmentCode",
    "_iGetNormalVertexCode",
    "_iGetNormalFragmentCode",
    "removeVertexTempUsage",
    "_iGetVertexCode",
    "sharedReg",
    "alphaReg",
    "_iUsesShadows",
    "castingDirectionalLights",
    "castingPointLights",
    "_iUsesSpecular",
    "_iUsesDiffuse",
    "numDirectionalLightsOld",
    "numPointLightsOld",
    "numLightProbesOld",
    "calculateNumDirectionalLights",
    "calculateNumPointLights",
    "calculateNumProbes",
    "min",
    "numFree",
    "numChannels",
    "PROBES",
    "awayjs-display/lib/materials/LightSources",
    "awayjs-renderergl/lib/shaders/LightingShader",
    "awayjs-renderergl/lib/shaders/ShaderBase",
    "awayjs-renderergl/lib/surfaces/passes/PassBase",
    "awayjs-methodmaterials/lib/surfaces/passes/SingleObjectDepthPass",
    "Matrix3D_1",
    "ContextGLDrawMode_1",
    "ContextGLProgramType_1",
    "SingleObjectDepthPass",
    "_textureSize",
    "_polyOffset",
    "Float32Array",
    "_projectionTexturesInvalid",
    "key",
    "updateProjectionTextures",
    "_projections",
    "renderableGL",
    "id",
    "context",
    "light",
    "lights",
    "allPickedLights",
    "rId",
    "iGetObjectProjectionMatrix",
    "sourceEntity",
    "sceneTransform",
    "setRenderTarget",
    "clear",
    "setProgramConstantsFromMatrix",
    "VERTEX",
    "setProgramConstantsFromArray",
    "FRAGMENT",
    "_enc",
    "elements",
    "elementsGL",
    "_elementsPool",
    "activateVertexBufferVO",
    "positions",
    "normals",
    "getIndexBufferGL",
    "draw",
    "TRIANGLES",
    "numElements",
    "awayjs-core/lib/geom/Matrix3D",
    "awayjs-stagegl/lib/base/ContextGLDrawMode",
    "awayjs-stagegl/lib/base/ContextGLProgramType",
    "MethodPassMode",
    "SingleObjectDepthPass_1",
    "GL_MethodMaterialSurface_1"
  ],
  "mappings": "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",
  "file": "awayjs-methodmaterials.min.js",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\nvar data = require(\"awayjs-methodmaterials/lib/data\");\nexports.data = data;\nvar methods = require(\"awayjs-methodmaterials/lib/methods\");\nexports.methods = methods;\nvar surfaces = require(\"awayjs-methodmaterials/lib/surfaces\");\nexports.surfaces = surfaces;\nvar MethodMaterial_1 = require(\"awayjs-methodmaterials/lib/MethodMaterial\");\nexports.MethodMaterial = MethodMaterial_1.default;\nvar MethodMaterialMode_1 = require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\nexports.MethodMaterialMode = MethodMaterialMode_1.default;\nvar SurfacePool_1 = require(\"awayjs-renderergl/lib/surfaces/SurfacePool\");\nSurfacePool_1.default.registerAbstraction(surfaces.GL_MethodMaterialSurface, MethodMaterial_1.default);\n\n},{\"awayjs-methodmaterials/lib/MethodMaterial\":\"awayjs-methodmaterials/lib/MethodMaterial\",\"awayjs-methodmaterials/lib/MethodMaterialMode\":\"awayjs-methodmaterials/lib/MethodMaterialMode\",\"awayjs-methodmaterials/lib/data\":\"awayjs-methodmaterials/lib/data\",\"awayjs-methodmaterials/lib/methods\":\"awayjs-methodmaterials/lib/methods\",\"awayjs-methodmaterials/lib/surfaces\":\"awayjs-methodmaterials/lib/surfaces\",\"awayjs-renderergl/lib/surfaces/SurfacePool\":undefined}],\"awayjs-methodmaterials/lib/MethodMaterialMode\":[function(require,module,exports){\n\"use strict\";\nvar MethodMaterialMode = (function () {\n    function MethodMaterialMode() {\n    }\n    /**\n     *\n     */\n    MethodMaterialMode.SINGLE_PASS = \"singlePass\";\n    /**\n     *\n     */\n    MethodMaterialMode.MULTI_PASS = \"multiPass\";\n    return MethodMaterialMode;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = MethodMaterialMode;\n\n},{}],\"awayjs-methodmaterials/lib/MethodMaterial\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Image2D_1 = require(\"awayjs-core/lib/image/Image2D\");\nvar MaterialBase_1 = require(\"awayjs-display/lib/materials/MaterialBase\");\nvar Single2DTexture_1 = require(\"awayjs-display/lib/textures/Single2DTexture\");\nvar ContextGLCompareMode_1 = require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\nvar MethodMaterialMode_1 = require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\nvar AmbientBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nvar DiffuseBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nvar NormalBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nvar SpecularBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n/**\n * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,\n * using material methods to define their appearance.\n */\nvar MethodMaterial = (function (_super) {\n    __extends(MethodMaterial, _super);\n    function MethodMaterial(imageColor, alpha) {\n        if (imageColor === void 0) { imageColor = null; }\n        if (alpha === void 0) { alpha = 1; }\n        _super.call(this, imageColor, alpha);\n        this._effectMethods = new Array();\n        this._ambientMethod = new AmbientBasicMethod_1.default();\n        this._diffuseMethod = new DiffuseBasicMethod_1.default();\n        this._normalMethod = new NormalBasicMethod_1.default();\n        this._specularMethod = new SpecularBasicMethod_1.default();\n        this._depthCompareMode = ContextGLCompareMode_1.default.LESS_EQUAL;\n        this._mode = MethodMaterialMode_1.default.SINGLE_PASS;\n        //add default methods owners\n        this._ambientMethod.iAddOwner(this);\n        this._diffuseMethod.iAddOwner(this);\n        this._normalMethod.iAddOwner(this);\n        this._specularMethod.iAddOwner(this);\n        //set a texture if an image is present\n        if (imageColor instanceof Image2D_1.default)\n            this._ambientMethod.texture = new Single2DTexture_1.default();\n    }\n    Object.defineProperty(MethodMaterial.prototype, \"assetType\", {\n        /**\n         *\n         */\n        get: function () {\n            return MethodMaterial.assetType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"mode\", {\n        get: function () {\n            return this._mode;\n        },\n        set: function (value) {\n            if (this._mode == value)\n                return;\n            this._mode = value;\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"depthCompareMode\", {\n        /**\n         * The depth compare mode used to render the renderables using this material.\n         *\n         * @see away.stagegl.ContextGLCompareMode\n         */\n        get: function () {\n            return this._depthCompareMode;\n        },\n        set: function (value) {\n            if (this._depthCompareMode == value)\n                return;\n            this._depthCompareMode = value;\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"diffuseTexture\", {\n        /**\n         * The texture object to use for the ambient colour.\n         */\n        get: function () {\n            return this._diffuseMethod.texture;\n        },\n        set: function (value) {\n            this._diffuseMethod.texture = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"ambientMethod\", {\n        /**\n         * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n         */\n        get: function () {\n            return this._ambientMethod;\n        },\n        set: function (value) {\n            if (this._ambientMethod == value)\n                return;\n            if (this._ambientMethod)\n                this._ambientMethod.iRemoveOwner(this);\n            this._ambientMethod = value;\n            if (this._ambientMethod)\n                this._ambientMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"shadowMethod\", {\n        /**\n         * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n         */\n        get: function () {\n            return this._shadowMethod;\n        },\n        set: function (value) {\n            if (this._shadowMethod == value)\n                return;\n            if (this._shadowMethod)\n                this._shadowMethod.iRemoveOwner(this);\n            this._shadowMethod = value;\n            if (this._shadowMethod)\n                this._shadowMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"diffuseMethod\", {\n        /**\n         * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n         */\n        get: function () {\n            return this._diffuseMethod;\n        },\n        set: function (value) {\n            if (this._diffuseMethod == value)\n                return;\n            if (this._diffuseMethod)\n                this._diffuseMethod.iRemoveOwner(this);\n            this._diffuseMethod = value;\n            if (this._diffuseMethod)\n                this._diffuseMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"specularMethod\", {\n        /**\n         * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n         */\n        get: function () {\n            return this._specularMethod;\n        },\n        set: function (value) {\n            if (this._specularMethod == value)\n                return;\n            if (this._specularMethod)\n                this._specularMethod.iRemoveOwner(this);\n            this._specularMethod = value;\n            if (this._specularMethod)\n                this._specularMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"normalMethod\", {\n        /**\n         * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n         */\n        get: function () {\n            return this._normalMethod;\n        },\n        set: function (value) {\n            if (this._normalMethod == value)\n                return;\n            if (this._normalMethod)\n                this._normalMethod.iRemoveOwner(this);\n            this._normalMethod = value;\n            if (this._normalMethod)\n                this._normalMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"numEffectMethods\", {\n        get: function () {\n            return this._effectMethods.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n     * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n     * methods added prior.\n     */\n    MethodMaterial.prototype.addEffectMethod = function (method) {\n        method.iAddOwner(this);\n        this._effectMethods.push(method);\n        this.invalidate();\n    };\n    /**\n     * Returns the method added at the given index.\n     * @param index The index of the method to retrieve.\n     * @return The method at the given index.\n     */\n    MethodMaterial.prototype.getEffectMethodAt = function (index) {\n        return this._effectMethods[index];\n    };\n    /**\n     * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n     * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n     * etc. The method will be applied to the result of the methods with a lower index.\n     */\n    MethodMaterial.prototype.addEffectMethodAt = function (method, index) {\n        method.iAddOwner(this);\n        this._effectMethods.splice(index, 0, method);\n        this.invalidate();\n    };\n    /**\n     * Removes an effect method from the material.\n     * @param method The method to be removed.\n     */\n    MethodMaterial.prototype.removeEffectMethod = function (method) {\n        method.iRemoveOwner(this);\n        this._effectMethods.splice(this._effectMethods.indexOf(method), 1);\n        this.invalidate();\n    };\n    MethodMaterial.assetType = \"[materials MethodMaterial]\";\n    return MethodMaterial;\n}(MaterialBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = MethodMaterial;\n\n},{\"awayjs-core/lib/image/Image2D\":undefined,\"awayjs-display/lib/materials/MaterialBase\":undefined,\"awayjs-display/lib/textures/Single2DTexture\":undefined,\"awayjs-methodmaterials/lib/MethodMaterialMode\":\"awayjs-methodmaterials/lib/MethodMaterialMode\",\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\":\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\",\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\",\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\":\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\",\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\",\"awayjs-stagegl/lib/base/ContextGLCompareMode\":undefined}],\"awayjs-methodmaterials/lib/data/MethodVO\":[function(require,module,exports){\n\"use strict\";\n/**\n * MethodVO contains data for a given shader object for the use within a single material.\n * This allows shader methods to be shared across materials while their non-public state differs.\n */\nvar MethodVO = (function () {\n    /**\n     * Creates a new MethodVO object.\n     */\n    function MethodVO(method, pass) {\n        this.useMethod = true;\n        this.method = method;\n        this.pass = pass;\n    }\n    /**\n     * Resets the values of the value object to their \"unused\" state.\n     */\n    MethodVO.prototype.reset = function () {\n        this.method.iReset();\n        this.vertexConstantsIndex = -1;\n        this.secondaryVertexConstantsIndex = -1;\n        this.fragmentConstantsIndex = -1;\n        this.secondaryFragmentConstantsIndex = -1;\n        this.needsProjection = false;\n        this.needsView = false;\n        this.needsNormals = false;\n        this.needsTangents = false;\n        this.needsGlobalVertexPos = false;\n        this.needsGlobalFragmentPos = false;\n    };\n    return MethodVO;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = MethodVO;\n\n},{}],\"awayjs-methodmaterials/lib/data\":[function(require,module,exports){\n\"use strict\";\nvar MethodVO_1 = require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nexports.MethodVO = MethodVO_1.default;\n\n},{\"awayjs-methodmaterials/lib/data/MethodVO\":\"awayjs-methodmaterials/lib/data/MethodVO\"}],\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar ShadingMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nvar AmbientBasicMethod = (function (_super) {\n    __extends(AmbientBasicMethod, _super);\n    /**\n     * Creates a new AmbientBasicMethod object.\n     */\n    function AmbientBasicMethod() {\n        _super.call(this);\n        this._alpha = 1;\n        this._colorR = 1;\n        this._colorG = 1;\n        this._colorB = 1;\n        this._strength = 1;\n    }\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, this._texture));\n            methodVO.textureGL = null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.iInitConstants = function (shader, methodVO) {\n        if (!methodVO.textureGL) {\n            this._color = shader.numLights ? 0xFFFFFF : methodVO.pass._surface.style.color;\n            this.updateColor();\n        }\n    };\n    Object.defineProperty(AmbientBasicMethod.prototype, \"strength\", {\n        /**\n         * The strength of the ambient reflection of the surface.\n         */\n        get: function () {\n            return this._strength;\n        },\n        set: function (value) {\n            if (this._strength == value)\n                return;\n            this._strength = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AmbientBasicMethod.prototype, \"alpha\", {\n        /**\n         * The alpha component of the surface.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            if (this._alpha == value)\n                return;\n            this._alpha = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AmbientBasicMethod.prototype, \"texture\", {\n        /**\n         * The texture to use to define the diffuse reflection color per texel.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.copyFrom = function (method) {\n        var m = method;\n        var b = m;\n    };\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (methodVO.textureGL) {\n            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n            if (shader.alphaThreshold > 0) {\n                var cutOffReg = registerCache.getFreeFragmentConstant();\n                methodVO.fragmentConstantsIndex = cutOffReg.index * 4;\n                code += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n                    \"kil \" + targetReg + \".w\\n\" +\n                    \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n            }\n        }\n        else {\n            var ambientInputRegister = registerCache.getFreeFragmentConstant();\n            methodVO.fragmentConstantsIndex = ambientInputRegister.index * 4;\n            code += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n        }\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (methodVO.textureGL) {\n            methodVO.textureGL.activate(methodVO.pass._render);\n            if (shader.alphaThreshold > 0)\n                shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n        }\n        else {\n            var index = methodVO.fragmentConstantsIndex;\n            var data = shader.fragmentConstantData;\n            data[index] = this._colorR;\n            data[index + 1] = this._colorG;\n            data[index + 2] = this._colorB;\n            data[index + 3] = this._alpha;\n        }\n    };\n    AmbientBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (methodVO.textureGL)\n            methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Updates the ambient color data used by the render state.\n     */\n    AmbientBasicMethod.prototype.updateColor = function () {\n        this._colorR = ((this._color >> 16) & 0xff) / 0xff * this._strength;\n        this._colorG = ((this._color >> 8) & 0xff) / 0xff * this._strength;\n        this._colorB = (this._color & 0xff) / 0xff * this._strength;\n    };\n    return AmbientBasicMethod;\n}(ShadingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = AmbientBasicMethod;\n\n},{\"awayjs-core/lib/events/AssetEvent\":undefined,\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar AmbientBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\n/**\n * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to\n * approximate global lighting rather than lights.\n */\nvar AmbientEnvMapMethod = (function (_super) {\n    __extends(AmbientEnvMapMethod, _super);\n    /**\n     * Creates a new <code>AmbientEnvMapMethod</code> object.\n     *\n     * @param envMap The cube environment map to use for the ambient lighting.\n     */\n    function AmbientEnvMapMethod() {\n        _super.call(this);\n    }\n    /**\n     * @inheritDoc\n     */\n    AmbientEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, this._texture));\n            methodVO.textureGL = null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    AmbientEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        return (this._texture) ? methodVO.textureGL._iGetFragmentCode(targetReg, regCache, sharedRegisters, sharedRegisters.normalFragment) : \"\";\n    };\n    return AmbientEnvMapMethod;\n}(AmbientBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = AmbientEnvMapMethod;\n\n},{\"awayjs-core/lib/events/AssetEvent\":undefined,\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\":\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/CurveBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar ShadingMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nvar CurveBasicMethod = (function (_super) {\n    __extends(CurveBasicMethod, _super);\n    /**\n     * Creates a new AmbientBasicMethod object.\n     */\n    function CurveBasicMethod() {\n        _super.call(this);\n        this._color = 0xffffff;\n        this._alpha = 1;\n        this._colorR = 1;\n        this._colorG = 1;\n        this._colorB = 1;\n        this._ambient = 1;\n    }\n    /**\n     * @inheritDoc\n     */\n    CurveBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, this._texture));\n            methodVO.textureGL = null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    CurveBasicMethod.prototype.iInitConstants = function (shader, methodVO) {\n        if (!methodVO.textureGL) {\n            this._color = methodVO.pass._surface.style.color;\n            this.updateColor();\n        }\n    };\n    Object.defineProperty(CurveBasicMethod.prototype, \"ambient\", {\n        /**\n         * The strength of the ambient reflection of the surface.\n         */\n        get: function () {\n            return this._ambient;\n        },\n        set: function (value) {\n            if (this._ambient == value)\n                return;\n            this._ambient = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CurveBasicMethod.prototype, \"alpha\", {\n        /**\n         * The alpha component of the surface.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            if (this._alpha == value)\n                return;\n            this._alpha = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CurveBasicMethod.prototype, \"texture\", {\n        /**\n         * The texture to use to define the diffuse reflection color per texel.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    CurveBasicMethod.prototype.copyFrom = function (method) {\n        var m = method;\n        var b = m;\n    };\n    /**\n     * @inheritDoc\n     */\n    /*\n    public iGeVertexCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string {\n        var code:string = \"\";\n        code = \"mov \" + sharedRegisters.uvVarying + \" \" + registerCache.uv +  \" \\n\";\n    }*/\n    CurveBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var ambientInputRegister;\n        if (methodVO.textureGL) {\n            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n            if (shader.alphaThreshold > 0) {\n                var cutOffReg = registerCache.getFreeFragmentConstant();\n                methodVO.fragmentConstantsIndex = cutOffReg.index * 4;\n                code += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n                    \"kil \" + targetReg + \".w\\n\" +\n                    \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n            }\n        }\n        else {\n            ambientInputRegister = registerCache.getFreeFragmentConstant();\n            methodVO.fragmentConstantsIndex = ambientInputRegister.index * 4;\n            code += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n        }\n        code = \"mov \" + targetReg + \", \" + sharedRegisters.uvVarying + \"\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    CurveBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (methodVO.textureGL) {\n            methodVO.textureGL.activate(methodVO.pass._render);\n            if (shader.alphaThreshold > 0)\n                shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n        }\n        else {\n            var index = methodVO.fragmentConstantsIndex;\n            var data = shader.fragmentConstantData;\n            data[index] = this._colorR;\n            data[index + 1] = this._colorG;\n            data[index + 2] = this._colorB;\n            data[index + 3] = this._alpha;\n        }\n    };\n    CurveBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (methodVO.textureGL)\n            methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Updates the ambient color data used by the render state.\n     */\n    CurveBasicMethod.prototype.updateColor = function () {\n        this._colorR = ((this._color >> 16) & 0xff) / 0xff * this._ambient;\n        this._colorG = ((this._color >> 8) & 0xff) / 0xff * this._ambient;\n        this._colorB = (this._color & 0xff) / 0xff * this._ambient;\n    };\n    return CurveBasicMethod;\n}(ShadingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = CurveBasicMethod;\n\n},{\"awayjs-core/lib/events/AssetEvent\":undefined,\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar LightingMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\n/**\n * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.\n */\nvar DiffuseBasicMethod = (function (_super) {\n    __extends(DiffuseBasicMethod, _super);\n    /**\n     * Creates a new DiffuseBasicMethod object.\n     */\n    function DiffuseBasicMethod() {\n        _super.call(this);\n        this._multiply = true;\n        this._ambientColorR = 1;\n        this._ambientColorG = 1;\n        this._ambientColorB = 1;\n        this._color = 0xffffff;\n        this._colorR = 1;\n        this._colorG = 1;\n        this._colorB = 1;\n    }\n    DiffuseBasicMethod.prototype.iIsUsed = function (shader) {\n        if (!shader.numLights)\n            return false;\n        return true;\n    };\n    Object.defineProperty(DiffuseBasicMethod.prototype, \"multiply\", {\n        /**\n         * Set internally if diffuse color component multiplies or replaces the ambient color\n         */\n        get: function () {\n            return this._multiply;\n        },\n        set: function (value) {\n            if (this._multiply == value)\n                return;\n            this._multiply = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DiffuseBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, null));\n            methodVO.textureGL = null;\n        }\n        if (shader.numLights > 0) {\n            shader.usesCommonData = true;\n            methodVO.needsNormals = true;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iInitConstants = function (shader, methodVO) {\n        if (shader.numLights > 0) {\n            this._ambientColor = methodVO.pass._surface.style.color;\n            this.updateAmbientColor();\n        }\n        else {\n            this._ambientColor = null;\n        }\n    };\n    Object.defineProperty(DiffuseBasicMethod.prototype, \"color\", {\n        /**\n         * The color of the diffuse reflection when not using a texture.\n         */\n        get: function () {\n            return this._color;\n        },\n        set: function (value) {\n            if (this._color == value)\n                return;\n            this._color = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseBasicMethod.prototype, \"texture\", {\n        /**\n         * The texture to use to define the diffuse reflection color per texel.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.dispose = function () {\n        this._texture = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.copyFrom = function (method) {\n        var diff = method;\n        this.texture = diff.texture;\n        this.multiply = diff.multiply;\n        this.color = diff.color;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._pTotalLightColorReg = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = \"\";\n        this._pIsFirstLight = true;\n        registerCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        code += \"dp3 \" + t + \".x, \" + lightDirReg + \", \" + sharedRegisters.normalFragment + \"\\n\" +\n            \"max \" + t + \".w, \" + t + \".x, \" + sharedRegisters.commons + \".y\\n\";\n        if (shader.usesLightFallOff)\n            code += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += \"mul \" + t + \", \" + t + \".w, \" + lightColReg + \"\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        code += \"tex \" + t + \", \" + sharedRegisters.normalFragment + \", \" + cubeMapReg + \" <cube,linear,miplinear>\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \".xyz, \" + weightRegister + \"\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var diffuseColor;\n        var cutOffReg;\n        // incorporate input from ambient\n        if (sharedRegisters.shadowTarget)\n            code += this.pApplyShadow(shader, methodVO, registerCache, sharedRegisters);\n        registerCache.addFragmentTempUsages(diffuseColor = registerCache.getFreeFragmentVectorTemp(), 1);\n        var ambientColorRegister = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = ambientColorRegister.index * 4;\n        if (this._texture) {\n            code += methodVO.textureGL._iGetFragmentCode(diffuseColor, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n        }\n        else {\n            var diffuseInputRegister = registerCache.getFreeFragmentConstant();\n            code += \"mov \" + diffuseColor + \", \" + diffuseInputRegister + \"\\n\";\n        }\n        code += \"sat \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n            \"mul \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\";\n        if (this._multiply) {\n            code += \"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + ambientColorRegister + \"\\n\" +\n                \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\";\n        }\n        else if (this._texture) {\n            code += \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + ambientColorRegister + \"\\n\" +\n                \"mul \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"sub \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"add \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; //add diffuse color and ambient color\n        }\n        else {\n            code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"sub \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; // multiply by target which could be texture or white\n        }\n        registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n        registerCache.removeFragmentTempUsage(diffuseColor);\n        return code;\n    };\n    /**\n     * Generate the code that applies the calculated shadow to the diffuse light\n     * @param methodVO The MethodVO object for which the compilation is currently happening.\n     * @param regCache The register cache the compiler is currently using for the register management.\n     */\n    DiffuseBasicMethod.prototype.pApplyShadow = function (shader, methodVO, regCache, sharedRegisters) {\n        return \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (this._texture) {\n            methodVO.textureGL.activate(methodVO.pass._render);\n        }\n        else {\n            var index = methodVO.fragmentConstantsIndex;\n            var data = shader.fragmentConstantData;\n            if (this._multiply) {\n                data[index + 4] = this._colorR * this._ambientColorR;\n                data[index + 5] = this._colorG * this._ambientColorG;\n                data[index + 6] = this._colorB * this._ambientColorB;\n            }\n            else {\n                data[index + 4] = this._colorR;\n                data[index + 5] = this._colorG;\n                data[index + 6] = this._colorB;\n            }\n            data[index + 7] = 1;\n        }\n    };\n    /**\n     * Updates the diffuse color data used by the render state.\n     */\n    DiffuseBasicMethod.prototype.updateColor = function () {\n        this._colorR = ((this._color >> 16) & 0xff) / 0xff;\n        this._colorG = ((this._color >> 8) & 0xff) / 0xff;\n        this._colorB = (this._color & 0xff) / 0xff;\n    };\n    /**\n     * Updates the ambient color data used by the render state.\n     */\n    DiffuseBasicMethod.prototype.updateAmbientColor = function () {\n        this._ambientColorR = ((this._ambientColor >> 16) & 0xff) / 0xff;\n        this._ambientColorG = ((this._ambientColor >> 8) & 0xff) / 0xff;\n        this._ambientColorB = (this._ambientColor & 0xff) / 0xff;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (this._texture)\n            methodVO.textureGL._setRenderState(renderable);\n        //TODO move this to Activate (ambientR/G/B currently calc'd in render state)\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = shader.ambientR * this._ambientColorR;\n        data[index + 1] = shader.ambientG * this._ambientColorG;\n        data[index + 2] = shader.ambientB * this._ambientColorB;\n        data[index + 3] = 1;\n    };\n    return DiffuseBasicMethod;\n}(LightingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseBasicMethod;\n\n},{\"awayjs-core/lib/events/AssetEvent\":undefined,\"awayjs-methodmaterials/lib/methods/LightingMethodBase\":\"awayjs-methodmaterials/lib/methods/LightingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/DiffuseCelMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseCompositeMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n/**\n * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.\n */\nvar DiffuseCelMethod = (function (_super) {\n    __extends(DiffuseCelMethod, _super);\n    /**\n     * Creates a new DiffuseCelMethod object.\n     * @param levels The amount of shadow gradations.\n     * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.\n     */\n    function DiffuseCelMethod(levels, baseMethod) {\n        var _this = this;\n        if (levels === void 0) { levels = 3; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this, null, baseMethod);\n        this._smoothness = .1;\n        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.clampDiffuse(shader, methodVO, targetReg, registerCache, sharedRegisters); };\n        this._levels = levels;\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseCelMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        data[index + 1] = 1;\n        data[index + 2] = 0;\n    };\n    Object.defineProperty(DiffuseCelMethod.prototype, \"levels\", {\n        /**\n         * The amount of shadow gradations.\n         */\n        get: function () {\n            return this._levels;\n        },\n        set: function (value /*uint*/) {\n            this._levels = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseCelMethod.prototype, \"smoothness\", {\n        /**\n         * The smoothness of the edge between 2 shading levels.\n         */\n        get: function () {\n            return this._smoothness;\n        },\n        set: function (value) {\n            this._smoothness = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseCelMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._dataReg = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        this._dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;\n        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCelMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var data = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        data[index] = this._levels;\n        data[index + 3] = this._smoothness;\n    };\n    /**\n     * Snaps the diffuse shading of the wrapped method to one of the levels.\n     * @param vo The MethodVO used to compile the current shader.\n     * @param t The register containing the diffuse strength in the \"w\" component.\n     * @param regCache The register cache used for the shader compilation.\n     * @param sharedRegisters The shared register data for this shader.\n     * @return The AGAL fragment code for the method.\n     */\n    DiffuseCelMethod.prototype.clampDiffuse = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".x\\n\" +\n            \"frc \" + targetReg + \".z, \" + targetReg + \".w\\n\" +\n            \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n            \"mov \" + targetReg + \".x, \" + this._dataReg + \".x\\n\" +\n            \"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + this._dataReg + \".y\\n\" +\n            \"rcp \" + targetReg + \".x,\" + targetReg + \".x\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n            // previous clamped strength\n            \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".x\\n\" +\n            // fract/epsilon (so 0 - epsilon will become 0 - 1)\n            \"div \" + targetReg + \".z, \" + targetReg + \".z, \" + this._dataReg + \".w\\n\" +\n            \"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n            // 1-z\n            \"sub \" + targetReg + \".z, \" + this._dataReg + \".y, \" + targetReg + \".z\\n\" +\n            \"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + targetReg + \".z\\n\" +\n            \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\" +\n            \"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n    };\n    return DiffuseCelMethod;\n}(DiffuseCompositeMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseCelMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar DiffuseBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n/**\n * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the\n * calculated diffuse reflection strength.\n */\nvar DiffuseCompositeMethod = (function (_super) {\n    __extends(DiffuseCompositeMethod, _super);\n    /**\n     * Creates a new <code>DiffuseCompositeMethod</code> object.\n     *\n     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.\n     * @param baseMethod The base diffuse method on which this method's shading is based.\n     */\n    function DiffuseCompositeMethod(modulateMethod, baseMethod) {\n        var _this = this;\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this);\n        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };\n        this.pBaseMethod = baseMethod || new DiffuseBasicMethod_1.default();\n        this.pBaseMethod._iModulateMethod = modulateMethod;\n        this.pBaseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n    }\n    Object.defineProperty(DiffuseCompositeMethod.prototype, \"baseMethod\", {\n        /**\n         * The base diffuse method on which this method's shading is based.\n         */\n        get: function () {\n            return this.pBaseMethod;\n        },\n        set: function (value) {\n            if (this.pBaseMethod == value)\n                return;\n            this.pBaseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this.pBaseMethod = value;\n            this.pBaseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iInitVO = function (shader, methodVO) {\n        this.pBaseMethod.iInitVO(shader, methodVO);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iInitConstants = function (shader, methodVO) {\n        this.pBaseMethod.iInitConstants(shader, methodVO);\n    };\n    DiffuseCompositeMethod.prototype.iAddOwner = function (owner) {\n        _super.prototype.iAddOwner.call(this, owner);\n        this.pBaseMethod.iAddOwner(owner);\n    };\n    DiffuseCompositeMethod.prototype.iRemoveOwner = function (owner) {\n        _super.prototype.iRemoveOwner.call(this, owner);\n        this.pBaseMethod.iRemoveOwner(owner);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.dispose = function () {\n        this.pBaseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n        this.pBaseMethod.dispose();\n    };\n    Object.defineProperty(DiffuseCompositeMethod.prototype, \"texture\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this.pBaseMethod.texture;\n        },\n        /**\n         * @inheritDoc\n         */\n        set: function (value) {\n            this.pBaseMethod.texture = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseCompositeMethod.prototype, \"color\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this.pBaseMethod.color;\n        },\n        /**\n         * @inheritDoc\n         */\n        set: function (value) {\n            this.pBaseMethod.color = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseCompositeMethod.prototype, \"multiply\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this.pBaseMethod.multiply;\n        },\n        /**\n         * @inheritDoc\n         */\n        set: function (value) {\n            this.pBaseMethod.multiply = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this.pBaseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = this.pBaseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n        this._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        var code = this.pBaseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n        this._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        this.pBaseMethod.iActivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        this.pBaseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iDeactivate = function (shader, methodVO, stage) {\n        this.pBaseMethod.iDeactivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this.pBaseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return this.pBaseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iReset = function () {\n        this.pBaseMethod.iReset();\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this.pBaseMethod.iCleanCompilationData();\n    };\n    /**\n     * Called when the base method's shader code is invalidated.\n     */\n    DiffuseCompositeMethod.prototype.onShaderInvalidated = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    return DiffuseCompositeMethod;\n}(DiffuseBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseCompositeMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\",\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/DiffuseDepthMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n/**\n * DiffuseDepthMethod provides a debug method to visualise depth maps\n */\nvar DiffuseDepthMethod = (function (_super) {\n    __extends(DiffuseDepthMethod, _super);\n    /**\n     * Creates a new DiffuseBasicMethod object.\n     */\n    function DiffuseDepthMethod() {\n        _super.call(this);\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseDepthMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index] = 1.0;\n        data[index + 1] = 1 / 255.0;\n        data[index + 2] = 1 / 65025.0;\n        data[index + 3] = 1 / 16581375.0;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseDepthMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var temp;\n        var decReg;\n        if (!this._texture)\n            throw new Error(\"DiffuseDepthMethod requires texture!\");\n        // incorporate input from ambient\n        if (shader.numLights > 0) {\n            if (sharedRegisters.shadowTarget)\n                code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + sharedRegisters.shadowTarget + \".w\\n\";\n            code += \"add \" + targetReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \".xyz\\n\" +\n                \"sat \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n            registerCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);\n        }\n        else {\n            temp = targetReg;\n        }\n        decReg = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        code += methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n            \"dp4 \" + temp + \".x, \" + temp + \", \" + decReg + \"\\n\" +\n            \"mov \" + temp + \".yz, \" + temp + \".xx\t\t\t\\n\" +\n            \"mov \" + temp + \".w, \" + decReg + \".x\\n\" +\n            \"sub \" + temp + \".xyz, \" + decReg + \".xxx, \" + temp + \".xyz\\n\";\n        if (shader.numLights == 0)\n            return code;\n        code += \"mul \" + targetReg + \".xyz, \" + temp + \".xyz, \" + targetReg + \".xyz\\n\" +\n            \"mov \" + targetReg + \".w, \" + temp + \".w\\n\";\n        if (shader.numLights > 0)\n            registerCache.removeFragmentTempUsage(temp);\n        return code;\n    };\n    return DiffuseDepthMethod;\n}(DiffuseBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseDepthMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseGradientMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n/**\n * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient\n * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude\n * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate\n * scattered light within the skin attributing to the final colour)\n */\nvar DiffuseGradientMethod = (function (_super) {\n    __extends(DiffuseGradientMethod, _super);\n    /**\n     * Creates a new DiffuseGradientMethod object.\n     * @param gradient A texture that contains the light colour based on the angle. This can be used to change\n     * the light colour due to subsurface scattering when the surface faces away from the light.\n     */\n    function DiffuseGradientMethod(gradient) {\n        _super.call(this);\n        this._gradient = gradient;\n        if (this._gradient)\n            this.iAddTexture(this._gradient);\n    }\n    DiffuseGradientMethod.prototype.iInitVO = function (shader, methodVO) {\n        _super.prototype.iInitVO.call(this, shader, methodVO);\n        methodVO.secondaryTextureGL = shader.getAbstraction(this._gradient);\n    };\n    Object.defineProperty(DiffuseGradientMethod.prototype, \"gradient\", {\n        /**\n         * A texture that contains the light colour based on the angle. This can be used to change the light colour\n         * due to subsurface scattering when the surface faces away from the light.\n         */\n        get: function () {\n            return this._gradient;\n        },\n        set: function (value) {\n            if (this._gradient == value)\n                return;\n            if (this._gradient)\n                this.iRemoveTexture(this._gradient);\n            this._gradient = value;\n            if (this._gradient)\n                this.iAddTexture(this._gradient);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n        this._pIsFirstLight = true;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight)\n            t = this._pTotalLightColorReg;\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        code += \"dp3 \" + t + \".w, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n            \"mul \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n            \"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += methodVO.secondaryTextureGL._iGetFragmentCode(t, registerCache, sharedRegisters, t) +\n            //\t\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + t + \".w\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \".xyz, \" + lightColReg + \".xyz\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.pApplyShadow = function (shader, methodVO, regCache, sharedRegisters) {\n        var t = regCache.getFreeFragmentVectorTemp();\n        return \"mov \" + t + \", \" + sharedRegisters.shadowTarget + \".wwww\\n\" +\n            methodVO.secondaryTextureGL._iGetFragmentCode(t, regCache, sharedRegisters, sharedRegisters.uvVarying) +\n            \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);\n        if (shader.numLights > 0)\n            methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    return DiffuseGradientMethod;\n}(DiffuseBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseGradientMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseCompositeMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n/**\n * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse\n * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather\n * than only the diffuse lighting value.\n */\nvar DiffuseLightMapMethod = (function (_super) {\n    __extends(DiffuseLightMapMethod, _super);\n    /**\n     * Creates a new DiffuseLightMapMethod method.\n     *\n     * @param lightMap The texture containing the light map.\n     * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n     * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n     * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n     */\n    function DiffuseLightMapMethod(lightMap, blendMode, useSecondaryUV, baseMethod) {\n        if (blendMode === void 0) { blendMode = \"multiply\"; }\n        if (useSecondaryUV === void 0) { useSecondaryUV = false; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this, null, baseMethod);\n        this._useSecondaryUV = useSecondaryUV;\n        this._lightMap = lightMap;\n        this.blendMode = blendMode;\n        if (this._lightMap)\n            this.iAddTexture(this._lightMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseLightMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.secondaryTextureGL = shader.getAbstraction(this._lightMap);\n        if (this._useSecondaryUV)\n            shader.secondaryUVDependencies++;\n        else\n            shader.uvDependencies++;\n    };\n    Object.defineProperty(DiffuseLightMapMethod.prototype, \"blendMode\", {\n        /**\n         * The blend mode with which the light map should be applied to the lighting result.\n         *\n         * @see DiffuseLightMapMethod.ADD\n         * @see DiffuseLightMapMethod.MULTIPLY\n         */\n        get: function () {\n            return this._blendMode;\n        },\n        set: function (value) {\n            if (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)\n                throw new Error(\"Unknown blendmode!\");\n            if (this._blendMode == value)\n                return;\n            this._blendMode = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseLightMapMethod.prototype, \"lightMap\", {\n        /**\n         * The texture containing the light map data.\n         */\n        get: function () {\n            return this._lightMap;\n        },\n        set: function (value) {\n            if (this._lightMap == value)\n                return;\n            if (this._lightMap)\n                this.iRemoveTexture(this._lightMap);\n            this._lightMap = value;\n            if (this._lightMap)\n                this.iAddTexture(this._lightMap);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseLightMapMethod.prototype, \"useSecondaryUV\", {\n        /**\n         * Indicates whether the secondary UV set should be used to map the light map.\n         */\n        get: function () {\n            return this._useSecondaryUV;\n        },\n        set: function (value) {\n            if (this._useSecondaryUV == value)\n                return;\n            this._useSecondaryUV = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseLightMapMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n        switch (this._blendMode) {\n            case DiffuseLightMapMethod.MULTIPLY:\n                code += \"mul \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n                break;\n            case DiffuseLightMapMethod.ADD:\n                code += \"add \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n                break;\n        }\n        code += _super.prototype.iGetFragmentPostLightingCode.call(this, shader, methodVO, targetReg, registerCache, sharedRegisters);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseLightMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseLightMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);\n        methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * Indicates the light map should be multiplied with the calculated shading result.\n     * This can be used to add pre-calculated shadows or occlusion.\n     */\n    DiffuseLightMapMethod.MULTIPLY = \"multiply\";\n    /**\n     * Indicates the light map should be added into the calculated shading result.\n     * This can be used to add pre-calculated lighting or global illumination.\n     */\n    DiffuseLightMapMethod.ADD = \"add\";\n    return DiffuseLightMapMethod;\n}(DiffuseCompositeMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseLightMapMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseCompositeMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n/**\n * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of\n * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.\n * It can be used for candle wax, ice, skin, ...\n */\nvar DiffuseSubSurfaceMethod = (function (_super) {\n    __extends(DiffuseSubSurfaceMethod, _super);\n    /**\n     * Creates a new <code>DiffuseSubSurfaceMethod</code> object.\n     *\n     * @param depthMapSize The size of the depth map used.\n     * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n     * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n     */\n    function DiffuseSubSurfaceMethod(depthMapSize, depthMapOffset, baseMethod) {\n        var _this = this;\n        if (depthMapSize === void 0) { depthMapSize = 512; }\n        if (depthMapOffset === void 0) { depthMapOffset = 15; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this, null, baseMethod);\n        this._translucency = 1;\n        this._scatterColor = 0xffffff;\n        this._scatterR = 1.0;\n        this._scatterG = 1.0;\n        this._scatterB = 1.0;\n        this.pBaseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.scatterLight(shader, methodVO, targetReg, registerCache, sharedRegisters); };\n        //this._passes = new Array<MaterialPassGLBase>();\n        //this._depthPass = new SingleObjectDepthPass();\n        //this._depthPass.textureSize = depthMapSize;\n        //this._depthPass.polyOffset = depthMapOffset;\n        //this._passes.push(this._depthPass);\n        this._scattering = 0.2;\n        this._translucency = 1;\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        var data = shader.vertexConstantData;\n        var index = methodVO.secondaryVertexConstantsIndex;\n        data[index] = .5;\n        data[index + 1] = -.5;\n        data[index + 2] = 0;\n        data[index + 3] = 1;\n        data = shader.fragmentConstantData;\n        index = methodVO.secondaryFragmentConstantsIndex;\n        data[index + 3] = 1.0;\n        data[index + 4] = 1.0;\n        data[index + 5] = 1 / 255;\n        data[index + 6] = 1 / 65025;\n        data[index + 7] = 1 / 16581375;\n        data[index + 10] = .5;\n        data[index + 11] = -.1;\n    };\n    DiffuseSubSurfaceMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._lightProjVarying = null;\n        this._propReg = null;\n        this._lightColorReg = null;\n        this._colorReg = null;\n        this._decReg = null;\n        this._targetReg = null;\n    };\n    Object.defineProperty(DiffuseSubSurfaceMethod.prototype, \"scattering\", {\n        /**\n         * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low\n         * values for skin.\n         */\n        get: function () {\n            return this._scattering;\n        },\n        set: function (value) {\n            this._scattering = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseSubSurfaceMethod.prototype, \"translucency\", {\n        /**\n         * The translucency of the object.\n         */\n        get: function () {\n            return this._translucency;\n        },\n        set: function (value) {\n            this._translucency = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseSubSurfaceMethod.prototype, \"scatterColor\", {\n        /**\n         * The colour of the \"insides\" of the object, ie: the colour the light becomes after leaving the object.\n         */\n        get: function () {\n            return this._scatterColor;\n        },\n        set: function (scatterColor /*uint*/) {\n            this._scatterColor = scatterColor;\n            this._scatterR = ((scatterColor >> 16) & 0xff) / 0xff;\n            this._scatterG = ((scatterColor >> 8) & 0xff) / 0xff;\n            this._scatterB = (scatterColor & 0xff) / 0xff;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = _super.prototype.iGetVertexCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n        var lightProjection;\n        var toTexRegister;\n        var temp = registerCache.getFreeVertexVectorTemp();\n        toTexRegister = registerCache.getFreeVertexConstant();\n        methodVO.secondaryVertexConstantsIndex = toTexRegister.index * 4;\n        this._lightProjVarying = registerCache.getFreeVarying();\n        lightProjection = registerCache.getFreeVertexConstant();\n        registerCache.getFreeVertexConstant();\n        registerCache.getFreeVertexConstant();\n        registerCache.getFreeVertexConstant();\n        code += \"m44 \" + temp + \", vt0, \" + lightProjection + \"\\n\" +\n            \"div \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xy\\n\" +\n            \"add \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xx\\n\" +\n            \"mov \" + this._lightProjVarying + \".xyz, \" + temp + \".xyz\\n\" +\n            \"mov \" + this._lightProjVarying + \".w, va0.w\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        this._colorReg = registerCache.getFreeFragmentConstant();\n        this._decReg = registerCache.getFreeFragmentConstant();\n        this._propReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._colorReg.index * 4;\n        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        this._pIsFirstLight = true;\n        this._lightColorReg = lightColReg;\n        return _super.prototype.iGetFragmentCodePerLight.call(this, shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = _super.prototype.iGetFragmentPostLightingCode.call(this, shader, methodVO, targetReg, registerCache, sharedRegisters);\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code += \"mul \" + temp + \".xyz, \" + this._lightColorReg + \".xyz, \" + this._targetReg + \".w\\n\" +\n            \"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + this._colorReg + \".xyz\\n\" +\n            \"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n        if (this._targetReg != sharedRegisters.viewDirFragment)\n            registerCache.removeFragmentTempUsage(targetReg);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._scatterR;\n        data[index + 1] = this._scatterG;\n        data[index + 2] = this._scatterB;\n        data[index + 8] = this._scattering;\n        data[index + 9] = this._translucency;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.secondaryTextureGL = shader.getAbstraction(this._depthPass._iGetDepthMap(renderable));\n        methodVO.secondaryTextureGL._setRenderState(renderable);\n        this._depthPass._iGetProjection(renderable).copyRawDataTo(shader.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);\n    };\n    /**\n     * Generates the code for this method\n     */\n    DiffuseSubSurfaceMethod.prototype.scatterLight = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        // only scatter first light\n        if (!this._pIsFirstLight)\n            return \"\";\n        this._pIsFirstLight = false;\n        var code = \"\";\n        if (sharedRegisters.viewDirFragment)\n            this._targetReg = sharedRegisters.viewDirFragment;\n        else\n            registerCache.addFragmentTempUsages(this._targetReg = registerCache.getFreeFragmentVectorTemp(), 1);\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._lightProjVarying) +\n            // reencode RGBA\n            \"dp4 \" + targetReg + \".z, \" + temp + \", \" + this._decReg + \"\\n\";\n        // currentDistanceToLight - closestDistanceToLight\n        code += \"sub \" + targetReg + \".z, \" + this._lightProjVarying + \".z, \" + targetReg + \".z\\n\" +\n            \"sub \" + targetReg + \".z, \" + this._propReg + \".x, \" + targetReg + \".z\\n\" +\n            \"mul \" + targetReg + \".z, \" + this._propReg + \".y, \" + targetReg + \".z\\n\" +\n            \"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n            // targetReg.x contains dot(lightDir, normal)\n            // modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)\n            \"neg \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n            \"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n            \"add \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n            \"mul \" + this._targetReg + \".w, \" + targetReg + \".z, \" + targetReg + \".y\\n\" +\n            // blend diffuse: d' = (1-s)*d + s*1\n            \"sub \" + targetReg + \".y, \" + this._colorReg + \".w, \" + this._targetReg + \".w\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n        return code;\n    };\n    return DiffuseSubSurfaceMethod;\n}(DiffuseCompositeMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseSubSurfaceMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseWrapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n/**\n * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be \"wrapped around\" the normally dark area, to some extent.\n * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.\n */\nvar DiffuseWrapMethod = (function (_super) {\n    __extends(DiffuseWrapMethod, _super);\n    /**\n     * Creates a new DiffuseWrapMethod object.\n     * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap\n     */\n    function DiffuseWrapMethod(wrapFactor) {\n        if (wrapFactor === void 0) { wrapFactor = .5; }\n        _super.call(this);\n        this.wrapFactor = wrapFactor;\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseWrapMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._wrapDataRegister = null;\n    };\n    Object.defineProperty(DiffuseWrapMethod.prototype, \"wrapFactor\", {\n        /**\n         * A factor to indicate the amount by which the light is allowed to wrap.\n         */\n        get: function () {\n            return this._wrapFactor;\n        },\n        set: function (value) {\n            this._wrapFactor = value;\n            this._wrapFactor = 1 / (value + 1);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseWrapMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n        this._pIsFirstLight = true;\n        this._wrapDataRegister = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index * 4;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseWrapMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        code += \"dp3 \" + t + \".x, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n            \"add \" + t + \".y, \" + t + \".x, \" + this._wrapDataRegister + \".x\\n\" +\n            \"mul \" + t + \".y, \" + t + \".y, \" + this._wrapDataRegister + \".y\\n\" +\n            \"sat \" + t + \".w, \" + t + \".y\\n\" +\n            \"mul \" + t + \".xz, \" + t + \".w, \" + lightDirReg + \".wz\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, lightDirReg, registerCache, sharedRegisters);\n        code += \"mul \" + t + \", \" + t + \".x, \" + lightColReg + \"\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseWrapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._wrapFactor;\n        data[index + 1] = 1 / (this._wrapFactor + 1);\n    };\n    return DiffuseWrapMethod;\n}(DiffuseBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DiffuseWrapMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n/**\n * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used\n * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water\n * etc).\n */\nvar EffectAlphaMaskMethod = (function (_super) {\n    __extends(EffectAlphaMaskMethod, _super);\n    /**\n     * Creates a new EffectAlphaMaskMethod object.\n     *\n     * @param texture The texture to use as the alpha mask.\n     * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.\n     */\n    function EffectAlphaMaskMethod(texture, useSecondaryUV) {\n        if (useSecondaryUV === void 0) { useSecondaryUV = false; }\n        _super.call(this);\n        this._texture = texture;\n        this._useSecondaryUV = useSecondaryUV;\n        if (this._texture)\n            this.iAddTexture(this._texture);\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectAlphaMaskMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.textureGL = shader.getAbstraction(this._texture);\n        if (this._useSecondaryUV)\n            shader.secondaryUVDependencies++;\n        else\n            shader.uvDependencies++;\n    };\n    Object.defineProperty(EffectAlphaMaskMethod.prototype, \"useSecondaryUV\", {\n        /**\n         * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for\n         * instance to tile the main texture and normal map while providing untiled alpha, for example to define the\n         * transparency over a tiled water surface.\n         */\n        get: function () {\n            return this._useSecondaryUV;\n        },\n        set: function (value) {\n            if (this._useSecondaryUV == value)\n                return;\n            this._useSecondaryUV = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectAlphaMaskMethod.prototype, \"texture\", {\n        /**\n         * The texture to use as the alpha mask.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectAlphaMaskMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +\n            \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \".x\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectAlphaMaskMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    EffectAlphaMaskMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n    };\n    return EffectAlphaMaskMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectAlphaMaskMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n/**\n * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.\n */\nvar EffectColorMatrixMethod = (function (_super) {\n    __extends(EffectColorMatrixMethod, _super);\n    /**\n     * Creates a new EffectColorTransformMethod.\n     *\n     * @param matrix An array of 20 items for 4 x 5 color transform.\n     */\n    function EffectColorMatrixMethod(matrix) {\n        _super.call(this);\n        if (matrix.length != 20)\n            throw new Error(\"Matrix length must be 20!\");\n        this._matrix = matrix;\n    }\n    Object.defineProperty(EffectColorMatrixMethod.prototype, \"colorMatrix\", {\n        /**\n         * The 4 x 5 matrix to transform the color of the material.\n         */\n        get: function () {\n            return this._matrix;\n        },\n        set: function (value) {\n            this._matrix = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectColorMatrixMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var colorMultReg = registerCache.getFreeFragmentConstant();\n        registerCache.getFreeFragmentConstant();\n        registerCache.getFreeFragmentConstant();\n        registerCache.getFreeFragmentConstant();\n        var colorOffsetReg = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = colorMultReg.index * 4;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code += \"m44 \" + temp + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" +\n            \"add \" + targetReg + \", \" + temp + \", \" + colorOffsetReg + \"\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectColorMatrixMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var matrix = this._matrix;\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        // r\n        data[index] = matrix[0];\n        data[index + 1] = matrix[1];\n        data[index + 2] = matrix[2];\n        data[index + 3] = matrix[3];\n        // g\n        data[index + 4] = matrix[5];\n        data[index + 5] = matrix[6];\n        data[index + 6] = matrix[7];\n        data[index + 7] = matrix[8];\n        // b\n        data[index + 8] = matrix[10];\n        data[index + 9] = matrix[11];\n        data[index + 10] = matrix[12];\n        data[index + 11] = matrix[13];\n        // a\n        data[index + 12] = matrix[15];\n        data[index + 13] = matrix[16];\n        data[index + 14] = matrix[17];\n        data[index + 15] = matrix[18];\n        // rgba offset\n        data[index + 16] = matrix[4];\n        data[index + 17] = matrix[9];\n        data[index + 18] = matrix[14];\n        data[index + 19] = matrix[19];\n    };\n    return EffectColorMatrixMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectColorMatrixMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n/**\n * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a\n * ColorTransform object.\n */\nvar EffectColorTransformMethod = (function (_super) {\n    __extends(EffectColorTransformMethod, _super);\n    /**\n     * Creates a new EffectColorTransformMethod.\n     */\n    function EffectColorTransformMethod() {\n        _super.call(this);\n    }\n    Object.defineProperty(EffectColorTransformMethod.prototype, \"colorTransform\", {\n        /**\n         * The ColorTransform object to transform the colour of the material with.\n         */\n        get: function () {\n            return this._colorTransform;\n        },\n        set: function (value) {\n            this._colorTransform = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectColorTransformMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var colorMultReg = registerCache.getFreeFragmentConstant();\n        var colorOffsReg = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = colorMultReg.index * 4;\n        //TODO: AGAL <> GLSL\n        code += \"mul \" + targetReg + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" + \"add \" + targetReg + \", \" + targetReg + \", \" + colorOffsReg + \"\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectColorTransformMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var inv = 1 / 0xff;\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._colorTransform.redMultiplier;\n        data[index + 1] = this._colorTransform.greenMultiplier;\n        data[index + 2] = this._colorTransform.blueMultiplier;\n        data[index + 3] = this._colorTransform.alphaMultiplier;\n        data[index + 4] = this._colorTransform.redOffset * inv;\n        data[index + 5] = this._colorTransform.greenOffset * inv;\n        data[index + 6] = this._colorTransform.blueOffset * inv;\n        data[index + 7] = this._colorTransform.alphaOffset * inv;\n    };\n    return EffectColorTransformMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectColorTransformMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectEnvMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n/**\n * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.\n */\nvar EffectEnvMapMethod = (function (_super) {\n    __extends(EffectEnvMapMethod, _super);\n    /**\n     * Creates an EffectEnvMapMethod object.\n     * @param envMap The environment map containing the reflected scene.\n     * @param alpha The reflectivity of the surface.\n     */\n    function EffectEnvMapMethod(envMap, alpha) {\n        if (alpha === void 0) { alpha = 1; }\n        _super.call(this);\n        this._envMap = envMap;\n        this._alpha = alpha;\n        if (this._envMap)\n            this.iAddTexture(this._envMap);\n    }\n    Object.defineProperty(EffectEnvMapMethod.prototype, \"mask\", {\n        /**\n         * An optional texture to modulate the reflectivity of the surface.\n         */\n        get: function () {\n            return this._mask;\n        },\n        set: function (value) {\n            if (value == this._mask)\n                return;\n            if (this._mask)\n                this.iRemoveTexture(this._mask);\n            this._mask = value;\n            if (this._mask)\n                this.iAddTexture(this._mask);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        methodVO.needsView = true;\n        if (this._envMap)\n            methodVO.textureGL = shader.getAbstraction(this._envMap);\n        if (this._mask) {\n            methodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n            shader.uvDependencies++;\n        }\n    };\n    Object.defineProperty(EffectEnvMapMethod.prototype, \"envMap\", {\n        /**\n         * The cubic environment map containing the reflected scene.\n         */\n        get: function () {\n            return this._envMap;\n        },\n        set: function (value) {\n            if (this._envMap == value)\n                return;\n            if (this._envMap)\n                this.iRemoveTexture(this._envMap);\n            this._envMap = value;\n            if (this._envMap)\n                this.iAddTexture(this._envMap);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectEnvMapMethod.prototype.dispose = function () {\n    };\n    Object.defineProperty(EffectEnvMapMethod.prototype, \"alpha\", {\n        /**\n         * The reflectivity of the surface.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            this._alpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;\n        methodVO.textureGL.activate(methodVO.pass._render);\n        if (this._mask)\n            methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    EffectEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n        if (this._mask)\n            methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var dataRegister = registerCache.getFreeFragmentConstant();\n        var code = \"\";\n        methodVO.fragmentConstantsIndex = dataRegister.index * 4;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var temp2 = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp2, 1);\n        // r = I - 2(I.N)*N\n        code += \"dp3 \" + temp + \".w, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n            \"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".xyz, \" + sharedRegisters.normalFragment + \".xyz, \" + temp + \".w\\n\" +\n            \"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n            \"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +\n            \"kil \" + temp2 + \".w\\n\" +\n            \"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n        if (this._mask) {\n            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n                \"mul \" + temp + \", \" + temp2 + \", \" + temp + \"\\n\";\n        }\n        code += \"mul \" + temp + \", \" + temp + \", \" + dataRegister + \".x\\n\" +\n            \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        registerCache.removeFragmentTempUsage(temp2);\n        return code;\n    };\n    return EffectEnvMapMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectEnvMapMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectFogMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n/**\n * EffectFogMethod provides a method to add distance-based fog to a material.\n */\nvar EffectFogMethod = (function (_super) {\n    __extends(EffectFogMethod, _super);\n    /**\n     * Creates a new EffectFogMethod object.\n     * @param minDistance The distance from which the fog starts appearing.\n     * @param maxDistance The distance at which the fog is densest.\n     * @param fogColor The colour of the fog.\n     */\n    function EffectFogMethod(minDistance, maxDistance, fogColor) {\n        if (fogColor === void 0) { fogColor = 0x808080; }\n        _super.call(this);\n        this._minDistance = 0;\n        this._maxDistance = 1000;\n        this.minDistance = minDistance;\n        this.maxDistance = maxDistance;\n        this.fogColor = fogColor;\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectFogMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsProjection = true;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectFogMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index + 3] = 1;\n        data[index + 6] = 0;\n        data[index + 7] = 0;\n    };\n    Object.defineProperty(EffectFogMethod.prototype, \"minDistance\", {\n        /**\n         * The distance from which the fog starts appearing.\n         */\n        get: function () {\n            return this._minDistance;\n        },\n        set: function (value) {\n            this._minDistance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFogMethod.prototype, \"maxDistance\", {\n        /**\n         * The distance at which the fog is densest.\n         */\n        get: function () {\n            return this._maxDistance;\n        },\n        set: function (value) {\n            this._maxDistance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFogMethod.prototype, \"fogColor\", {\n        /**\n         * The colour of the fog.\n         */\n        get: function () {\n            return this._fogColor;\n        },\n        set: function (value /*uint*/) {\n            this._fogColor = value;\n            this._fogR = ((value >> 16) & 0xff) / 0xff;\n            this._fogG = ((value >> 8) & 0xff) / 0xff;\n            this._fogB = (value & 0xff) / 0xff;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectFogMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index] = this._fogR;\n        data[index + 1] = this._fogG;\n        data[index + 2] = this._fogB;\n        data[index + 4] = this._minDistance;\n        data[index + 5] = 1 / (this._maxDistance - this._minDistance);\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectFogMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var fogColor = registerCache.getFreeFragmentConstant();\n        var fogData = registerCache.getFreeFragmentConstant();\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var temp2 = registerCache.getFreeFragmentVectorTemp();\n        var code = \"\";\n        methodVO.fragmentConstantsIndex = fogColor.index * 4;\n        code += \"sub \" + temp2 + \".w, \" + sharedRegisters.projectionFragment + \".z, \" + fogData + \".x\\n\" +\n            \"mul \" + temp2 + \".w, \" + temp2 + \".w, \" + fogData + \".y\\n\" +\n            \"sat \" + temp2 + \".w, \" + temp2 + \".w\\n\" +\n            \"sub \" + temp + \", \" + fogColor + \", \" + targetReg + \"\\n\" +\n            \"mul \" + temp + \", \" + temp + \", \" + temp2 + \".w\\n\" +\n            \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\"; // fogRatio*(fogColor- col) + col\n        registerCache.removeFragmentTempUsage(temp);\n        return code;\n    };\n    return EffectFogMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectFogMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n/**\n * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets\n * stronger as the viewing angle becomes more grazing.\n */\nvar EffectFresnelEnvMapMethod = (function (_super) {\n    __extends(EffectFresnelEnvMapMethod, _super);\n    /**\n     * Creates a new <code>EffectFresnelEnvMapMethod</code> object.\n     *\n     * @param envMap The environment map containing the reflected scene.\n     * @param alpha The reflectivity of the material.\n     */\n    function EffectFresnelEnvMapMethod(envMap, alpha) {\n        if (alpha === void 0) { alpha = 1; }\n        _super.call(this);\n        this._fresnelPower = 5;\n        this._normalReflectance = 0;\n        this._envMap = envMap;\n        this._alpha = alpha;\n        if (this._envMap)\n            this.iAddTexture(this._envMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectFresnelEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        methodVO.needsView = true;\n        methodVO.textureGL = shader.getAbstraction(this._envMap);\n        if (this._mask != null) {\n            methodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n            shader.uvDependencies++;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectFresnelEnvMapMethod.prototype.iInitConstants = function (shader, methodVO) {\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n    };\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"mask\", {\n        /**\n         * An optional texture to modulate the reflectivity of the surface.\n         */\n        get: function () {\n            return this._mask;\n        },\n        set: function (value) {\n            if (this._mask == value)\n                return;\n            if (this._mask)\n                this.iRemoveTexture(this._mask);\n            this._mask = value;\n            if (this._mask)\n                this.iAddTexture(this._mask);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"fresnelPower\", {\n        /**\n         * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n         */\n        get: function () {\n            return this._fresnelPower;\n        },\n        set: function (value) {\n            this._fresnelPower = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"envMap\", {\n        /**\n         * The cubic environment map containing the reflected scene.\n         */\n        get: function () {\n            return this._envMap;\n        },\n        set: function (value) {\n            if (this._envMap == value)\n                return;\n            if (this._envMap)\n                this.iRemoveTexture(this._envMap);\n            this._envMap = value;\n            if (this._envMap)\n                this.iAddTexture(this._envMap);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"alpha\", {\n        /**\n         * The reflectivity of the surface.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            this._alpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"normalReflectance\", {\n        /**\n         * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n         */\n        get: function () {\n            return this._normalReflectance;\n        },\n        set: function (value) {\n            this._normalReflectance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectFresnelEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index] = this._alpha;\n        data[index + 1] = this._normalReflectance;\n        data[index + 2] = this._fresnelPower;\n        methodVO.textureGL.activate(methodVO.pass._render);\n        if (this._mask)\n            methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    EffectFresnelEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n        if (this._mask)\n            methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectFresnelEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var dataRegister = registerCache.getFreeFragmentConstant();\n        var code = \"\";\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        var normalReg = sharedRegisters.normalFragment;\n        methodVO.fragmentConstantsIndex = dataRegister.index * 4;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var temp2 = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp2, 1);\n        // r = V - 2(V.N)*N\n        code += \"dp3 \" + temp + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n            \"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".xyz, \" + normalReg + \".xyz, \" + temp + \".w\\n\" +\n            \"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + viewDirReg + \".xyz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n            \"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +\n            \"kil \" + temp2 + \".w\\n\" +\n            \"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n        // calculate fresnel term\n        code += \"dp3 \" + viewDirReg + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n            \"sub \" + viewDirReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +\n            \"pow \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + dataRegister + \".z\\n\" +\n            \"sub \" + normalReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +\n            \"mul \" + normalReg + \".w, \" + dataRegister + \".y, \" + normalReg + \".w\\n\" +\n            \"add \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + normalReg + \".w\\n\" +\n            // total alpha\n            \"mul \" + viewDirReg + \".w, \" + dataRegister + \".x, \" + viewDirReg + \".w\\n\";\n        if (this._mask) {\n            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n                \"mul \" + viewDirReg + \".w, \" + temp2 + \".x, \" + viewDirReg + \".w\\n\";\n        }\n        // blend\n        code += \"mul \" + temp + \", \" + temp + \", \" + viewDirReg + \".w\\n\" +\n            \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        registerCache.removeFragmentTempUsage(temp2);\n        return code;\n    };\n    return EffectFresnelEnvMapMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectFresnelEnvMapMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectLightMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n/**\n * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.\n * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather\n * than the whole pixel colour.\n */\nvar EffectLightMapMethod = (function (_super) {\n    __extends(EffectLightMapMethod, _super);\n    /**\n     * Creates a new EffectLightMapMethod object.\n     *\n     * @param lightMap The texture containing the light map.\n     * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n     * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n     */\n    function EffectLightMapMethod(lightMap, blendMode, useSecondaryUV) {\n        if (blendMode === void 0) { blendMode = \"multiply\"; }\n        if (useSecondaryUV === void 0) { useSecondaryUV = false; }\n        _super.call(this);\n        if (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)\n            throw new Error(\"Unknown blendmode!\");\n        this._lightMap = lightMap;\n        this._blendMode = blendMode;\n        this._useSecondaryUV = useSecondaryUV;\n        if (this._lightMap)\n            this.iAddTexture(this._lightMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectLightMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.textureGL = shader.getAbstraction(this._lightMap);\n        if (this._useSecondaryUV)\n            shader.secondaryUVDependencies++;\n        else\n            shader.uvDependencies++;\n    };\n    Object.defineProperty(EffectLightMapMethod.prototype, \"blendMode\", {\n        /**\n         * The blend mode with which the light map should be applied to the lighting result.\n         *\n         * @see EffectLightMapMethod.ADD\n         * @see EffectLightMapMethod.MULTIPLY\n         */\n        get: function () {\n            return this._blendMode;\n        },\n        set: function (value) {\n            if (this._blendMode == value)\n                return;\n            if (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)\n                throw new Error(\"Unknown blendmode!\");\n            this._blendMode = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectLightMapMethod.prototype, \"lightMap\", {\n        /**\n         * The lightMap containing the light map.\n         */\n        get: function () {\n            return this._lightMap;\n        },\n        set: function (value) {\n            if (this._lightMap == value)\n                return;\n            if (this._lightMap)\n                this.iRemoveTexture(this._lightMap);\n            this._lightMap = value;\n            if (this._lightMap)\n                this.iAddTexture(this._lightMap);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectLightMapMethod.prototype, \"useSecondaryUV\", {\n        /**\n         * Indicates whether the secondary UV set should be used to map the light map.\n         */\n        get: function () {\n            return this._useSecondaryUV;\n        },\n        set: function (value) {\n            if (this._useSecondaryUV == value)\n                return;\n            this._useSecondaryUV = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectLightMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n        switch (this._blendMode) {\n            case EffectLightMapMethod.MULTIPLY:\n                code += \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n                break;\n            case EffectLightMapMethod.ADD:\n                code += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n                break;\n        }\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectLightMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    EffectLightMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Indicates the light map should be multiplied with the calculated shading result.\n     */\n    EffectLightMapMethod.MULTIPLY = \"multiply\";\n    /**\n     * Indicates the light map should be added into the calculated shading result.\n     */\n    EffectLightMapMethod.ADD = \"add\";\n    return EffectLightMapMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectLightMapMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AbstractMethodError_1 = require(\"awayjs-core/lib/errors/AbstractMethodError\");\nvar ShadingMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n/**\n * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,\n * and are in essence post-process effects on the materials.\n */\nvar EffectMethodBase = (function (_super) {\n    __extends(EffectMethodBase, _super);\n    function EffectMethodBase() {\n        _super.call(this);\n    }\n    Object.defineProperty(EffectMethodBase.prototype, \"assetType\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return EffectMethodBase.assetType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param regCache The register cache used during the compilation.\n     * @param targetReg The register that will be containing the method's output.\n     * @private\n     */\n    EffectMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        throw new AbstractMethodError_1.default();\n    };\n    EffectMethodBase.assetType = \"[asset EffectMethod]\";\n    return EffectMethodBase;\n}(ShadingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectMethodBase;\n\n},{\"awayjs-core/lib/errors/AbstractMethodError\":undefined,\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n/**\n * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.\n */\nvar EffectRefractionEnvMapMethod = (function (_super) {\n    __extends(EffectRefractionEnvMapMethod, _super);\n    /**\n     * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015\n     *\n     * @param envMap The environment map containing the refracted scene.\n     * @param refractionIndex The refractive index of the material.\n     * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n     * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n     * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n     */\n    function EffectRefractionEnvMapMethod(envMap, refractionIndex, dispersionR, dispersionG, dispersionB) {\n        if (refractionIndex === void 0) { refractionIndex = .1; }\n        if (dispersionR === void 0) { dispersionR = 0; }\n        if (dispersionG === void 0) { dispersionG = 0; }\n        if (dispersionB === void 0) { dispersionB = 0; }\n        _super.call(this);\n        this._dispersionR = 0;\n        this._dispersionG = 0;\n        this._dispersionB = 0;\n        this._alpha = 1;\n        this._envMap = envMap;\n        this._dispersionR = dispersionR;\n        this._dispersionG = dispersionG;\n        this._dispersionB = dispersionB;\n        this._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n        this._refractionIndex = refractionIndex;\n        if (this._envMap)\n            this.iAddTexture(this._envMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectRefractionEnvMapMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index + 4] = 1;\n        data[index + 5] = 0;\n        data[index + 7] = 1;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectRefractionEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        methodVO.needsView = true;\n        methodVO.textureGL = shader.getAbstraction(this._envMap);\n    };\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"envMap\", {\n        /**\n         * The cube environment map to use for the refraction.\n         */\n        get: function () {\n            return this._envMap;\n        },\n        set: function (value) {\n            if (this._envMap == value)\n                return;\n            if (this._envMap)\n                this.iRemoveTexture(this._envMap);\n            this._envMap = value;\n            if (this._envMap)\n                this.iAddTexture(this._envMap);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"refractionIndex\", {\n        /**\n         * The refractive index of the material.\n         */\n        get: function () {\n            return this._refractionIndex;\n        },\n        set: function (value) {\n            this._refractionIndex = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"dispersionR\", {\n        /**\n         * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n         */\n        get: function () {\n            return this._dispersionR;\n        },\n        set: function (value) {\n            this._dispersionR = value;\n            var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n            if (this._useDispersion != useDispersion) {\n                this.iInvalidateShaderProgram();\n                this._useDispersion = useDispersion;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"dispersionG\", {\n        /**\n         * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n         */\n        get: function () {\n            return this._dispersionG;\n        },\n        set: function (value) {\n            this._dispersionG = value;\n            var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n            if (this._useDispersion != useDispersion) {\n                this.iInvalidateShaderProgram();\n                this._useDispersion = useDispersion;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"dispersionB\", {\n        /**\n         * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n         */\n        get: function () {\n            return this._dispersionB;\n        },\n        set: function (value) {\n            this._dispersionB = value;\n            var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n            if (this._useDispersion != useDispersion) {\n                this.iInvalidateShaderProgram();\n                this._useDispersion = useDispersion;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"alpha\", {\n        /**\n         * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual\n         * material. A value of 1 will make it appear fully transparent.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            this._alpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectRefractionEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._dispersionR + this._refractionIndex;\n        if (this._useDispersion) {\n            data[index + 1] = this._dispersionG + this._refractionIndex;\n            data[index + 2] = this._dispersionB + this._refractionIndex;\n        }\n        data[index + 3] = this._alpha;\n        methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    EffectRefractionEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectRefractionEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        // todo: data2.x could use common reg, so only 1 reg is used\n        var data = registerCache.getFreeFragmentConstant();\n        var data2 = registerCache.getFreeFragmentConstant();\n        var code = \"\";\n        var refractionDir;\n        var refractionColor;\n        var temp;\n        methodVO.fragmentConstantsIndex = data.index * 4;\n        refractionDir = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(refractionDir, 1);\n        refractionColor = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(refractionColor, 1);\n        temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        var normalReg = sharedRegisters.normalFragment;\n        code += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n        code += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n            \"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n            \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n            \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n            \"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".x, \" + data + \".x, \" + temp + \".x\\n\" +\n            \"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n            \"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n            \"mul \" + refractionDir + \", \" + data + \".x, \" + viewDirReg + \"\\n\" +\n            \"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n            \"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(refractionColor, registerCache, sharedRegisters, refractionDir) +\n            \"sub \" + refractionColor + \".w, \" + refractionColor + \".w, fc0.x\t\\n\" +\n            \"kil \" + refractionColor + \".w\\n\";\n        if (this._useDispersion) {\n            // GREEN\n            code += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n                \"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n                \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n                \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n                \"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".x, \" + data + \".y, \" + temp + \".x\\n\" +\n                \"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n                \"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n                \"mul \" + refractionDir + \", \" + data + \".y, \" + viewDirReg + \"\\n\" +\n                \"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n                \"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n                methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n                \"mov \" + refractionColor + \".y, \" + temp + \".y\\n\";\n            // BLUE\n            code += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n                \"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n                \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n                \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n                \"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".x, \" + data + \".z, \" + temp + \".x\\n\" +\n                \"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n                \"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n                \"mul \" + refractionDir + \", \" + data + \".z, \" + viewDirReg + \"\\n\" +\n                \"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n                \"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n                methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n                \"mov \" + refractionColor + \".z, \" + temp + \".z\\n\";\n        }\n        code += \"sub \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + targetReg + \".xyz\\n\" +\n            \"mul \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + data + \".w\\n\" +\n            \"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + refractionColor + \".xyz\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        registerCache.removeFragmentTempUsage(refractionDir);\n        registerCache.removeFragmentTempUsage(refractionColor);\n        // restore\n        code += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n        return code;\n    };\n    return EffectRefractionEnvMapMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectRefractionEnvMapMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectRimLightMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n/**\n * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.\n */\nvar EffectRimLightMethod = (function (_super) {\n    __extends(EffectRimLightMethod, _super);\n    /**\n     * Creates a new <code>EffectRimLightMethod</code> object.\n     *\n     * @param color The colour of the rim light.\n     * @param strength The strength of the rim light.\n     * @param power The power of the rim light. Higher values will result in a higher edge fall-off.\n     * @param blend The blend mode with which to add the light to the object.\n     */\n    function EffectRimLightMethod(color, strength, power, blend) {\n        if (color === void 0) { color = 0xffffff; }\n        if (strength === void 0) { strength = .4; }\n        if (power === void 0) { power = 2; }\n        if (blend === void 0) { blend = \"mix\"; }\n        _super.call(this);\n        this._blendMode = blend;\n        this._strength = strength;\n        this._power = power;\n        this.color = color;\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectRimLightMethod.prototype.iInitConstants = function (shader, methodVO) {\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectRimLightMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        methodVO.needsView = true;\n    };\n    Object.defineProperty(EffectRimLightMethod.prototype, \"blendMode\", {\n        /**\n         * The blend mode with which to add the light to the object.\n         *\n         * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.\n         * EffectRimLightMethod.ADD adds the rim light with the material's colour.\n         * EffectRimLightMethod.MIX provides normal alpha blending.\n         */\n        get: function () {\n            return this._blendMode;\n        },\n        set: function (value) {\n            if (this._blendMode == value)\n                return;\n            this._blendMode = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRimLightMethod.prototype, \"color\", {\n        /**\n         * The color of the rim light.\n         */\n        get: function () {\n            return this._color;\n        },\n        set: function (value /*uint*/) {\n            this._color = value;\n            this._colorR = ((value >> 16) & 0xff) / 0xff;\n            this._colorG = ((value >> 8) & 0xff) / 0xff;\n            this._colorB = (value & 0xff) / 0xff;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRimLightMethod.prototype, \"strength\", {\n        /**\n         * The strength of the rim light.\n         */\n        get: function () {\n            return this._strength;\n        },\n        set: function (value) {\n            this._strength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRimLightMethod.prototype, \"power\", {\n        /**\n         * The power of the rim light. Higher values will result in a higher edge fall-off.\n         */\n        get: function () {\n            return this._power;\n        },\n        set: function (value) {\n            this._power = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectRimLightMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._colorR;\n        data[index + 1] = this._colorG;\n        data[index + 2] = this._colorB;\n        data[index + 4] = this._strength;\n        data[index + 5] = this._power;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectRimLightMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var dataRegister = registerCache.getFreeFragmentConstant();\n        var dataRegister2 = registerCache.getFreeFragmentConstant();\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        var code = \"\";\n        methodVO.fragmentConstantsIndex = dataRegister.index * 4;\n        code += \"dp3 \" + temp + \".x, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n            \"sat \" + temp + \".x, \" + temp + \".x\\n\" +\n            \"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n            \"pow \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".y\\n\" +\n            \"mul \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".x\\n\" +\n            \"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n            \"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".x\\n\" +\n            \"sub \" + temp + \".w, \" + dataRegister + \".w, \" + temp + \".x\\n\";\n        if (this._blendMode == EffectRimLightMethod.ADD) {\n            code += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n                \"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n        }\n        else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {\n            code += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n                \"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n        }\n        else {\n            code += \"sub \" + temp + \".xyz, \" + dataRegister + \".xyz, \" + targetReg + \".xyz\\n\" +\n                \"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n                \"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n        }\n        return code;\n    };\n    EffectRimLightMethod.ADD = \"add\";\n    EffectRimLightMethod.MULTIPLY = \"multiply\";\n    EffectRimLightMethod.MIX = \"mix\";\n    return EffectRimLightMethod;\n}(EffectMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EffectRimLightMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/LightingMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n/**\n * LightingMethodBase provides an abstract base method for shading methods that uses lights.\n * Used for diffuse and specular shaders only.\n */\nvar LightingMethodBase = (function (_super) {\n    __extends(LightingMethodBase, _super);\n    /**\n     * Creates a new LightingMethodBase.\n     */\n    function LightingMethodBase() {\n        _super.call(this);\n    }\n    /**\n     * Get the fragment shader code that will be needed before any per-light code is added.\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param regCache The register cache used during the compilation.\n     * @private\n     */\n    LightingMethodBase.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    /**\n     * Get the fragment shader code that will generate the code relevant to a single light.\n     *\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param lightDirReg The register containing the light direction vector.\n     * @param lightColReg The register containing the light colour.\n     * @param regCache The register cache used during the compilation.\n     */\n    LightingMethodBase.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    /**\n     * Get the fragment shader code that will generate the code relevant to a single light probe object.\n     *\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param cubeMapReg The register containing the cube map for the current probe\n     * @param weightRegister A string representation of the register + component containing the current weight\n     * @param regCache The register cache providing any necessary registers to the shader\n     */\n    LightingMethodBase.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    /**\n     * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n     *\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param regCache The register cache used during the compilation.\n     * @param targetReg The register containing the final shading output.\n     * @private\n     */\n    LightingMethodBase.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    return LightingMethodBase;\n}(ShadingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = LightingMethodBase;\n\n},{\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n/**\n * NormalBasicMethod is the default method for standard tangent-space normal mapping.\n */\nvar NormalBasicMethod = (function (_super) {\n    __extends(NormalBasicMethod, _super);\n    /**\n     * Creates a new NormalBasicMethod object.\n     */\n    function NormalBasicMethod(texture) {\n        if (texture === void 0) { texture = null; }\n        _super.call(this);\n        this._texture = texture;\n        if (this._texture)\n            this.iAddTexture(this._texture);\n    }\n    NormalBasicMethod.prototype.iIsUsed = function (shader) {\n        if (this._texture && shader.normalDependencies)\n            return true;\n        return false;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n    };\n    /**\n     * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.\n     */\n    NormalBasicMethod.prototype.iOutputsTangentNormals = function () {\n        return true;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.copyFrom = function (method) {\n        var s = method;\n        var bnm = method;\n        if (bnm.texture != null)\n            this.texture = bnm.texture;\n    };\n    Object.defineProperty(NormalBasicMethod.prototype, \"texture\", {\n        /**\n         * A texture to modulate the direction of the surface for each texel (normal map). The default normal method expects\n         * tangent-space normal maps, but others could expect object-space maps.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.dispose = function () {\n        if (this._texture)\n            this._texture = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (this._texture)\n            methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    NormalBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (this._texture)\n            methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (this._texture)\n            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n        code += \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\\n\" +\n            \"nrm \" + targetReg + \".xyz, \" + targetReg + \"\\n\";\n        return code;\n    };\n    return NormalBasicMethod;\n}(ShadingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = NormalBasicMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/NormalHeightMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar NormalBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\n/**\n * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.\n */\nvar NormalHeightMapMethod = (function (_super) {\n    __extends(NormalHeightMapMethod, _super);\n    /**\n     * Creates a new NormalHeightMapMethod method.\n     *\n     * @param heightMap The texture containing the height data. 0 means low, 1 means high.\n     * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.\n     * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.\n     * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.\n     */\n    function NormalHeightMapMethod(heightMap, worldWidth, worldHeight, worldDepth) {\n        _super.call(this);\n        this.texture = heightMap;\n        this._worldXYRatio = worldWidth / worldHeight;\n        this._worldXZRatio = worldDepth / worldHeight;\n    }\n    /**\n     * @inheritDoc\n     */\n    NormalHeightMapMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = 1 / this.texture.image2D.width;\n        data[index + 1] = 1 / this.texture.image2D.height;\n        data[index + 2] = 0;\n        data[index + 3] = 1;\n        data[index + 4] = this._worldXYRatio;\n        data[index + 5] = this._worldXZRatio;\n    };\n    Object.defineProperty(NormalHeightMapMethod.prototype, \"tangentSpace\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    NormalHeightMapMethod.prototype.copyFrom = function (method) {\n        _super.prototype.copyFrom.call(this, method);\n        this._worldXYRatio = method._worldXYRatio;\n        this._worldXZRatio = method._worldXZRatio;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalHeightMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var dataReg = registerCache.getFreeFragmentConstant();\n        var dataReg2 = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = dataReg.index * 4;\n        code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n            \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".xzzz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n            \"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + temp + \".x\\n\" +\n            \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".zyzz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n            \"sub \" + targetReg + \".z, \" + targetReg + \".z, \" + temp + \".x\\n\" +\n            \"mov \" + targetReg + \".y, \" + dataReg + \".w\\n\" +\n            \"mul \" + targetReg + \".xz, \" + targetReg + \".xz, \" + dataReg2 + \".xy\\n\" +\n            \"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        return code;\n    };\n    return NormalHeightMapMethod;\n}(NormalBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = NormalHeightMapMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\":\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar NormalBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\n/**\n * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.\n */\nvar NormalSimpleWaterMethod = (function (_super) {\n    __extends(NormalSimpleWaterMethod, _super);\n    /**\n     * Creates a new NormalSimpleWaterMethod object.\n     * @param waveMap1 A normal map containing one layer of a wave structure.\n     * @param waveMap2 A normal map containing a second layer of a wave structure.\n     */\n    function NormalSimpleWaterMethod(normalMap, secondaryNormalMap) {\n        if (normalMap === void 0) { normalMap = null; }\n        if (secondaryNormalMap === void 0) { secondaryNormalMap = null; }\n        _super.call(this, normalMap);\n        this._water1OffsetX = 0;\n        this._water1OffsetY = 0;\n        this._water2OffsetX = 0;\n        this._water2OffsetY = 0;\n        this._secondaryNormalMap = secondaryNormalMap;\n        if (this._secondaryNormalMap)\n            this.iAddTexture(this._secondaryNormalMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = .5;\n        data[index + 1] = 0;\n        data[index + 2] = 0;\n        data[index + 3] = 1;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iInitVO = function (shader, methodVO) {\n        _super.prototype.iInitVO.call(this, shader, methodVO);\n        if (this._secondaryNormalMap) {\n            methodVO.secondaryTextureGL = shader.getAbstraction(this._secondaryNormalMap);\n            shader.uvDependencies++;\n        }\n    };\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"water1OffsetX\", {\n        /**\n         * The translation of the first wave layer along the X-axis.\n         */\n        get: function () {\n            return this._water1OffsetX;\n        },\n        set: function (value) {\n            this._water1OffsetX = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"water1OffsetY\", {\n        /**\n         * The translation of the first wave layer along the Y-axis.\n         */\n        get: function () {\n            return this._water1OffsetY;\n        },\n        set: function (value) {\n            this._water1OffsetY = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"water2OffsetX\", {\n        /**\n         * The translation of the second wave layer along the X-axis.\n         */\n        get: function () {\n            return this._water2OffsetX;\n        },\n        set: function (value) {\n            this._water2OffsetX = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"water2OffsetY\", {\n        /**\n         * The translation of the second wave layer along the Y-axis.\n         */\n        get: function () {\n            return this._water2OffsetY;\n        },\n        set: function (value) {\n            this._water2OffsetY = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"secondaryNormalMap\", {\n        /**\n         * A second normal map that will be combined with the first to create a wave-like animation pattern.\n         */\n        get: function () {\n            return this._secondaryNormalMap;\n        },\n        set: function (value) {\n            if (this._secondaryNormalMap == value)\n                return;\n            if (this._secondaryNormalMap)\n                this.iRemoveTexture(this._secondaryNormalMap);\n            this._secondaryNormalMap = value;\n            if (this._secondaryNormalMap)\n                this.iAddTexture(this._secondaryNormalMap);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._secondaryNormalMap = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index + 4] = this._water1OffsetX;\n        data[index + 5] = this._water1OffsetY;\n        data[index + 6] = this._water2OffsetX;\n        data[index + 7] = this._water2OffsetY;\n        if (this._secondaryNormalMap)\n            methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);\n        if (this._secondaryNormalMap)\n            methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var dataReg = registerCache.getFreeFragmentConstant();\n        var dataReg2 = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = dataReg.index * 4;\n        code += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".xyxy\\n\";\n        if (this.texture)\n            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, temp);\n        code += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".zwzw\\n\";\n        if (this._secondaryNormalMap)\n            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp);\n        code += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\t\t\\n\" +\n            \"mul \" + targetReg + \", \" + targetReg + \", \" + dataReg + \".x\t\\n\" +\n            \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\t\\n\" +\n            \"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\t\t\t\t\t\t\t\\n\";\n        return code;\n    };\n    return NormalSimpleWaterMethod;\n}(NormalBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = NormalSimpleWaterMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\":\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetBase_1 = require(\"awayjs-core/lib/library/AssetBase\");\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\n/**\n * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile\n * the final shading program.\n */\nvar ShadingMethodBase = (function (_super) {\n    __extends(ShadingMethodBase, _super);\n    /**\n     * Create a new ShadingMethodBase object.\n     */\n    function ShadingMethodBase() {\n        _super.call(this);\n        this._textures = new Array();\n        this._owners = new Array();\n        this._counts = new Array();\n    }\n    Object.defineProperty(ShadingMethodBase.prototype, \"assetType\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return ShadingMethodBase.assetType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ShadingMethodBase.prototype.iIsUsed = function (shader) {\n        return true;\n    };\n    /**\n     * Initializes the properties for a MethodVO, including register and texture indices.\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iInitVO = function (shader, methodVO) {\n    };\n    /**\n     * Initializes unchanging shader constants using the data from a MethodVO.\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iInitConstants = function (shader, methodVO) {\n    };\n    /**\n     * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.\n     */\n    ShadingMethodBase.prototype.iUsesTangentSpace = function () {\n        return true;\n    };\n    /**\n     * Cleans up any resources used by the current object.\n     */\n    ShadingMethodBase.prototype.dispose = function () {\n    };\n    ShadingMethodBase.prototype.iAddOwner = function (owner) {\n        //a method can be used more than once in the same material, so we check for this\n        var index = this._owners.indexOf(owner);\n        if (index != -1) {\n            this._counts[index]++;\n        }\n        else {\n            this._owners.push(owner);\n            this._counts.push(1);\n            //add textures\n            var len = this._textures.length;\n            for (var i = 0; i < len; i++)\n                owner.addTexture(this._textures[i]);\n        }\n    };\n    ShadingMethodBase.prototype.iRemoveOwner = function (owner) {\n        var index = this._owners.indexOf(owner);\n        if (this._counts[index] != 1) {\n            this._counts[index]--;\n        }\n        else {\n            this._owners.splice(index, 1);\n            this._counts.splice(index, 1);\n            //remove textures\n            var len = this._textures.length;\n            for (var i = 0; i < len; i++)\n                owner.removeTexture(this._textures[i]);\n        }\n    };\n    /**\n     *\n     */\n    ShadingMethodBase.prototype.iAddTexture = function (texture) {\n        this._textures.push(texture);\n        var len = this._owners.length;\n        for (var i = 0; i < len; i++)\n            this._owners[i].addTexture(texture);\n    };\n    /**\n     *\n     */\n    ShadingMethodBase.prototype.iRemoveTexture = function (texture) {\n        this._textures.splice(this._textures.indexOf(texture), 1);\n        var len = this._owners.length;\n        for (var i = 0; i < len; i++)\n            this._owners[i].removeTexture(texture);\n    };\n    /**\n     * Resets the compilation state of the method.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iReset = function () {\n        this.iCleanCompilationData();\n    };\n    /**\n     * Resets the method's state for compilation.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iCleanCompilationData = function () {\n    };\n    /**\n     * Get the vertex shader code for this method.\n     * @param vo The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadingMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return null;\n    };\n    /**\n     * Sets the render state for this method.\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param stage The Stage object currently used for rendering.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iActivate = function (shader, methodVO, stage) {\n    };\n    /**\n     * Sets the render state for a single renderable.\n     *\n     * @param vo The MethodVO object linking this method with the pass currently being compiled.\n     * @param renderable The renderable currently being rendered.\n     * @param stage The Stage object currently used for rendering.\n     * @param camera The camera from which the scene is currently rendered.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n    };\n    /**\n     * Clears the render state for this method.\n     * @param vo The MethodVO object linking this method with the pass currently being compiled.\n     * @param stage The Stage object currently used for rendering.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iDeactivate = function (shader, methodVO, stage) {\n    };\n    /**\n     * Marks the shader program as invalid, so it will be recompiled before the next render.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iInvalidateShaderProgram = function () {\n        this.dispatchEvent(new ShadingMethodEvent_1.default(ShadingMethodEvent_1.default.SHADER_INVALIDATED));\n    };\n    /**\n     * Copies the state from a ShadingMethodBase object into the current object.\n     */\n    ShadingMethodBase.prototype.copyFrom = function (method) {\n    };\n    ShadingMethodBase.assetType = \"[asset ShadingMethod]\";\n    return ShadingMethodBase;\n}(AssetBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadingMethodBase;\n\n},{\"awayjs-core/lib/library/AssetBase\":undefined,\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/ShadowCascadeMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar DirectionalLight_1 = require(\"awayjs-display/lib/display/DirectionalLight\");\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar MethodVO_1 = require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nvar ShadowMapMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\n/**\n * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.\n * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.\n *\n * @see away.lights.CascadeShadowMapper\n */\nvar ShadowCascadeMethod = (function (_super) {\n    __extends(ShadowCascadeMethod, _super);\n    /**\n     * Creates a new ShadowCascadeMethod object.\n     *\n     * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n     */\n    function ShadowCascadeMethod(shadowMethodBase) {\n        var _this = this;\n        _super.call(this, shadowMethodBase.castingLight);\n        this._baseMethod = shadowMethodBase;\n        if (!(this._pCastingLight instanceof DirectionalLight_1.default))\n            throw new Error(\"ShadowCascadeMethod is only compatible with DirectionalLight\");\n        this._cascadeShadowMapper = this._pCastingLight.shadowMapper;\n        if (!this._cascadeShadowMapper)\n            throw new Error(\"ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.\");\n        this._cascadeShadowMapper.addEventListener(AssetEvent_1.default.INVALIDATE, function (event) { return _this.onCascadeChange(event); });\n        this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, function (event) { return _this.onShaderInvalidated(event); });\n    }\n    Object.defineProperty(ShadowCascadeMethod.prototype, \"baseMethod\", {\n        /**\n         * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction\n         * with a DirectionalShadowMapper.\n         *\n         * @see ShadowHardMethod\n         * @see ShadowSoftMethod\n         */\n        get: function () {\n            return this._baseMethod;\n        },\n        set: function (value) {\n            var _this = this;\n            if (this._baseMethod == value)\n                return;\n            this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, function (event) { return _this.onShaderInvalidated(event); });\n            this._baseMethod = value;\n            this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, function (event) { return _this.onShaderInvalidated(event); });\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iInitVO = function (shader, methodVO) {\n        var tempVO = new MethodVO_1.default(this._baseMethod, methodVO.pass);\n        this._baseMethod.iInitVO(shader, tempVO);\n        methodVO.needsGlobalVertexPos = true;\n        methodVO.needsProjection = true;\n        methodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var fragmentData = shader.fragmentConstantData;\n        var vertexData = shader.vertexConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        fragmentData[index] = 1.0;\n        fragmentData[index + 1] = 1 / 255.0;\n        fragmentData[index + 2] = 1 / 65025.0;\n        fragmentData[index + 3] = 1 / 16581375.0;\n        fragmentData[index + 6] = .5;\n        fragmentData[index + 7] = -.5;\n        index = methodVO.vertexConstantsIndex;\n        vertexData[index] = .5;\n        vertexData[index + 1] = -.5;\n        vertexData[index + 2] = 0;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._cascadeProjections = null;\n        this._depthMapCoordVaryings = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = \"\";\n        var dataReg = registerCache.getFreeVertexConstant();\n        this.initProjectionsRegs(registerCache);\n        methodVO.vertexConstantsIndex = dataReg.index * 4;\n        var temp = registerCache.getFreeVertexVectorTemp();\n        for (var i = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n            code += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + this._cascadeProjections[i] + \"\\n\" +\n                \"add \" + this._depthMapCoordVaryings[i] + \", \" + temp + \", \" + dataReg + \".zzwz\\n\";\n        }\n        return code;\n    };\n    /**\n     * Creates the registers for the cascades' projection coordinates.\n     */\n    ShadowCascadeMethod.prototype.initProjectionsRegs = function (registerCache) {\n        this._cascadeProjections = new Array(this._cascadeShadowMapper.numCascades);\n        this._depthMapCoordVaryings = new Array(this._cascadeShadowMapper.numCascades);\n        for (var i = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n            this._depthMapCoordVaryings[i] = registerCache.getFreeVarying();\n            this._cascadeProjections[i] = registerCache.getFreeVertexConstant();\n            registerCache.getFreeVertexConstant();\n            registerCache.getFreeVertexConstant();\n            registerCache.getFreeVertexConstant();\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var numCascades = this._cascadeShadowMapper.numCascades;\n        var decReg = registerCache.getFreeFragmentConstant();\n        var dataReg = registerCache.getFreeFragmentConstant();\n        var planeDistanceReg = registerCache.getFreeFragmentConstant();\n        var planeDistances = Array(planeDistanceReg + \".x\", planeDistanceReg + \".y\", planeDistanceReg + \".z\", planeDistanceReg + \".w\");\n        var code;\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        var inQuad = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(inQuad, 1);\n        var uvCoord = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(uvCoord, 1);\n        // assume lowest partition is selected, will be overwritten later otherwise\n        code = \"mov \" + uvCoord + \", \" + this._depthMapCoordVaryings[numCascades - 1] + \"\\n\";\n        for (var i = numCascades - 2; i >= 0; --i) {\n            var uvProjection = this._depthMapCoordVaryings[i];\n            // calculate if in texturemap (result == 0 or 1, only 1 for a single partition)\n            code += \"slt \" + inQuad + \".z, \" + sharedRegisters.projectionFragment + \".z, \" + planeDistances[i] + \"\\n\"; // z = x > minX, w = y > minY\n            var temp = registerCache.getFreeFragmentVectorTemp();\n            // linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)\n            code += \"sub \" + temp + \", \" + uvProjection + \", \" + uvCoord + \"\\n\" +\n                \"mul \" + temp + \", \" + temp + \", \" + inQuad + \".z\\n\" +\n                \"add \" + uvCoord + \", \" + uvCoord + \", \" + temp + \"\\n\";\n        }\n        registerCache.removeFragmentTempUsage(inQuad);\n        code += \"div \" + uvCoord + \", \" + uvCoord + \", \" + uvCoord + \".w\\n\" +\n            \"mul \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zw\\n\" +\n            \"add \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zz\\n\";\n        code += this._baseMethod._iGetCascadeFragmentCode(shader, methodVO, decReg, uvCoord, targetReg, registerCache, sharedRegisters) +\n            \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + dataReg + \".y\\n\";\n        registerCache.removeFragmentTempUsage(uvCoord);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        methodVO.textureGL.activate(methodVO.pass._render);\n        var vertexData = shader.vertexConstantData;\n        var vertexIndex = methodVO.vertexConstantsIndex;\n        shader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1 / (this._cascadeShadowMapper.depth * this._pEpsilon);\n        var numCascades = this._cascadeShadowMapper.numCascades;\n        vertexIndex += 4;\n        for (var k = 0; k < numCascades; ++k) {\n            this._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);\n            vertexIndex += 16;\n        }\n        var fragmentData = shader.fragmentConstantData;\n        var fragmentIndex = methodVO.fragmentConstantsIndex;\n        fragmentData[fragmentIndex + 5] = 1 - this._pAlpha;\n        var nearPlaneDistances = this._cascadeShadowMapper._iNearPlaneDistances;\n        fragmentIndex += 8;\n        for (var i = 0; i < numCascades; ++i)\n            fragmentData[fragmentIndex + i] = nearPlaneDistances[i];\n        this._baseMethod.iActivateForCascade(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n    };\n    /**\n     * Called when the shadow mappers cascade configuration changes.\n     */\n    ShadowCascadeMethod.prototype.onCascadeChange = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    /**\n     * Called when the base method's shader code is invalidated.\n     */\n    ShadowCascadeMethod.prototype.onShaderInvalidated = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    return ShadowCascadeMethod;\n}(ShadowMapMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowCascadeMethod;\n\n},{\"awayjs-core/lib/events/AssetEvent\":undefined,\"awayjs-display/lib/display/DirectionalLight\":undefined,\"awayjs-methodmaterials/lib/data/MethodVO\":\"awayjs-methodmaterials/lib/data/MethodVO\",\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\",\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/ShadowDitheredMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar BitmapImage2D_1 = require(\"awayjs-core/lib/image/BitmapImage2D\");\nvar Single2DTexture_1 = require(\"awayjs-display/lib/textures/Single2DTexture\");\nvar ShadowMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n/**\n * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.\n */\nvar ShadowDitheredMethod = (function (_super) {\n    __extends(ShadowDitheredMethod, _super);\n    /**\n     * Creates a new ShadowDitheredMethod object.\n     * @param castingLight The light casting the shadows\n     * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.\n     */\n    function ShadowDitheredMethod(castingLight, numSamples, range) {\n        if (numSamples === void 0) { numSamples = 4; }\n        if (range === void 0) { range = 1; }\n        _super.call(this, castingLight);\n        this._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;\n        this.numSamples = numSamples;\n        this.range = range;\n        ++ShadowDitheredMethod._grainUsages;\n        if (!ShadowDitheredMethod._grainTexture)\n            this.initGrainTexture();\n    }\n    Object.defineProperty(ShadowDitheredMethod.prototype, \"numSamples\", {\n        /**\n         * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the\n         * complexity of the shader.\n         */\n        get: function () {\n            return this._numSamples;\n        },\n        set: function (value /*int*/) {\n            if (value < 1)\n                value = 1;\n            else if (value > 24)\n                value = 24;\n            if (this._numSamples == value)\n                return;\n            this._numSamples = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iInitVO = function (shader, methodVO) {\n        _super.prototype.iInitVO.call(this, shader, methodVO);\n        methodVO.needsProjection = true;\n        methodVO.secondaryTextureGL = shader.getAbstraction(ShadowDitheredMethod._grainTexture);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        fragmentData[index + 8] = 1 / this._numSamples;\n    };\n    Object.defineProperty(ShadowDitheredMethod.prototype, \"range\", {\n        /**\n         * The range in the shadow map in which to distribute the samples.\n         */\n        get: function () {\n            return this._range * 2;\n        },\n        set: function (value) {\n            this._range = value / 2;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates a texture containing the dithering noise texture.\n     */\n    ShadowDitheredMethod.prototype.initGrainTexture = function () {\n        ShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D_1.default(64, 64, false);\n        var vec = new Array();\n        var len = 4096;\n        var step = 1 / (this._depthMapSize * this._range);\n        var r, g;\n        for (var i = 0; i < len; ++i) {\n            r = 2 * (Math.random() - .5);\n            g = 2 * (Math.random() - .5);\n            if (r < 0)\n                r -= step;\n            else\n                r += step;\n            if (g < 0)\n                g -= step;\n            else\n                g += step;\n            if (r > 1)\n                r = 1;\n            else if (r < -1)\n                r = -1;\n            if (g > 1)\n                g = 1;\n            else if (g < -1)\n                g = -1;\n            vec[i] = (Math.floor((r * .5 + .5) * 0xff) << 16) | (Math.floor((g * .5 + .5) * 0xff) << 8);\n        }\n        ShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);\n        ShadowDitheredMethod._grainTexture = new Single2DTexture_1.default(ShadowDitheredMethod._grainBitmapImage2D);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.dispose = function () {\n        if (--ShadowDitheredMethod._grainUsages == 0) {\n            ShadowDitheredMethod._grainTexture.dispose();\n            ShadowDitheredMethod._grainBitmapImage2D.dispose();\n            ShadowDitheredMethod._grainTexture = null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index + 9] = (stage.width - 1) / 63;\n        data[index + 10] = (stage.height - 1) / 63;\n        data[index + 11] = 2 * this._range / this._depthMapSize;\n        methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);\n        methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        var decReg = regCache.getFreeFragmentConstant();\n        var dataReg = regCache.getFreeFragmentConstant();\n        var customDataReg = regCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        return this.getSampleCode(shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);\n    };\n    /**\n     * Get the actual shader code for shadow mapping\n     * @param regCache The register cache managing the registers.\n     * @param depthMapRegister The texture register containing the depth map.\n     * @param decReg The register containing the depth map decoding data.\n     * @param targetReg The target register to add the shadow coverage.\n     */\n    ShadowDitheredMethod.prototype.getSampleCode = function (shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters) {\n        var code = \"\";\n        var numSamples = this._numSamples;\n        var uvReg = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(uvReg, 1);\n        var temp = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(temp, 1);\n        var projectionReg = sharedRegisters.projectionFragment;\n        code += \"div \" + uvReg + \", \" + projectionReg + \", \" + projectionReg + \".w\\n\" +\n            \"mul \" + uvReg + \".xy, \" + uvReg + \".xy, \" + customDataReg + \".yz\\n\";\n        while (numSamples > 0) {\n            if (numSamples == this._numSamples) {\n                code += methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, uvReg);\n            }\n            else {\n                code += \"mov \" + temp + \", \" + uvReg + \".zwxy \\n\" +\n                    methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, temp);\n            }\n            // keep grain in uvReg.zw\n            code += \"sub \" + uvReg + \".zw, \" + uvReg + \".xy, fc0.xx\\n\" +\n                \"mul \" + uvReg + \".zw, \" + uvReg + \".zw, \" + customDataReg + \".w\\n\"; // (tex unpack scale and tex scale in one)\n            if (numSamples == this._numSamples) {\n                // first sample\n                code += \"add \" + uvReg + \".xy, \" + uvReg + \".zw, \" + this._pDepthMapCoordReg + \".xy\\n\" +\n                    methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n                    \"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n                    \"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n            }\n            else {\n                code += this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            }\n            if (numSamples > 4)\n                code += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 1)\n                code += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 5)\n                code += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 2) {\n                code += \"neg \" + uvReg + \".w, \" + uvReg + \".w\\n\"; // will be rotated 90 degrees when being accessed as wz\n                code += \"add \" + uvReg + \".xy, \" + uvReg + \".wz, \" + this._pDepthMapCoordReg + \".xy\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            }\n            if (numSamples > 6)\n                code += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 3)\n                code += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 7)\n                code += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            numSamples -= 8;\n        }\n        regCache.removeFragmentTempUsage(temp);\n        regCache.removeFragmentTempUsage(uvReg);\n        code += \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + customDataReg + \".x\\n\"; // average\n        return code;\n    };\n    /**\n     * Adds the code for another tap to the shader code.\n     * @param uvReg The uv register for the tap.\n     * @param depthMapRegister The texture register containing the depth map.\n     * @param decReg The register containing the depth map decoding data.\n     * @param targetReg The target register to add the tap comparison result.\n     * @param regCache The register cache managing the registers.\n     * @return\n     */\n    ShadowDitheredMethod.prototype.addSample = function (shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters) {\n        var temp = regCache.getFreeFragmentVectorTemp();\n        return methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n            \"slt \" + temp + \".z, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" +\n            \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \".z\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        data[index] = 1 / this._numSamples;\n        data[index + 1] = (stage.width - 1) / 63;\n        data[index + 2] = (stage.height - 1) / 63;\n        data[index + 3] = 2 * this._range / this._depthMapSize;\n        methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        this._pDepthMapCoordReg = depthProjection;\n        var dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;\n        return this.getSampleCode(shader, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);\n    };\n    return ShadowDitheredMethod;\n}(ShadowMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowDitheredMethod;\n\n},{\"awayjs-core/lib/image/BitmapImage2D\":undefined,\"awayjs-display/lib/textures/Single2DTexture\":undefined,\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\"}],\"awayjs-methodmaterials/lib/methods/ShadowFilteredMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadowMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n/**\n * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison\n * results of neighbouring pixels.\n */\nvar ShadowFilteredMethod = (function (_super) {\n    __extends(ShadowFilteredMethod, _super);\n    /**\n     * Creates a new DiffuseBasicMethod object.\n     *\n     * @param castingLight The light casting the shadow\n     */\n    function ShadowFilteredMethod(castingLight) {\n        _super.call(this, castingLight);\n    }\n    /**\n     * @inheritDoc\n     */\n    ShadowFilteredMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        fragmentData[index + 8] = .5;\n        var size = this.castingLight.shadowMapper.depthMapSize;\n        fragmentData[index + 9] = size;\n        fragmentData[index + 10] = 1 / size;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowFilteredMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        var code = \"\";\n        var decReg = regCache.getFreeFragmentConstant();\n        regCache.getFreeFragmentConstant();\n        var customDataReg = regCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        var depthCol = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(depthCol, 1);\n        var uvReg = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(uvReg, 1);\n        code += \"mov \" + uvReg + \", \" + this._pDepthMapCoordReg + \"\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +\n            \"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +\n            \"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n            \"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n            \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n            \"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n            \"add \" + targetReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n            \"mov \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x\\n\" +\n            \"add \" + uvReg + \".y, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".z\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +\n            \"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +\n            // recalculate fraction, since we ran out of registers :(\n            \"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n            \"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n            \"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n            \"add \" + uvReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n            \"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".y\\n\" +\n            \"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n            \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + targetReg + \".w\\n\" +\n            \"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n            \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + uvReg + \".w\\n\";\n        regCache.removeFragmentTempUsage(depthCol);\n        regCache.removeFragmentTempUsage(uvReg);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowFilteredMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n        var size = this.castingLight.shadowMapper.depthMapSize;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = size;\n        data[index + 1] = 1 / size;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowFilteredMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        var code;\n        var dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var predicate = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(predicate, 1);\n        code = methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + predicate + \".x, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n            \"add \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + predicate + \".z, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n            \"add \" + depthProjection + \".y, \" + depthProjection + \".y, \" + dataReg + \".y\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + predicate + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n            \"sub \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + predicate + \".y, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n            \"mul \" + temp + \".xy, \" + depthProjection + \".xy, \" + dataReg + \".x\\n\" +\n            \"frc \" + temp + \".xy, \" + temp + \".xy\\n\" +\n            // some strange register juggling to prevent agal bugging out\n            \"sub \" + depthProjection + \", \" + predicate + \".xyzw, \" + predicate + \".zwxy\\n\" +\n            \"mul \" + depthProjection + \", \" + depthProjection + \", \" + temp + \".x\\n\" +\n            \"add \" + predicate + \".xy, \" + predicate + \".xy, \" + depthProjection + \".zw\\n\" +\n            \"sub \" + predicate + \".y, \" + predicate + \".y, \" + predicate + \".x\\n\" +\n            \"mul \" + predicate + \".y, \" + predicate + \".y, \" + temp + \".y\\n\" +\n            \"add \" + targetRegister + \".w, \" + predicate + \".x, \" + predicate + \".y\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        registerCache.removeFragmentTempUsage(predicate);\n        return code;\n    };\n    return ShadowFilteredMethod;\n}(ShadowMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowFilteredMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\"}],\"awayjs-methodmaterials/lib/methods/ShadowHardMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadowMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n/**\n * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.\n */\nvar ShadowHardMethod = (function (_super) {\n    __extends(ShadowHardMethod, _super);\n    /**\n     * Creates a new ShadowHardMethod object.\n     */\n    function ShadowHardMethod(castingLight) {\n        _super.call(this, castingLight);\n    }\n    /**\n     * @inheritDoc\n     */\n    ShadowHardMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        var code = \"\";\n        var decReg = regCache.getFreeFragmentConstant();\n        regCache.getFreeFragmentConstant();\n        var depthCol = regCache.getFreeFragmentVectorTemp();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        code += methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\"; // 0 if in shadow\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowHardMethod.prototype._pGetPointFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        var code = \"\";\n        var decReg = regCache.getFreeFragmentConstant();\n        var epsReg = regCache.getFreeFragmentConstant();\n        var posReg = regCache.getFreeFragmentConstant();\n        var depthSampleCol = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(depthSampleCol, 1);\n        var lightDir = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(lightDir, 1);\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        code += \"sub \" + lightDir + \", \" + sharedRegisters.globalPositionVarying + \", \" + posReg + \"\\n\" +\n            \"dp3 \" + lightDir + \".w, \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n            \"mul \" + lightDir + \".w, \" + lightDir + \".w, \" + posReg + \".w\\n\" +\n            \"nrm \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthSampleCol, regCache, sharedRegisters, lightDir) +\n            \"dp4 \" + depthSampleCol + \".z, \" + depthSampleCol + \", \" + decReg + \"\\n\" +\n            \"add \" + targetReg + \".w, \" + lightDir + \".w, \" + epsReg + \".x\\n\" +\n            \"slt \" + targetReg + \".w, \" + targetReg + \".w, \" + depthSampleCol + \".z\\n\"; // 0 if in shadow\n        regCache.removeFragmentTempUsage(lightDir);\n        regCache.removeFragmentTempUsage(depthSampleCol);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowHardMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + targetRegister + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowHardMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n    };\n    return ShadowHardMethod;\n}(ShadowMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowHardMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\"}],\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n/**\n * ShadowMapMethodBase provides an abstract base method for shadow map methods.\n */\nvar ShadowMapMethodBase = (function (_super) {\n    __extends(ShadowMapMethodBase, _super);\n    /**\n     * Creates a new ShadowMapMethodBase object.\n     * @param castingLight The light used to cast shadows.\n     */\n    function ShadowMapMethodBase(castingLight) {\n        _super.call(this);\n        this._pEpsilon = .02;\n        this._pAlpha = 1;\n        this._pCastingLight = castingLight;\n        castingLight.shadowsEnabled = true;\n        this._pShadowMapper = castingLight.shadowMapper;\n        this.iAddTexture(castingLight.shadowMapper.depthMap);\n    }\n    Object.defineProperty(ShadowMapMethodBase.prototype, \"assetType\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return ShadowMapMethodBase.assetType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowMapMethodBase.prototype, \"alpha\", {\n        /**\n         * The \"transparency\" of the shadows. This allows making shadows less strong.\n         */\n        get: function () {\n            return this._pAlpha;\n        },\n        set: function (value) {\n            this._pAlpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowMapMethodBase.prototype, \"castingLight\", {\n        /**\n         * The light casting the shadows.\n         */\n        get: function () {\n            return this._pCastingLight;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowMapMethodBase.prototype, \"epsilon\", {\n        /**\n         * A small value to counter floating point precision errors when comparing values in the shadow map with the\n         * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.\n         */\n        get: function () {\n            return this._pEpsilon;\n        },\n        set: function (value) {\n            this._pEpsilon = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ShadowMapMethodBase.assetType = \"[asset ShadowMapMethod]\";\n    return ShadowMapMethodBase;\n}(ShadingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowMapMethodBase;\n\n},{\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AbstractMethodError_1 = require(\"awayjs-core/lib/errors/AbstractMethodError\");\nvar PointLight_1 = require(\"awayjs-display/lib/display/PointLight\");\nvar ShadowMapMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\n/**\n * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.\n */\nvar ShadowMethodBase = (function (_super) {\n    __extends(ShadowMethodBase, _super);\n    /**\n     * Creates a new ShadowMethodBase object.\n     * @param castingLight The light used to cast shadows.\n     */\n    function ShadowMethodBase(castingLight) {\n        _super.call(this, castingLight);\n        this._pUsePoint = (castingLight instanceof PointLight_1.default);\n    }\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsView = true;\n        methodVO.needsGlobalVertexPos = true;\n        methodVO.needsGlobalFragmentPos = this._pUsePoint;\n        methodVO.needsNormals = shader.numLights > 0;\n        methodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iInitConstants = function (shader, methodVO) {\n        var fragmentData = shader.fragmentConstantData;\n        var vertexData = shader.vertexConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        fragmentData[index] = 1.0;\n        fragmentData[index + 1] = 1 / 255.0;\n        fragmentData[index + 2] = 1 / 65025.0;\n        fragmentData[index + 3] = 1 / 16581375.0;\n        fragmentData[index + 6] = 0;\n        fragmentData[index + 7] = 1;\n        if (this._pUsePoint) {\n            fragmentData[index + 8] = 0;\n            fragmentData[index + 9] = 0;\n            fragmentData[index + 10] = 0;\n            fragmentData[index + 11] = 1;\n        }\n        index = methodVO.vertexConstantsIndex;\n        if (index != -1) {\n            vertexData[index] = .5;\n            vertexData[index + 1] = .5;\n            vertexData[index + 2] = 0.0;\n            vertexData[index + 3] = 1.0;\n        }\n    };\n    Object.defineProperty(ShadowMethodBase.prototype, \"_iDepthMapCoordReg\", {\n        /**\n         * Wrappers that override the vertex shader need to set this explicitly\n         */\n        get: function () {\n            return this._pDepthMapCoordReg;\n        },\n        set: function (value) {\n            this._pDepthMapCoordReg = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._pDepthMapCoordReg = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iGetVertexCode = function (shader, methodVO, regCache, sharedRegisters) {\n        return this._pUsePoint ? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters) : this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);\n    };\n    /**\n     * Gets the vertex code for shadow mapping with a point light.\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     */\n    ShadowMethodBase.prototype._pGetPointVertexCode = function (methodVO, regCache, sharedRegisters) {\n        methodVO.vertexConstantsIndex = -1;\n        return \"\";\n    };\n    /**\n     * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     */\n    ShadowMethodBase.prototype.pGetPlanarVertexCode = function (methodVO, regCache, sharedRegisters) {\n        var code = \"\";\n        var temp = regCache.getFreeVertexVectorTemp();\n        var dataReg = regCache.getFreeVertexConstant();\n        var depthMapProj = regCache.getFreeVertexConstant();\n        regCache.getFreeVertexConstant();\n        regCache.getFreeVertexConstant();\n        regCache.getFreeVertexConstant();\n        this._pDepthMapCoordReg = regCache.getFreeVarying();\n        methodVO.vertexConstantsIndex = dataReg.index * 4;\n        // todo: can epsilon be applied here instead of fragment shader?\n        code += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + depthMapProj + \"\\n\" +\n            \"div \" + temp + \", \" + temp + \", \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".xy, \" + temp + \".xy, \" + dataReg + \".xy\\n\" +\n            \"add \" + this._pDepthMapCoordReg + \", \" + temp + \", \" + dataReg + \".xxwz\\n\";\n        //\"sub \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".w\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = this._pUsePoint ? this._pGetPointFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n        code += \"add \" + targetReg + \".w, \" + targetReg + \".w, fc\" + (methodVO.fragmentConstantsIndex / 4 + 1) + \".y\\n\" +\n            \"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n        return code;\n    };\n    /**\n     * Gets the fragment code for shadow mapping with a planar shadow map.\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     * @param targetReg The register to contain the shadow coverage\n     * @return\n     */\n    ShadowMethodBase.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        throw new AbstractMethodError_1.default();\n    };\n    /**\n     * Gets the fragment code for shadow mapping with a point light.\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     * @param targetReg The register to contain the shadow coverage\n     * @return\n     */\n    ShadowMethodBase.prototype._pGetPointFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        throw new AbstractMethodError_1.default();\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (!this._pUsePoint)\n            this._pShadowMapper.iDepthProjection.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);\n        methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Gets the fragment code for combining this method with a cascaded shadow map method.\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     * @param decodeRegister The register containing the data to decode the shadow map depth value.\n     * @param depthTexture The texture containing the shadow map.\n     * @param depthProjection The projection of the fragment relative to the light.\n     * @param targetRegister The register to contain the shadow coverage\n     * @return\n     */\n    ShadowMethodBase.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        throw new Error(\"This shadow method is incompatible with cascade shadows\");\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iActivate = function (shader, methodVO, stage) {\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        if (this._pUsePoint)\n            fragmentData[index + 4] = -Math.pow(1 / (this._pCastingLight.fallOff * this._pEpsilon), 2);\n        else\n            shader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1 / (this._pShadowMapper.depth * this._pEpsilon);\n        fragmentData[index + 5] = 1 - this._pAlpha;\n        if (this._pUsePoint) {\n            var pos = this._pCastingLight.scenePosition;\n            fragmentData[index + 8] = pos.x;\n            fragmentData[index + 9] = pos.y;\n            fragmentData[index + 10] = pos.z;\n            // used to decompress distance\n            var f = this._pCastingLight.fallOff;\n            fragmentData[index + 11] = 1 / (2 * f * f);\n        }\n        methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * Sets the method state for cascade shadow mapping.\n     */\n    ShadowMethodBase.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n        throw new Error(\"This shadow method is incompatible with cascade shadows\");\n    };\n    return ShadowMethodBase;\n}(ShadowMapMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowMethodBase;\n\n},{\"awayjs-core/lib/errors/AbstractMethodError\":undefined,\"awayjs-display/lib/display/PointLight\":undefined,\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\"}],\"awayjs-methodmaterials/lib/methods/ShadowNearMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar ShadowMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work\n/**\n * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize\n * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.\n *\n * @see away.lights.NearDirectionalShadowMapper\n */\nvar ShadowNearMethod = (function (_super) {\n    __extends(ShadowNearMethod, _super);\n    /**\n     * Creates a new ShadowNearMethod object.\n     * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n     * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n     */\n    function ShadowNearMethod(baseMethod, fadeRatio) {\n        var _this = this;\n        if (fadeRatio === void 0) { fadeRatio = .1; }\n        _super.call(this, baseMethod.castingLight);\n        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };\n        this._baseMethod = baseMethod;\n        this._fadeRatio = fadeRatio;\n        this._nearShadowMapper = this._pCastingLight.shadowMapper;\n        if (!this._nearShadowMapper)\n            throw new Error(\"ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.\");\n        this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n    }\n    Object.defineProperty(ShadowNearMethod.prototype, \"baseMethod\", {\n        /**\n         * The base shadow map method on which this method's shading is based.\n         */\n        get: function () {\n            return this._baseMethod;\n        },\n        set: function (value) {\n            if (this._baseMethod == value)\n                return;\n            this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this._baseMethod = value;\n            this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        this._baseMethod.iInitConstants(shader, methodVO);\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        fragmentData[index + 2] = 0;\n        fragmentData[index + 3] = 1;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iInitVO = function (shader, methodVO) {\n        this._baseMethod.iInitVO(shader, methodVO);\n        methodVO.needsProjection = true;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.dispose = function () {\n        this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n    };\n    Object.defineProperty(ShadowNearMethod.prototype, \"alpha\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.alpha;\n        },\n        set: function (value) {\n            this._baseMethod.alpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowNearMethod.prototype, \"epsilon\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.epsilon;\n        },\n        set: function (value) {\n            this._baseMethod.epsilon = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowNearMethod.prototype, \"fadeRatio\", {\n        /**\n         * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n         */\n        get: function () {\n            return this._fadeRatio;\n        },\n        set: function (value) {\n            this._fadeRatio = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = this._baseMethod.iGetFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n        var dataReg = registerCache.getFreeFragmentConstant();\n        var temp = registerCache.getFreeFragmentSingleTemp();\n        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;\n        code += \"abs \" + temp + \", \" + sharedRegisters.projectionFragment + \".w\\n\" +\n            \"sub \" + temp + \", \" + temp + \", \" + dataReg + \".x\\n\" +\n            \"mul \" + temp + \", \" + temp + \", \" + dataReg + \".y\\n\" +\n            \"sat \" + temp + \", \" + temp + \"\\n\" +\n            \"sub \" + temp + \", \" + dataReg + \".w,\" + temp + \"\\n\" +\n            \"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \"\\n\" +\n            \"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        this._baseMethod.iActivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iDeactivate = function (shader, methodVO, stage) {\n        this._baseMethod.iDeactivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        // todo: move this to activate (needs camera)\n        var near = camera.projection.near;\n        var d = camera.projection.far - near;\n        var maxDistance = this._nearShadowMapper.coverageRatio;\n        var minDistance = maxDistance * (1 - this._fadeRatio);\n        maxDistance = near + maxDistance * d;\n        minDistance = near + minDistance * d;\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        fragmentData[index] = minDistance;\n        fragmentData[index + 1] = 1 / (maxDistance - minDistance);\n        this._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iReset = function () {\n        this._baseMethod.iReset();\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._baseMethod.iCleanCompilationData();\n    };\n    /**\n     * Called when the base method's shader code is invalidated.\n     */\n    ShadowNearMethod.prototype.onShaderInvalidated = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    return ShadowNearMethod;\n}(ShadowMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowNearMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\",\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/ShadowSoftMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar PoissonLookup_1 = require(\"awayjs-core/lib/geom/PoissonLookup\");\nvar ShadowMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n/**\n * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.\n */\nvar ShadowSoftMethod = (function (_super) {\n    __extends(ShadowSoftMethod, _super);\n    /**\n     * Creates a new DiffuseBasicMethod object.\n     *\n     * @param castingLight The light casting the shadows\n     * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.\n     */\n    function ShadowSoftMethod(castingLight, numSamples, range) {\n        if (numSamples === void 0) { numSamples = 5; }\n        if (range === void 0) { range = 1; }\n        _super.call(this, castingLight);\n        this._range = 1;\n        this.numSamples = numSamples;\n        this.range = range;\n    }\n    Object.defineProperty(ShadowSoftMethod.prototype, \"numSamples\", {\n        /**\n         * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the\n         * complexity of the shader.\n         */\n        get: function () {\n            return this._numSamples;\n        },\n        set: function (value /*int*/) {\n            this._numSamples = value;\n            if (this._numSamples < 1)\n                this._numSamples = 1;\n            else if (this._numSamples > 32)\n                this._numSamples = 32;\n            this._offsets = PoissonLookup_1.default.getDistribution(this._numSamples);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowSoftMethod.prototype, \"range\", {\n        /**\n         * The range in the shadow map in which to distribute the samples.\n         */\n        get: function () {\n            return this._range;\n        },\n        set: function (value) {\n            this._range = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1 / this._numSamples;\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var texRange = .5 * this._range / this._pCastingLight.shadowMapper.depthMapSize;\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex + 10;\n        var len = this._numSamples << 1;\n        for (var i = 0; i < len; ++i)\n            data[index + i] = this._offsets[i] * texRange;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        // todo: move some things to super\n        var decReg = regCache.getFreeFragmentConstant();\n        regCache.getFreeFragmentConstant();\n        var dataReg = regCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        return this.getSampleCode(shader, methodVO, decReg, targetReg, regCache, sharedRegisters, dataReg);\n    };\n    /**\n     * Adds the code for another tap to the shader code.\n     * @param uv The uv register for the tap.\n     * @param texture The texture register containing the depth map.\n     * @param decode The register containing the depth map decoding data.\n     * @param target The target register to add the tap comparison result.\n     * @param regCache The register cache managing the registers.\n     * @return\n     */\n    ShadowSoftMethod.prototype.addSample = function (shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg) {\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" +\n            \"add \" + targetRegister + \".w, \" + targetRegister + \".w, \" + uvReg + \".w\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var texRange = this._range / this._pCastingLight.shadowMapper.depthMapSize;\n        var data = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var len = this._numSamples << 1;\n        data[index] = 1 / this._numSamples;\n        data[index + 1] = 0;\n        index += 2;\n        for (var i = 0; i < len; ++i)\n            data[index + i] = this._offsets[i] * texRange;\n        if (len % 4 == 0) {\n            data[index + len] = 0;\n            data[index + len + 1] = 0;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        this._pDepthMapCoordReg = depthProjection;\n        var dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;\n        return this.getSampleCode(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg);\n    };\n    /**\n     * Get the actual shader code for shadow mapping\n     * @param regCache The register cache managing the registers.\n     * @param depthTexture The texture register containing the depth map.\n     * @param decodeRegister The register containing the depth map decoding data.\n     * @param targetReg The target register to add the shadow coverage.\n     * @param dataReg The register containing additional data.\n     */\n    ShadowSoftMethod.prototype.getSampleCode = function (shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg) {\n        var code;\n        var uvReg = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(uvReg, 1);\n        var offsets = new Array(dataReg + \".zw\");\n        var numRegs = this._numSamples >> 1;\n        for (var i = 0; i < numRegs; ++i) {\n            var reg = registerCache.getFreeFragmentConstant();\n            offsets.push(reg + \".xy\");\n            offsets.push(reg + \".zw\");\n        }\n        for (i = 0; i < this._numSamples; ++i) {\n            if (i == 0) {\n                var temp = registerCache.getFreeFragmentVectorTemp();\n                code = \"add \" + uvReg + \", \" + this._pDepthMapCoordReg + \", \" + dataReg + \".zwyy\\n\" +\n                    methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n                    \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n                    \"slt \" + targetRegister + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow;\n            }\n            else {\n                code += \"add \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + offsets[i] + \"\\n\" +\n                    this.addSample(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg);\n            }\n        }\n        registerCache.removeFragmentTempUsage(uvReg);\n        code += \"mul \" + targetRegister + \".w, \" + targetRegister + \".w, \" + dataReg + \".x\\n\"; // average\n        return code;\n    };\n    return ShadowSoftMethod;\n}(ShadowMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ShadowSoftMethod;\n\n},{\"awayjs-core/lib/geom/PoissonLookup\":undefined,\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\"}],\"awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar SpecularBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n/**\n * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for\n * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.\n * The tangent vectors are used as the surface groove directions.\n */\nvar SpecularAnisotropicMethod = (function (_super) {\n    __extends(SpecularAnisotropicMethod, _super);\n    /**\n     * Creates a new SpecularAnisotropicMethod object.\n     */\n    function SpecularAnisotropicMethod() {\n        _super.call(this);\n    }\n    /**\n     * @inheritDoc\n     */\n    SpecularAnisotropicMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsTangents = true;\n        methodVO.needsView = true;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularAnisotropicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        if (this._pIsFirstLight)\n            t = this._pTotalLightColorReg;\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        // (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k\n        code += \"nrm \" + t + \".xyz, \" + sharedRegisters.tangentVarying + \".xyz\\n\" +\n            \"dp3 \" + t + \".w, \" + t + \".xyz, \" + lightDirReg + \".xyz\\n\" +\n            \"dp3 \" + t + \".z, \" + t + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\";\n        // (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k\n        code += \"sin \" + t + \".x, \" + t + \".w\\n\" +\n            \"sin \" + t + \".y, \" + t + \".z\\n\" +\n            // (t.x * t.y - cos(t.w)*cos(t.z)) ^ k\n            \"mul \" + t + \".x, \" + t + \".x, \" + t + \".y\\n\" +\n            // (t.x - cos(t.w)*cos(t.z)) ^ k\n            \"cos \" + t + \".z, \" + t + \".z\\n\" +\n            \"cos \" + t + \".w, \" + t + \".w\\n\" +\n            // (t.x - t.w*t.z) ^ k\n            \"mul \" + t + \".w, \" + t + \".w, \" + t + \".z\\n\" +\n            // (t.x - t.w) ^ k\n            \"sub \" + t + \".w, \" + t + \".x, \" + t + \".w\\n\";\n        if (this.texture) {\n            // apply gloss modulation from texture\n            code += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n                \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n        }\n        else\n            code += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n        // attenuate\n        code += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    return SpecularAnisotropicMethod;\n}(SpecularBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SpecularAnisotropicMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar LightingMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\n/**\n * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated\n * version of Phong specularity).\n */\nvar SpecularBasicMethod = (function (_super) {\n    __extends(SpecularBasicMethod, _super);\n    /**\n     * Creates a new SpecularBasicMethod object.\n     */\n    function SpecularBasicMethod() {\n        _super.call(this);\n        this._gloss = 50;\n        this._strength = 1;\n        this._color = 0xffffff;\n        this._iSpecularR = 1;\n        this._iSpecularG = 1;\n        this._iSpecularB = 1;\n    }\n    SpecularBasicMethod.prototype.iIsUsed = function (shader) {\n        if (!shader.numLights)\n            return false;\n        return true;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = shader.numLights > 0;\n        methodVO.needsView = shader.numLights > 0;\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.default(AssetEvent_1.default.CLEAR, null));\n            methodVO.textureGL = null;\n        }\n    };\n    Object.defineProperty(SpecularBasicMethod.prototype, \"gloss\", {\n        /**\n         * The glossiness of the material (sharpness of the specular highlight).\n         */\n        get: function () {\n            return this._gloss;\n        },\n        set: function (value) {\n            this._gloss = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularBasicMethod.prototype, \"strength\", {\n        /**\n         * The overall strength of the specular highlights.\n         */\n        get: function () {\n            return this._strength;\n        },\n        set: function (value) {\n            if (value == this._strength)\n                return;\n            this._strength = value;\n            this.updateSpecular();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularBasicMethod.prototype, \"color\", {\n        /**\n         * The colour of the specular reflection of the surface.\n         */\n        get: function () {\n            return this._color;\n        },\n        set: function (value) {\n            if (this._color == value)\n                return;\n            // specular is now either enabled or disabled\n            if (this._color == 0 || value == 0)\n                this.iInvalidateShaderProgram();\n            this._color = value;\n            this.updateSpecular();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularBasicMethod.prototype, \"texture\", {\n        /**\n         * A texture that defines the strength of specular reflections for each texel in the red channel,\n         * and the gloss factor (sharpness) in the green channel. You can use Specular2DTexture if you want to easily set\n         * specular and gloss maps from grayscale images, but correctly authored images are preferred.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.copyFrom = function (method) {\n        var m = method;\n        var bsm = method;\n        var spec = bsm; //SpecularBasicMethod(method);\n        this.texture = spec.texture;\n        this.strength = spec.strength;\n        this.color = spec.color;\n        this.gloss = spec.gloss;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._pTotalLightColorReg = null;\n        this._pSpecularTexData = null;\n        this._pSpecularDataRegister = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = \"\";\n        this._pIsFirstLight = true;\n        this._pSpecularDataRegister = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index * 4;\n        if (this._texture) {\n            this._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(this._pSpecularTexData, 1);\n            code += methodVO.textureGL._iGetFragmentCode(this._pSpecularTexData, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n        }\n        this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        var normalReg = sharedRegisters.normalFragment;\n        // blinn-phong half vector model\n        code += \"add \" + t + \", \" + lightDirReg + \", \" + viewDirReg + \"\\n\" +\n            \"nrm \" + t + \".xyz, \" + t + \"\\n\" +\n            \"dp3 \" + t + \".w, \" + normalReg + \", \" + t + \"\\n\" +\n            \"sat \" + t + \".w, \" + t + \".w\\n\";\n        if (this._texture) {\n            // apply gloss modulation from texture\n            code += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n                \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n        }\n        else {\n            code += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n        }\n        // attenuate\n        if (shader.usesLightFallOff)\n            code += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += \"mul \" + t + \".xyz, \" + lightColReg + \", \" + t + \".w\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        var normalReg = sharedRegisters.normalFragment;\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        code += \"dp3 \" + t + \".w, \" + normalReg + \", \" + viewDirReg + \"\\n\" +\n            \"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n            \"mul \" + t + \", \" + t + \".w, \" + normalReg + \"\\n\" +\n            \"sub \" + t + \", \" + t + \", \" + viewDirReg + \"\\n\" +\n            \"tex \" + t + \", \" + t + \", \" + cubeMapReg + \" <cube,\" + \"linear\" + \",miplinear>\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \", \" + weightRegister + \"\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (sharedRegisters.shadowTarget)\n            code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n        if (this._texture) {\n            // apply strength modulation from texture\n            code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularTexData + \".x\\n\";\n            registerCache.removeFragmentTempUsage(this._pSpecularTexData);\n        }\n        // apply material's specular reflection\n        code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularDataRegister + \"\\n\" +\n            \"add \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\";\n        registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (this._texture)\n            methodVO.textureGL.activate(methodVO.pass._render);\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._iSpecularR;\n        data[index + 1] = this._iSpecularG;\n        data[index + 2] = this._iSpecularB;\n        data[index + 3] = this._gloss;\n    };\n    SpecularBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (this._texture)\n            methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Updates the specular color data used by the render state.\n     */\n    SpecularBasicMethod.prototype.updateSpecular = function () {\n        this._iSpecularR = ((this._color >> 16) & 0xff) / 0xff * this._strength;\n        this._iSpecularG = ((this._color >> 8) & 0xff) / 0xff * this._strength;\n        this._iSpecularB = (this._color & 0xff) / 0xff * this._strength;\n    };\n    return SpecularBasicMethod;\n}(LightingMethodBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SpecularBasicMethod;\n\n},{\"awayjs-core/lib/events/AssetEvent\":undefined,\"awayjs-methodmaterials/lib/methods/LightingMethodBase\":\"awayjs-methodmaterials/lib/methods/LightingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/SpecularCelMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar SpecularCompositeMethod_1 = require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n/**\n * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.\n */\nvar SpecularCelMethod = (function (_super) {\n    __extends(SpecularCelMethod, _super);\n    /**\n     * Creates a new SpecularCelMethod object.\n     * @param specularCutOff The threshold at which the specular highlight should be shown.\n     * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.\n     */\n    function SpecularCelMethod(specularCutOff, baseMethod) {\n        var _this = this;\n        if (specularCutOff === void 0) { specularCutOff = .5; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this, null, baseMethod);\n        this._smoothness = .1;\n        this._specularCutOff = .1;\n        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.clampSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters); };\n        this._specularCutOff = specularCutOff;\n    }\n    Object.defineProperty(SpecularCelMethod.prototype, \"smoothness\", {\n        /**\n         * The smoothness of the highlight edge.\n         */\n        get: function () {\n            return this._smoothness;\n        },\n        set: function (value) {\n            this._smoothness = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularCelMethod.prototype, \"specularCutOff\", {\n        /**\n         * The threshold at which the specular highlight should be shown.\n         */\n        get: function () {\n            return this._specularCutOff;\n        },\n        set: function (value) {\n            this._specularCutOff = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularCelMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._smoothness;\n        data[index + 1] = this._specularCutOff;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCelMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._dataReg = null;\n    };\n    /**\n     * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff\n     * @param vo The MethodVO used to compile the current shader.\n     * @param t The register containing the specular strength in the \"w\" component, and either the half-vector or the reflection vector in \"xyz\".\n     * @param regCache The register cache used for the shader compilation.\n     * @param sharedRegisters The shared register data for this shader.\n     * @return The AGAL fragment code for the method.\n     */\n    SpecularCelMethod.prototype.clampSpecular = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n            \"div \" + targetReg + \".y, \" + targetReg + \".y, \" + this._dataReg + \".x\\n\" +\n            \"sat \" + targetReg + \".y, \" + targetReg + \".y\\n\" +\n            \"sge \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        this._dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;\n        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n    };\n    return SpecularCelMethod;\n}(SpecularCompositeMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SpecularCelMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\":\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar SpecularBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n/**\n * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the\n * calculated specular reflection strength.\n */\nvar SpecularCompositeMethod = (function (_super) {\n    __extends(SpecularCompositeMethod, _super);\n    /**\n     * Creates a new <code>SpecularCompositeMethod</code> object.\n     *\n     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.\n     * @param baseMethod The base specular method on which this method's shading is based.\n     */\n    function SpecularCompositeMethod(modulateMethod, baseMethod) {\n        var _this = this;\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this);\n        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };\n        this._baseMethod = baseMethod || new SpecularBasicMethod_1.default();\n        this._baseMethod._iModulateMethod = modulateMethod;\n        this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n    }\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iInitVO = function (shader, methodVO) {\n        this._baseMethod.iInitVO(shader, methodVO);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iInitConstants = function (shader, methodVO) {\n        this._baseMethod.iInitConstants(shader, methodVO);\n    };\n    SpecularCompositeMethod.prototype.iAddOwner = function (owner) {\n        _super.prototype.iAddOwner.call(this, owner);\n        this._baseMethod.iAddOwner(owner);\n    };\n    SpecularCompositeMethod.prototype.iRemoveOwner = function (owner) {\n        _super.prototype.iRemoveOwner.call(this, owner);\n        this._baseMethod.iRemoveOwner(owner);\n    };\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"baseMethod\", {\n        /**\n         * The base specular method on which this method's shading is based.\n         */\n        get: function () {\n            return this._baseMethod;\n        },\n        set: function (value) {\n            if (this._baseMethod == value)\n                return;\n            this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this._baseMethod = value;\n            this._baseMethod.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"gloss\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.gloss;\n        },\n        set: function (value) {\n            this._baseMethod.gloss = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"strength\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.strength;\n        },\n        set: function (value) {\n            this._baseMethod.strength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"color\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.color;\n        },\n        /**\n         * @inheritDoc\n         */\n        set: function (value) {\n            this._baseMethod.color = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.dispose = function () {\n        this._baseMethod.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n        this._baseMethod.dispose();\n    };\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"texture\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.texture;\n        },\n        set: function (value) {\n            this._baseMethod.texture = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        this._baseMethod.iActivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        this._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iDeactivate = function (shader, methodVO, stage) {\n        this._baseMethod.iDeactivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     * @return\n     */\n    SpecularCompositeMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iReset = function () {\n        this._baseMethod.iReset();\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._baseMethod.iCleanCompilationData();\n    };\n    /**\n     * Called when the base method's shader code is invalidated.\n     */\n    SpecularCompositeMethod.prototype.onShaderInvalidated = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    return SpecularCompositeMethod;\n}(SpecularBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SpecularCompositeMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\",\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/SpecularFresnelMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar SpecularCompositeMethod_1 = require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n/**\n * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.\n */\nvar SpecularFresnelMethod = (function (_super) {\n    __extends(SpecularFresnelMethod, _super);\n    /**\n     * Creates a new SpecularFresnelMethod object.\n     * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n     * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.\n     */\n    function SpecularFresnelMethod(basedOnSurface, baseMethod) {\n        var _this = this;\n        if (basedOnSurface === void 0) { basedOnSurface = true; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        // may want to offer diff speculars\n        _super.call(this, null, baseMethod);\n        this._fresnelPower = 5;\n        this._normalReflectance = .028; // default value for skin\n        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.modulateSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters); };\n        this._incidentLight = !basedOnSurface;\n    }\n    /**\n     * @inheritDoc\n     */\n    SpecularFresnelMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        shader.fragmentConstantData[index + 2] = 1;\n        shader.fragmentConstantData[index + 3] = 0;\n    };\n    Object.defineProperty(SpecularFresnelMethod.prototype, \"basedOnSurface\", {\n        /**\n         * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n         */\n        get: function () {\n            return !this._incidentLight;\n        },\n        set: function (value) {\n            if (this._incidentLight != value)\n                return;\n            this._incidentLight = !value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularFresnelMethod.prototype, \"fresnelPower\", {\n        /**\n         * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n         */\n        get: function () {\n            return this._fresnelPower;\n        },\n        set: function (value) {\n            this._fresnelPower = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularFresnelMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._dataReg = null;\n    };\n    Object.defineProperty(SpecularFresnelMethod.prototype, \"normalReflectance\", {\n        /**\n         * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n         */\n        get: function () {\n            return this._normalReflectance;\n        },\n        set: function (value) {\n            this._normalReflectance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularFresnelMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        fragmentData[index] = this._normalReflectance;\n        fragmentData[index + 1] = this._fresnelPower;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularFresnelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        this._dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;\n        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * Applies the fresnel effect to the specular strength.\n     *\n     * @param vo The MethodVO object containing the method data for the currently compiled material pass.\n     * @param target The register containing the specular strength in the \"w\" component, and the half-vector/reflection vector in \"xyz\".\n     * @param regCache The register cache used for the shader compilation.\n     * @param sharedRegisters The shared registers created by the compiler.\n     * @return The AGAL fragment code for the method.\n     */\n    SpecularFresnelMethod.prototype.modulateSpecular = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code;\n        code = \"dp3 \" + targetReg + \".y, \" + sharedRegisters.viewDirFragment + \".xyz, \" + (this._incidentLight ? targetReg : sharedRegisters.normalFragment) + \".xyz\\n\" +\n            \"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +\n            \"pow \" + targetReg + \".x, \" + targetReg + \".y, \" + this._dataReg + \".y\\n\" +\n            \"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +\n            \"mul \" + targetReg + \".y, \" + this._dataReg + \".x, \" + targetReg + \".y\\n\" +\n            \"add \" + targetReg + \".y, \" + targetReg + \".x, \" + targetReg + \".y\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n        return code;\n    };\n    return SpecularFresnelMethod;\n}(SpecularCompositeMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SpecularFresnelMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\":\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/SpecularPhongMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar SpecularBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n/**\n * SpecularPhongMethod provides a specular method that provides Phong highlights.\n */\nvar SpecularPhongMethod = (function (_super) {\n    __extends(SpecularPhongMethod, _super);\n    /**\n     * Creates a new SpecularPhongMethod object.\n     */\n    function SpecularPhongMethod() {\n        _super.call(this);\n    }\n    /**\n     * @inheritDoc\n     */\n    SpecularPhongMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        var normalReg = sharedRegisters.normalFragment;\n        // phong model\n        code += \"dp3 \" + t + \".w, \" + lightDirReg + \", \" + normalReg + \"\\n\" +\n            //find the reflected light vector R\n            \"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n            \"mul \" + t + \".xyz, \" + normalReg + \", \" + t + \".w\\n\" +\n            \"sub \" + t + \".xyz, \" + t + \", \" + lightDirReg + \"\\n\" +\n            //smooth the edge as incidence angle approaches 90\n            \"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".w\\n\" +\n            \"sat \" + t + \".w, \" + t + \".w\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \", \" + t + \".w\\n\" +\n            //find the dot product between R and V\n            \"dp3 \" + t + \".w, \" + t + \", \" + viewDirReg + \"\\n\" +\n            \"sat \" + t + \".w, \" + t + \".w\\n\";\n        if (this.texture) {\n            // apply gloss modulation from texture\n            code += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n                \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n        }\n        else\n            code += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n        // attenuate\n        if (shader.usesLightFallOff)\n            code += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    return SpecularPhongMethod;\n}(SpecularBasicMethod_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SpecularPhongMethod;\n\n},{\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\"}],\"awayjs-methodmaterials/lib/methods\":[function(require,module,exports){\n\"use strict\";\nvar AmbientBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nexports.AmbientBasicMethod = AmbientBasicMethod_1.default;\nvar AmbientEnvMapMethod_1 = require(\"awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod\");\nexports.AmbientEnvMapMethod = AmbientEnvMapMethod_1.default;\nvar CurveBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/CurveBasicMethod\");\nexports.CurveBasicMethod = CurveBasicMethod_1.default;\nvar DiffuseBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nexports.DiffuseBasicMethod = DiffuseBasicMethod_1.default;\nvar DiffuseCelMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseCelMethod\");\nexports.DiffuseCelMethod = DiffuseCelMethod_1.default;\nvar DiffuseCompositeMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\nexports.DiffuseCompositeMethod = DiffuseCompositeMethod_1.default;\nvar DiffuseDepthMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseDepthMethod\");\nexports.DiffuseDepthMethod = DiffuseDepthMethod_1.default;\nvar DiffuseGradientMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseGradientMethod\");\nexports.DiffuseGradientMethod = DiffuseGradientMethod_1.default;\nvar DiffuseLightMapMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod\");\nexports.DiffuseLightMapMethod = DiffuseLightMapMethod_1.default;\nvar DiffuseSubSurfaceMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod\");\nexports.DiffuseSubSurfaceMethod = DiffuseSubSurfaceMethod_1.default;\nvar DiffuseWrapMethod_1 = require(\"awayjs-methodmaterials/lib/methods/DiffuseWrapMethod\");\nexports.DiffuseWrapMethod = DiffuseWrapMethod_1.default;\nvar EffectAlphaMaskMethod_1 = require(\"awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod\");\nexports.EffectAlphaMaskMethod = EffectAlphaMaskMethod_1.default;\nvar EffectColorMatrixMethod_1 = require(\"awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod\");\nexports.EffectColorMatrixMethod = EffectColorMatrixMethod_1.default;\nvar EffectColorTransformMethod_1 = require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nexports.EffectColorTransformMethod = EffectColorTransformMethod_1.default;\nvar EffectEnvMapMethod_1 = require(\"awayjs-methodmaterials/lib/methods/EffectEnvMapMethod\");\nexports.EffectEnvMapMethod = EffectEnvMapMethod_1.default;\nvar EffectFogMethod_1 = require(\"awayjs-methodmaterials/lib/methods/EffectFogMethod\");\nexports.EffectFogMethod = EffectFogMethod_1.default;\nvar EffectFresnelEnvMapMethod_1 = require(\"awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod\");\nexports.EffectFresnelEnvMapMethod = EffectFresnelEnvMapMethod_1.default;\nvar EffectLightMapMethod_1 = require(\"awayjs-methodmaterials/lib/methods/EffectLightMapMethod\");\nexports.EffectLightMapMethod = EffectLightMapMethod_1.default;\nvar EffectMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nexports.EffectMethodBase = EffectMethodBase_1.default;\nvar EffectRefractionEnvMapMethod_1 = require(\"awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod\");\nexports.EffectRefractionEnvMapMethod = EffectRefractionEnvMapMethod_1.default;\nvar EffectRimLightMethod_1 = require(\"awayjs-methodmaterials/lib/methods/EffectRimLightMethod\");\nexports.EffectRimLightMethod = EffectRimLightMethod_1.default;\nvar LightingMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nexports.LightingMethodBase = LightingMethodBase_1.default;\nvar NormalBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nexports.NormalBasicMethod = NormalBasicMethod_1.default;\nvar NormalHeightMapMethod_1 = require(\"awayjs-methodmaterials/lib/methods/NormalHeightMapMethod\");\nexports.NormalHeightMapMethod = NormalHeightMapMethod_1.default;\nvar NormalSimpleWaterMethod_1 = require(\"awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod\");\nexports.NormalSimpleWaterMethod = NormalSimpleWaterMethod_1.default;\nvar ShadingMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\nexports.ShadingMethodBase = ShadingMethodBase_1.default;\nvar ShadowCascadeMethod_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowCascadeMethod\");\nexports.ShadowCascadeMethod = ShadowCascadeMethod_1.default;\nvar ShadowDitheredMethod_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowDitheredMethod\");\nexports.ShadowDitheredMethod = ShadowDitheredMethod_1.default;\nvar ShadowFilteredMethod_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowFilteredMethod\");\nexports.ShadowFilteredMethod = ShadowFilteredMethod_1.default;\nvar ShadowHardMethod_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowHardMethod\");\nexports.ShadowHardMethod = ShadowHardMethod_1.default;\nvar ShadowMapMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nexports.ShadowMapMethodBase = ShadowMapMethodBase_1.default;\nvar ShadowMethodBase_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\nexports.ShadowMethodBase = ShadowMethodBase_1.default;\nvar ShadowNearMethod_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowNearMethod\");\nexports.ShadowNearMethod = ShadowNearMethod_1.default;\nvar ShadowSoftMethod_1 = require(\"awayjs-methodmaterials/lib/methods/ShadowSoftMethod\");\nexports.ShadowSoftMethod = ShadowSoftMethod_1.default;\nvar SpecularAnisotropicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod\");\nexports.SpecularAnisotropicMethod = SpecularAnisotropicMethod_1.default;\nvar SpecularBasicMethod_1 = require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nexports.SpecularBasicMethod = SpecularBasicMethod_1.default;\nvar SpecularCelMethod_1 = require(\"awayjs-methodmaterials/lib/methods/SpecularCelMethod\");\nexports.SpecularCelMethod = SpecularCelMethod_1.default;\nvar SpecularCompositeMethod_1 = require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\nexports.SpecularCompositeMethod = SpecularCompositeMethod_1.default;\nvar SpecularFresnelMethod_1 = require(\"awayjs-methodmaterials/lib/methods/SpecularFresnelMethod\");\nexports.SpecularFresnelMethod = SpecularFresnelMethod_1.default;\nvar SpecularPhongMethod_1 = require(\"awayjs-methodmaterials/lib/methods/SpecularPhongMethod\");\nexports.SpecularPhongMethod = SpecularPhongMethod_1.default;\n\n},{\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\":\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\",\"awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod\":\"awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod\",\"awayjs-methodmaterials/lib/methods/CurveBasicMethod\":\"awayjs-methodmaterials/lib/methods/CurveBasicMethod\",\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\",\"awayjs-methodmaterials/lib/methods/DiffuseCelMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCelMethod\",\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\",\"awayjs-methodmaterials/lib/methods/DiffuseDepthMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseDepthMethod\",\"awayjs-methodmaterials/lib/methods/DiffuseGradientMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseGradientMethod\",\"awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod\",\"awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod\",\"awayjs-methodmaterials/lib/methods/DiffuseWrapMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseWrapMethod\",\"awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod\":\"awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod\",\"awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod\":\"awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod\",\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\":\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\",\"awayjs-methodmaterials/lib/methods/EffectEnvMapMethod\":\"awayjs-methodmaterials/lib/methods/EffectEnvMapMethod\",\"awayjs-methodmaterials/lib/methods/EffectFogMethod\":\"awayjs-methodmaterials/lib/methods/EffectFogMethod\",\"awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod\":\"awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod\",\"awayjs-methodmaterials/lib/methods/EffectLightMapMethod\":\"awayjs-methodmaterials/lib/methods/EffectLightMapMethod\",\"awayjs-methodmaterials/lib/methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\",\"awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod\":\"awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod\",\"awayjs-methodmaterials/lib/methods/EffectRimLightMethod\":\"awayjs-methodmaterials/lib/methods/EffectRimLightMethod\",\"awayjs-methodmaterials/lib/methods/LightingMethodBase\":\"awayjs-methodmaterials/lib/methods/LightingMethodBase\",\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\":\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\",\"awayjs-methodmaterials/lib/methods/NormalHeightMapMethod\":\"awayjs-methodmaterials/lib/methods/NormalHeightMapMethod\",\"awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod\":\"awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod\",\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\",\"awayjs-methodmaterials/lib/methods/ShadowCascadeMethod\":\"awayjs-methodmaterials/lib/methods/ShadowCascadeMethod\",\"awayjs-methodmaterials/lib/methods/ShadowDitheredMethod\":\"awayjs-methodmaterials/lib/methods/ShadowDitheredMethod\",\"awayjs-methodmaterials/lib/methods/ShadowFilteredMethod\":\"awayjs-methodmaterials/lib/methods/ShadowFilteredMethod\",\"awayjs-methodmaterials/lib/methods/ShadowHardMethod\":\"awayjs-methodmaterials/lib/methods/ShadowHardMethod\",\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\",\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\",\"awayjs-methodmaterials/lib/methods/ShadowNearMethod\":\"awayjs-methodmaterials/lib/methods/ShadowNearMethod\",\"awayjs-methodmaterials/lib/methods/ShadowSoftMethod\":\"awayjs-methodmaterials/lib/methods/ShadowSoftMethod\",\"awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod\",\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\",\"awayjs-methodmaterials/lib/methods/SpecularCelMethod\":\"awayjs-methodmaterials/lib/methods/SpecularCelMethod\",\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\":\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\",\"awayjs-methodmaterials/lib/methods/SpecularFresnelMethod\":\"awayjs-methodmaterials/lib/methods/SpecularFresnelMethod\",\"awayjs-methodmaterials/lib/methods/SpecularPhongMethod\":\"awayjs-methodmaterials/lib/methods/SpecularPhongMethod\"}],\"awayjs-methodmaterials/lib/surfaces/GL_MethodMaterialSurface\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar BlendMode_1 = require(\"awayjs-core/lib/image/BlendMode\");\nvar StaticLightPicker_1 = require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\nvar ContextGLCompareMode_1 = require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\nvar GL_SurfaceBase_1 = require(\"awayjs-renderergl/lib/surfaces/GL_SurfaceBase\");\nvar MethodMaterialMode_1 = require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\nvar MethodPassMode_1 = require(\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\");\nvar MethodPass_1 = require(\"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\");\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nvar GL_MethodMaterialSurface = (function (_super) {\n    __extends(GL_MethodMaterialSurface, _super);\n    /**\n     * Creates a new CompiledPass object.\n     *\n     * @param material The material to which this pass belongs.\n     */\n    function GL_MethodMaterialSurface(material, elementsClass, pool) {\n        _super.call(this, material, elementsClass, pool);\n        this._material = material;\n    }\n    Object.defineProperty(GL_MethodMaterialSurface.prototype, \"numLights\", {\n        /**\n         * The maximum total number of lights provided by the light picker.\n         */\n        get: function () {\n            return this._material.lightPicker ? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights + this._material.lightPicker.numCastingDirectionalLights + this._material.lightPicker.numCastingPointLights : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GL_MethodMaterialSurface.prototype, \"numNonCasters\", {\n        /**\n         * The amount of lights that don't cast shadows.\n         */\n        get: function () {\n            return this._material.lightPicker ? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    GL_MethodMaterialSurface.prototype._pUpdateRender = function () {\n        _super.prototype._pUpdateRender.call(this);\n        this.initPasses();\n        this.setBlendAndCompareModes();\n        this._pClearPasses();\n        if (this._material.mode == MethodMaterialMode_1.default.MULTI_PASS) {\n            if (this._casterLightPass)\n                this._pAddPass(this._casterLightPass);\n            if (this._nonCasterLightPasses)\n                for (var i = 0; i < this._nonCasterLightPasses.length; ++i)\n                    this._pAddPass(this._nonCasterLightPasses[i]);\n        }\n        if (this._pass)\n            this._pAddPass(this._pass);\n    };\n    /**\n     * Initializes all the passes and their dependent passes.\n     */\n    GL_MethodMaterialSurface.prototype.initPasses = function () {\n        // let the effects pass handle everything if there are no lights, when there are effect methods applied\n        // after shading, or when the material mode is single pass.\n        if (this.numLights == 0 || this._material.numEffectMethods > 0 || this._material.mode == MethodMaterialMode_1.default.SINGLE_PASS)\n            this.initEffectPass();\n        else if (this._pass)\n            this.removeEffectPass();\n        // only use a caster light pass if shadows need to be rendered\n        if (this._material.shadowMethod && this._material.mode == MethodMaterialMode_1.default.MULTI_PASS)\n            this.initCasterLightPass();\n        else if (this._casterLightPass)\n            this.removeCasterLightPass();\n        // only use non caster light passes if there are lights that don't cast\n        if (this.numNonCasters > 0 && this._material.mode == MethodMaterialMode_1.default.MULTI_PASS)\n            this.initNonCasterLightPasses();\n        else if (this._nonCasterLightPasses)\n            this.removeNonCasterLightPasses();\n    };\n    /**\n     * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.\n     */\n    GL_MethodMaterialSurface.prototype.setBlendAndCompareModes = function () {\n        var forceSeparateMVP = Boolean(this._casterLightPass || this._pass);\n        // caster light pass is always first if it exists, hence it uses normal blending\n        if (this._casterLightPass) {\n            this._casterLightPass.forceSeparateMVP = forceSeparateMVP;\n            this._casterLightPass.shader.setBlendMode(BlendMode_1.default.NORMAL);\n            this._casterLightPass.shader.depthCompareMode = this._material.depthCompareMode;\n        }\n        if (this._nonCasterLightPasses) {\n            var firstAdditiveIndex = 0;\n            // if there's no caster light pass, the first non caster light pass will be the first\n            // and should use normal blending\n            if (!this._casterLightPass) {\n                this._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;\n                this._nonCasterLightPasses[0].shader.setBlendMode(BlendMode_1.default.NORMAL);\n                this._nonCasterLightPasses[0].shader.depthCompareMode = this._material.depthCompareMode;\n                firstAdditiveIndex = 1;\n            }\n            // all lighting passes following the first light pass should use additive blending\n            for (var i = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {\n                this._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;\n                this._nonCasterLightPasses[i].shader.setBlendMode(BlendMode_1.default.ADD);\n                this._nonCasterLightPasses[i].shader.depthCompareMode = ContextGLCompareMode_1.default.LESS_EQUAL;\n            }\n        }\n        if (this._casterLightPass || this._nonCasterLightPasses) {\n            //cannot be blended by blendmode property if multipass enabled\n            this._pRequiresBlending = false;\n            // there are light passes, so this should be blended in\n            if (this._pass) {\n                this._pass.mode = MethodPassMode_1.default.EFFECTS;\n                this._pass.forceSeparateMVP = forceSeparateMVP;\n                this._pass.shader.depthCompareMode = ContextGLCompareMode_1.default.LESS_EQUAL;\n                this._pass.shader.setBlendMode(BlendMode_1.default.LAYER);\n            }\n        }\n        else if (this._pass) {\n            this._pRequiresBlending = (this._material.blendMode != BlendMode_1.default.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));\n            // effects pass is the only pass, so it should just blend normally\n            this._pass.mode = MethodPassMode_1.default.SUPER_SHADER;\n            this._pass.preserveAlpha = this._pRequiresBlending;\n            this._pass.forceSeparateMVP = false;\n            this._pass.colorTransform = this._material.colorTransform;\n            this._pass.shader.setBlendMode((this._material.blendMode == BlendMode_1.default.NORMAL && this._pRequiresBlending) ? BlendMode_1.default.LAYER : this._material.blendMode);\n            this._pass.shader.depthCompareMode = this._material.depthCompareMode;\n        }\n    };\n    GL_MethodMaterialSurface.prototype.initCasterLightPass = function () {\n        if (this._casterLightPass == null)\n            this._casterLightPass = new MethodPass_1.default(MethodPassMode_1.default.LIGHTING, this, this._material, this._elementsClass, this._stage);\n        this._casterLightPass.lightPicker = new StaticLightPicker_1.default([this._material.shadowMethod.castingLight]);\n        this._casterLightPass.shadowMethod = this._material.shadowMethod;\n        this._casterLightPass.diffuseMethod = this._material.diffuseMethod;\n        this._casterLightPass.ambientMethod = this._material.ambientMethod;\n        this._casterLightPass.normalMethod = this._material.normalMethod;\n        this._casterLightPass.specularMethod = this._material.specularMethod;\n    };\n    GL_MethodMaterialSurface.prototype.removeCasterLightPass = function () {\n        this._casterLightPass.dispose();\n        this._pRemovePass(this._casterLightPass);\n        this._casterLightPass = null;\n    };\n    GL_MethodMaterialSurface.prototype.initNonCasterLightPasses = function () {\n        this.removeNonCasterLightPasses();\n        var pass;\n        var numDirLights = this._material.lightPicker.numDirectionalLights;\n        var numPointLights = this._material.lightPicker.numPointLights;\n        var numLightProbes = this._material.lightPicker.numLightProbes;\n        var dirLightOffset = 0;\n        var pointLightOffset = 0;\n        var probeOffset = 0;\n        if (!this._casterLightPass) {\n            numDirLights += this._material.lightPicker.numCastingDirectionalLights;\n            numPointLights += this._material.lightPicker.numCastingPointLights;\n        }\n        this._nonCasterLightPasses = new Array();\n        while (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {\n            pass = new MethodPass_1.default(MethodPassMode_1.default.LIGHTING, this, this._material, this._elementsClass, this._stage);\n            pass.includeCasters = this._material.shadowMethod == null;\n            pass.directionalLightsOffset = dirLightOffset;\n            pass.pointLightsOffset = pointLightOffset;\n            pass.lightProbesOffset = probeOffset;\n            pass.lightPicker = this._material.lightPicker;\n            pass.diffuseMethod = this._material.diffuseMethod;\n            pass.ambientMethod = this._material.ambientMethod;\n            pass.normalMethod = this._material.normalMethod;\n            pass.specularMethod = this._material.specularMethod;\n            this._nonCasterLightPasses.push(pass);\n            dirLightOffset += pass.numDirectionalLights;\n            pointLightOffset += pass.numPointLights;\n            probeOffset += pass.numLightProbes;\n        }\n    };\n    GL_MethodMaterialSurface.prototype.removeNonCasterLightPasses = function () {\n        if (!this._nonCasterLightPasses)\n            return;\n        for (var i = 0; i < this._nonCasterLightPasses.length; ++i)\n            this._pRemovePass(this._nonCasterLightPasses[i]);\n        this._nonCasterLightPasses = null;\n    };\n    GL_MethodMaterialSurface.prototype.removeEffectPass = function () {\n        if (this._pass.ambientMethod != this._material.ambientMethod)\n            this._pass.ambientMethod.dispose();\n        if (this._pass.diffuseMethod != this._material.diffuseMethod)\n            this._pass.diffuseMethod.dispose();\n        if (this._pass.specularMethod != this._material.specularMethod)\n            this._pass.specularMethod.dispose();\n        if (this._pass.normalMethod != this._material.normalMethod)\n            this._pass.normalMethod.dispose();\n        this._pRemovePass(this._pass);\n        this._pass = null;\n    };\n    GL_MethodMaterialSurface.prototype.initEffectPass = function () {\n        if (this._pass == null)\n            this._pass = new MethodPass_1.default(MethodPassMode_1.default.SUPER_SHADER, this, this._material, this._elementsClass, this._stage);\n        if (this._material.mode == MethodMaterialMode_1.default.SINGLE_PASS) {\n            this._pass.ambientMethod = this._material.ambientMethod;\n            this._pass.diffuseMethod = this._material.diffuseMethod;\n            this._pass.specularMethod = this._material.specularMethod;\n            this._pass.normalMethod = this._material.normalMethod;\n            this._pass.shadowMethod = this._material.shadowMethod;\n        }\n        else if (this._material.mode == MethodMaterialMode_1.default.MULTI_PASS) {\n            if (this.numLights == 0) {\n                this._pass.ambientMethod = this._material.ambientMethod;\n            }\n            else {\n                this._pass.ambientMethod = null;\n            }\n            this._pass.preserveAlpha = false;\n            this._pass.normalMethod = this._material.normalMethod;\n        }\n        //update effect methods\n        var i = 0;\n        var effectMethod;\n        var len = Math.max(this._material.numEffectMethods, this._pass.numEffectMethods);\n        while (i < len) {\n            effectMethod = this._material.getEffectMethodAt(i);\n            if (effectMethod != this._pass.getEffectMethodAt(i)) {\n                this._pass.removeEffectMethodAt(i);\n                if (effectMethod != null) {\n                    if (i < this._pass.numEffectMethods)\n                        this._pass.addEffectMethodAt(effectMethod, i);\n                    else\n                        this._pass.addEffectMethod(effectMethod);\n                }\n            }\n            i++;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    GL_MethodMaterialSurface.prototype.onClear = function (event) {\n        _super.prototype.onClear.call(this, event);\n        //TODO\n    };\n    return GL_MethodMaterialSurface;\n}(GL_SurfaceBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = GL_MethodMaterialSurface;\n\n},{\"awayjs-core/lib/image/BlendMode\":undefined,\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\":undefined,\"awayjs-methodmaterials/lib/MethodMaterialMode\":\"awayjs-methodmaterials/lib/MethodMaterialMode\",\"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\",\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\",\"awayjs-renderergl/lib/surfaces/GL_SurfaceBase\":undefined,\"awayjs-stagegl/lib/base/ContextGLCompareMode\":undefined}],\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\":[function(require,module,exports){\n\"use strict\";\nvar PassMode = (function () {\n    function PassMode() {\n    }\n    /**\n     *\n     */\n    PassMode.EFFECTS = 0x01;\n    /**\n     *\n     */\n    PassMode.LIGHTING = 0x02;\n    /**\n     *\n     */\n    PassMode.SUPER_SHADER = 0x03;\n    return PassMode;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = PassMode;\n\n},{}],\"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar LightSources_1 = require(\"awayjs-display/lib/materials/LightSources\");\nvar LightingShader_1 = require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar ShaderBase_1 = require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nvar PassBase_1 = require(\"awayjs-renderergl/lib/surfaces/passes/PassBase\");\nvar MethodVO_1 = require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nvar EffectColorTransformMethod_1 = require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nvar MethodPassMode_1 = require(\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\");\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nvar MethodPass = (function (_super) {\n    __extends(MethodPass, _super);\n    /**\n     * Creates a new CompiledPass object.\n     *\n     * @param material The material to which this pass belongs.\n     */\n    function MethodPass(mode, render, renderOwner, elementsClass, stage) {\n        var _this = this;\n        _super.call(this, render, renderOwner, elementsClass, stage);\n        this._maxLights = 3;\n        this._mode = 0x03;\n        this._includeCasters = true;\n        this._iMethodVOs = new Array();\n        this._numEffectDependencies = 0;\n        this.numDirectionalLights = 0;\n        this.numPointLights = 0;\n        this.numLightProbes = 0;\n        this.pointLightsOffset = 0;\n        this.directionalLightsOffset = 0;\n        this.lightProbesOffset = 0;\n        this._mode = mode;\n        this._material = renderOwner;\n        this._onLightsChangeDelegate = function (event) { return _this.onLightsChange(event); };\n        this._onMethodInvalidatedDelegate = function (event) { return _this.onMethodInvalidated(event); };\n        this.lightPicker = renderOwner.lightPicker;\n        if (this._shader == null)\n            this._updateShader();\n    }\n    Object.defineProperty(MethodPass.prototype, \"mode\", {\n        /**\n         *\n         */\n        get: function () {\n            return this._mode;\n        },\n        set: function (value) {\n            if (this._mode == value)\n                return;\n            this._mode = value;\n            this._updateLights();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"includeCasters\", {\n        /**\n         * Indicates whether or not shadow casting lights need to be included.\n         */\n        get: function () {\n            return this._includeCasters;\n        },\n        set: function (value) {\n            if (this._includeCasters == value)\n                return;\n            this._includeCasters = value;\n            this._updateLights();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"lightPicker\", {\n        /**\n         *\n         * @returns {LightPickerBase}\n         */\n        get: function () {\n            return this._lightPicker;\n        },\n        set: function (value) {\n            //if (this._lightPicker == value)\n            //\treturn;\n            if (this._lightPicker)\n                this._lightPicker.removeEventListener(AssetEvent_1.default.INVALIDATE, this._onLightsChangeDelegate);\n            this._lightPicker = value;\n            if (this._lightPicker)\n                this._lightPicker.addEventListener(AssetEvent_1.default.INVALIDATE, this._onLightsChangeDelegate);\n            this._updateLights();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"enableLightFallOff\", {\n        /**\n         * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and\n         * compatibility for constrained mode.\n         */\n        get: function () {\n            return this._material.enableLightFallOff;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"diffuseLightSources\", {\n        /**\n         * Define which light source types to use for diffuse reflections. This allows choosing between regular lights\n         * and/or light probes for diffuse reflections.\n         *\n         * @see away3d.materials.LightSources\n         */\n        get: function () {\n            return this._material.diffuseLightSources;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"specularLightSources\", {\n        /**\n         * Define which light source types to use for specular reflections. This allows choosing between regular lights\n         * and/or light probes for specular reflections.\n         *\n         * @see away3d.materials.LightSources\n         */\n        get: function () {\n            return this._material.specularLightSources;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MethodPass.prototype._updateShader = function () {\n        if ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof LightingShader_1.default)) {\n            if (this._shader != null)\n                this._shader.dispose();\n            this._shader = new LightingShader_1.default(this._elementsClass, this, this._stage);\n        }\n        else if (!(this._shader instanceof ShaderBase_1.default)) {\n            if (this._shader != null)\n                this._shader.dispose();\n            this._shader = new ShaderBase_1.default(this._elementsClass, this, this._stage);\n        }\n    };\n    /**\n     * Initializes the unchanging constant data for this material.\n     */\n    MethodPass.prototype._iInitConstantData = function (shader) {\n        _super.prototype._iInitConstantData.call(this, shader);\n        //Updates method constants if they have changed.\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i)\n            this._iMethodVOs[i].method.iInitConstants(shader, this._iMethodVOs[i]);\n    };\n    Object.defineProperty(MethodPass.prototype, \"colorTransform\", {\n        /**\n         * The ColorTransform object to transform the colour of the material with. Defaults to null.\n         */\n        get: function () {\n            return this.colorTransformMethod ? this.colorTransformMethod.colorTransform : null;\n        },\n        set: function (value) {\n            if (value) {\n                if (this.colorTransformMethod == null)\n                    this.colorTransformMethod = new EffectColorTransformMethod_1.default();\n                this.colorTransformMethod.colorTransform = value;\n            }\n            else if (!value) {\n                if (this.colorTransformMethod)\n                    this.colorTransformMethod = null;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"colorTransformMethod\", {\n        /**\n         * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.\n         */\n        get: function () {\n            return this._iColorTransformMethodVO ? this._iColorTransformMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)\n                return;\n            if (this._iColorTransformMethodVO) {\n                this._removeDependency(this._iColorTransformMethodVO);\n                this._iColorTransformMethodVO = null;\n            }\n            if (value) {\n                this._iColorTransformMethodVO = new MethodVO_1.default(value, this);\n                this._addDependency(this._iColorTransformMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MethodPass.prototype._removeDependency = function (methodVO, effectsDependency) {\n        if (effectsDependency === void 0) { effectsDependency = false; }\n        var index = this._iMethodVOs.indexOf(methodVO);\n        if (!effectsDependency)\n            this._numEffectDependencies--;\n        methodVO.method.removeEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n        this._iMethodVOs.splice(index, 1);\n        this.invalidate();\n    };\n    MethodPass.prototype._addDependency = function (methodVO, effectsDependency, index) {\n        if (effectsDependency === void 0) { effectsDependency = false; }\n        if (index === void 0) { index = -1; }\n        methodVO.method.addEventListener(ShadingMethodEvent_1.default.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n        if (effectsDependency) {\n            if (index != -1)\n                this._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n            else\n                this._iMethodVOs.push(methodVO);\n            this._numEffectDependencies++;\n        }\n        else {\n            this._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n        }\n        this.invalidate();\n    };\n    /**\n     * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n     * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n     * methods added prior.\n     */\n    MethodPass.prototype.addEffectMethod = function (method) {\n        this._addDependency(new MethodVO_1.default(method, this), true);\n    };\n    Object.defineProperty(MethodPass.prototype, \"numEffectMethods\", {\n        /**\n         * The number of \"effect\" methods added to the material.\n         */\n        get: function () {\n            return this._numEffectDependencies;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Queries whether a given effects method was added to the material.\n     *\n     * @param method The method to be queried.\n     * @return true if the method was added to the material, false otherwise.\n     */\n    MethodPass.prototype.hasEffectMethod = function (method) {\n        return this.getDependencyForMethod(method) != null;\n    };\n    /**\n     * Returns the method added at the given index.\n     * @param index The index of the method to retrieve.\n     * @return The method at the given index.\n     */\n    MethodPass.prototype.getEffectMethodAt = function (index) {\n        if (index < 0 || index > this._numEffectDependencies - 1)\n            return null;\n        return this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;\n    };\n    /**\n     * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n     * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n     * etc. The method will be applied to the result of the methods with a lower index.\n     */\n    MethodPass.prototype.addEffectMethodAt = function (method, index) {\n        this._addDependency(new MethodVO_1.default(method, this), true, index);\n    };\n    /**\n     * Removes an effect method from the material.\n     * @param method The method to be removed.\n     */\n    MethodPass.prototype.removeEffectMethod = function (method) {\n        var methodVO = this.getDependencyForMethod(method);\n        if (methodVO != null)\n            this._removeDependency(methodVO, true);\n    };\n    /**\n     * remove an effect method at the specified index from the material.\n     */\n    MethodPass.prototype.removeEffectMethodAt = function (index) {\n        if (index < 0 || index > this._numEffectDependencies - 1)\n            return;\n        var methodVO = this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies];\n        if (methodVO != null)\n            this._removeDependency(methodVO, true);\n    };\n    MethodPass.prototype.getDependencyForMethod = function (method) {\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i)\n            if (this._iMethodVOs[i].method == method)\n                return this._iMethodVOs[i];\n        return null;\n    };\n    Object.defineProperty(MethodPass.prototype, \"normalMethod\", {\n        /**\n         * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n         */\n        get: function () {\n            return this._iNormalMethodVO ? this._iNormalMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iNormalMethodVO && this._iNormalMethodVO.method == value)\n                return;\n            if (this._iNormalMethodVO) {\n                this._removeDependency(this._iNormalMethodVO);\n                this._iNormalMethodVO = null;\n            }\n            if (value) {\n                this._iNormalMethodVO = new MethodVO_1.default(value, this);\n                this._addDependency(this._iNormalMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"ambientMethod\", {\n        /**\n         * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n         */\n        get: function () {\n            return this._iAmbientMethodVO ? this._iAmbientMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)\n                return;\n            if (this._iAmbientMethodVO) {\n                this._removeDependency(this._iAmbientMethodVO);\n                this._iAmbientMethodVO = null;\n            }\n            if (value) {\n                this._iAmbientMethodVO = new MethodVO_1.default(value, this);\n                this._addDependency(this._iAmbientMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"shadowMethod\", {\n        /**\n         * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n         */\n        get: function () {\n            return this._iShadowMethodVO ? this._iShadowMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iShadowMethodVO && this._iShadowMethodVO.method == value)\n                return;\n            if (this._iShadowMethodVO) {\n                this._removeDependency(this._iShadowMethodVO);\n                this._iShadowMethodVO = null;\n            }\n            if (value) {\n                this._iShadowMethodVO = new MethodVO_1.default(value, this);\n                this._addDependency(this._iShadowMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"diffuseMethod\", {\n        /**\n         * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n         */\n        get: function () {\n            return this._iDiffuseMethodVO ? this._iDiffuseMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)\n                return;\n            if (this._iDiffuseMethodVO) {\n                this._removeDependency(this._iDiffuseMethodVO);\n                this._iDiffuseMethodVO = null;\n            }\n            if (value) {\n                this._iDiffuseMethodVO = new MethodVO_1.default(value, this);\n                this._addDependency(this._iDiffuseMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"specularMethod\", {\n        /**\n         * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n         */\n        get: function () {\n            return this._iSpecularMethodVO ? this._iSpecularMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)\n                return;\n            if (this._iSpecularMethodVO) {\n                this._removeDependency(this._iSpecularMethodVO);\n                this._iSpecularMethodVO = null;\n            }\n            if (value) {\n                this._iSpecularMethodVO = new MethodVO_1.default(value, this);\n                this._addDependency(this._iSpecularMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype.dispose = function () {\n        if (this._lightPicker)\n            this._lightPicker.removeEventListener(AssetEvent_1.default.INVALIDATE, this._onLightsChangeDelegate);\n        while (this._iMethodVOs.length)\n            this._removeDependency(this._iMethodVOs[0]);\n        _super.prototype.dispose.call(this);\n        this._iMethodVOs = null;\n    };\n    /**\n     * Called when any method's shader code is invalidated.\n     */\n    MethodPass.prototype.onMethodInvalidated = function (event) {\n        this.invalidate();\n    };\n    // RENDER LOOP\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype._iActivate = function (camera) {\n        _super.prototype._iActivate.call(this, camera);\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod)\n                methodVO.method.iActivate(this._shader, methodVO, this._stage);\n        }\n    };\n    /**\n     *\n     *\n     * @param renderable\n     * @param stage\n     * @param camera\n     */\n    MethodPass.prototype._iRender = function (renderable, camera, viewProjection) {\n        _super.prototype._iRender.call(this, renderable, camera, viewProjection);\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod)\n                methodVO.method.iSetRenderState(this._shader, methodVO, renderable, this._stage, camera);\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype._iDeactivate = function () {\n        _super.prototype._iDeactivate.call(this);\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod)\n                methodVO.method.iDeactivate(this._shader, methodVO, this._stage);\n        }\n    };\n    MethodPass.prototype._iIncludeDependencies = function (shader) {\n        _super.prototype._iIncludeDependencies.call(this, shader);\n        //TODO: fragment animtion should be compatible with lighting pass\n        shader.usesFragmentAnimation = Boolean(this._mode == MethodPassMode_1.default.SUPER_SHADER);\n        if (shader.useAlphaPremultiplied && shader.usesBlending)\n            shader.usesCommonData = true;\n        var i;\n        var len = this._iMethodVOs.length;\n        for (i = 0; i < len; ++i)\n            this.setupAndCountDependencies(shader, this._iMethodVOs[i]);\n        var usesTangentSpace = true;\n        var methodVO;\n        for (i = 0; i < len; ++i) {\n            methodVO = this._iMethodVOs[i];\n            if ((methodVO.useMethod = methodVO.method.iIsUsed(shader)) && !methodVO.method.iUsesTangentSpace())\n                usesTangentSpace = false;\n        }\n        shader.outputsNormals = this._iNormalMethodVO && this._iNormalMethodVO.useMethod;\n        shader.outputsTangentNormals = shader.outputsNormals && this._iNormalMethodVO.method.iOutputsTangentNormals();\n        shader.usesTangentSpace = shader.outputsTangentNormals && !shader.usesProbes && usesTangentSpace;\n        if (!shader.usesTangentSpace) {\n            if (shader.viewDirDependencies > 0) {\n                shader.globalPosDependencies++;\n            }\n            else if (this.numPointLights > 0 && shader.usesLights) {\n                shader.globalPosDependencies++;\n                if (Boolean(this._mode & MethodPassMode_1.default.EFFECTS))\n                    shader.usesGlobalPosFragment = true;\n            }\n        }\n    };\n    /**\n     * Counts the dependencies for a given method.\n     * @param method The method to count the dependencies for.\n     * @param methodVO The method's data for this material.\n     */\n    MethodPass.prototype.setupAndCountDependencies = function (shader, methodVO) {\n        methodVO.reset();\n        methodVO.method.iInitVO(shader, methodVO);\n        if (methodVO.needsProjection)\n            shader.projectionDependencies++;\n        if (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos) {\n            shader.globalPosDependencies++;\n            if (methodVO.needsGlobalFragmentPos)\n                shader.usesGlobalPosFragment = true;\n        }\n        if (methodVO.needsNormals)\n            shader.normalDependencies++;\n        if (methodVO.needsTangents)\n            shader.tangentDependencies++;\n        if (methodVO.needsView)\n            shader.viewDirDependencies++;\n    };\n    MethodPass.prototype._iGetPreLightingVertexCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)\n            code += this._iAmbientMethodVO.method.iGetVertexCode(shader, this._iAmbientMethodVO, registerCache, sharedRegisters);\n        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n            code += this._iDiffuseMethodVO.method.iGetVertexCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n            code += this._iSpecularMethodVO.method.iGetVertexCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n        return code;\n    };\n    MethodPass.prototype._iGetPreLightingFragmentCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {\n            code += this._iAmbientMethodVO.method.iGetFragmentCode(shader, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n            if (this._iAmbientMethodVO.needsNormals)\n                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n            if (this._iAmbientMethodVO.needsView)\n                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n        }\n        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n            code += this._iDiffuseMethodVO.method.iGetFragmentPreLightingCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n            code += this._iSpecularMethodVO.method.iGetFragmentPreLightingCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n        return code;\n    };\n    MethodPass.prototype._iGetPerLightDiffuseFragmentCode = function (shader, lightDirReg, diffuseColorReg, registerCache, sharedRegisters) {\n        return this._iDiffuseMethodVO.method.iGetFragmentCodePerLight(shader, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetPerLightSpecularFragmentCode = function (shader, lightDirReg, specularColorReg, registerCache, sharedRegisters) {\n        return this._iSpecularMethodVO.method.iGetFragmentCodePerLight(shader, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetPerProbeDiffuseFragmentCode = function (shader, texReg, weightReg, registerCache, sharedRegisters) {\n        return this._iDiffuseMethodVO.method.iGetFragmentCodePerProbe(shader, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetPerProbeSpecularFragmentCode = function (shader, texReg, weightReg, registerCache, sharedRegisters) {\n        return this._iSpecularMethodVO.method.iGetFragmentCodePerProbe(shader, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetPostLightingVertexCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (this._iShadowMethodVO)\n            code += this._iShadowMethodVO.method.iGetVertexCode(shader, this._iShadowMethodVO, registerCache, sharedRegisters);\n        return code;\n    };\n    MethodPass.prototype._iGetPostLightingFragmentCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (shader.useAlphaPremultiplied && shader.usesBlending) {\n            code += \"add \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n                \"div \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \", \" + sharedRegisters.shadedTarget + \".w\\n\" +\n                \"sub \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n                \"sat \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \"\\n\";\n        }\n        if (this._iShadowMethodVO)\n            code += this._iShadowMethodVO.method.iGetFragmentCode(shader, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);\n        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {\n            code += this._iDiffuseMethodVO.method.iGetFragmentPostLightingCode(shader, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n            // resolve other dependencies as well?\n            if (this._iDiffuseMethodVO.needsNormals)\n                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n            if (this._iDiffuseMethodVO.needsView)\n                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n        }\n        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {\n            code += this._iSpecularMethodVO.method.iGetFragmentPostLightingCode(shader, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n            if (this._iSpecularMethodVO.needsNormals)\n                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n            if (this._iSpecularMethodVO.needsView)\n                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n        }\n        if (this._iShadowMethodVO)\n            registerCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);\n        return code;\n    };\n    MethodPass.prototype._iGetNormalVertexCode = function (shader, registerCache, sharedRegisters) {\n        return this._iNormalMethodVO.method.iGetVertexCode(shader, this._iNormalMethodVO, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetNormalFragmentCode = function (shader, registerCache, sharedRegisters) {\n        var code = this._iNormalMethodVO.method.iGetFragmentCode(shader, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);\n        if (this._iNormalMethodVO.needsView)\n            registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n        if (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)\n            registerCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype._iGetVertexCode = function (shader, regCache, sharedReg) {\n        var code = \"\";\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = len - this._numEffectDependencies; i < len; i++) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod) {\n                code += methodVO.method.iGetVertexCode(shader, methodVO, regCache, sharedReg);\n                if (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)\n                    regCache.removeVertexTempUsage(sharedReg.globalPositionVertex);\n            }\n        }\n        if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n            code += this._iColorTransformMethodVO.method.iGetVertexCode(shader, this._iColorTransformMethodVO, regCache, sharedReg);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype._iGetFragmentCode = function (shader, regCache, sharedReg) {\n        var code = \"\";\n        var alphaReg;\n        if (this.preserveAlpha && this._numEffectDependencies > 0) {\n            alphaReg = regCache.getFreeFragmentSingleTemp();\n            regCache.addFragmentTempUsages(alphaReg, 1);\n            code += \"mov \" + alphaReg + \", \" + sharedReg.shadedTarget + \".w\\n\";\n        }\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = len - this._numEffectDependencies; i < len; i++) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod) {\n                code += methodVO.method.iGetFragmentCode(shader, methodVO, sharedReg.shadedTarget, regCache, sharedReg);\n                if (methodVO.needsNormals)\n                    regCache.removeFragmentTempUsage(sharedReg.normalFragment);\n                if (methodVO.needsView)\n                    regCache.removeFragmentTempUsage(sharedReg.viewDirFragment);\n            }\n        }\n        if (this.preserveAlpha && this._numEffectDependencies > 0) {\n            code += \"mov \" + sharedReg.shadedTarget + \".w, \" + alphaReg + \"\\n\";\n            regCache.removeFragmentTempUsage(alphaReg);\n        }\n        if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n            code += this._iColorTransformMethodVO.method.iGetFragmentCode(shader, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);\n        return code;\n    };\n    /**\n     * Indicates whether the shader uses any shadows.\n     */\n    MethodPass.prototype._iUsesShadows = function (shader) {\n        return Boolean(this._iShadowMethodVO && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));\n    };\n    /**\n     * Indicates whether the shader uses any specular component.\n     */\n    MethodPass.prototype._iUsesSpecular = function (shader) {\n        return Boolean(this._iSpecularMethodVO);\n    };\n    /**\n     * Indicates whether the shader uses any specular component.\n     */\n    MethodPass.prototype._iUsesDiffuse = function (shader) {\n        return Boolean(this._iDiffuseMethodVO);\n    };\n    MethodPass.prototype.onLightsChange = function (event) {\n        this._updateLights();\n    };\n    MethodPass.prototype._updateLights = function () {\n        var numDirectionalLightsOld = this.numDirectionalLights;\n        var numPointLightsOld = this.numPointLights;\n        var numLightProbesOld = this.numLightProbes;\n        if (this._lightPicker && (this._mode & MethodPassMode_1.default.LIGHTING)) {\n            this.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);\n            this.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);\n            this.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);\n            if (this._includeCasters) {\n                this.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;\n                this.numPointLights += this._lightPicker.numCastingPointLights;\n            }\n        }\n        else {\n            this.numDirectionalLights = 0;\n            this.numPointLights = 0;\n            this.numLightProbes = 0;\n        }\n        if (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {\n            this._updateShader();\n            this.invalidate();\n        }\n    };\n    /**\n     * Calculates the amount of directional lights this material will support.\n     * @param numDirectionalLights The maximum amount of directional lights to support.\n     * @return The amount of directional lights this material will support, bounded by the amount necessary.\n     */\n    MethodPass.prototype.calculateNumDirectionalLights = function (numDirectionalLights) {\n        return Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);\n    };\n    /**\n     * Calculates the amount of point lights this material will support.\n     * @param numDirectionalLights The maximum amount of point lights to support.\n     * @return The amount of point lights this material will support, bounded by the amount necessary.\n     */\n    MethodPass.prototype.calculateNumPointLights = function (numPointLights) {\n        var numFree = this._maxLights - this.numDirectionalLights;\n        return Math.min(numPointLights - this.pointLightsOffset, numFree);\n    };\n    /**\n     * Calculates the amount of light probes this material will support.\n     * @param numDirectionalLights The maximum amount of light probes to support.\n     * @return The amount of light probes this material will support, bounded by the amount necessary.\n     */\n    MethodPass.prototype.calculateNumProbes = function (numLightProbes) {\n        var numChannels = 0;\n        if ((this.specularLightSources & LightSources_1.default.PROBES) != 0)\n            ++numChannels;\n        if ((this.diffuseLightSources & LightSources_1.default.PROBES) != 0)\n            ++numChannels;\n        // 4 channels available\n        return Math.min(numLightProbes - this.lightProbesOffset, (4 / numChannels) | 0);\n    };\n    return MethodPass;\n}(PassBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = MethodPass;\n\n},{\"awayjs-core/lib/events/AssetEvent\":undefined,\"awayjs-display/lib/materials/LightSources\":undefined,\"awayjs-methodmaterials/lib/data/MethodVO\":\"awayjs-methodmaterials/lib/data/MethodVO\",\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\":\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\",\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\",\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined,\"awayjs-renderergl/lib/shaders/LightingShader\":undefined,\"awayjs-renderergl/lib/shaders/ShaderBase\":undefined,\"awayjs-renderergl/lib/surfaces/passes/PassBase\":undefined}],\"awayjs-methodmaterials/lib/surfaces/passes/SingleObjectDepthPass\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Image2D_1 = require(\"awayjs-core/lib/image/Image2D\");\nvar Matrix3D_1 = require(\"awayjs-core/lib/geom/Matrix3D\");\nvar Single2DTexture_1 = require(\"awayjs-display/lib/textures/Single2DTexture\");\nvar ContextGLDrawMode_1 = require(\"awayjs-stagegl/lib/base/ContextGLDrawMode\");\nvar ContextGLProgramType_1 = require(\"awayjs-stagegl/lib/base/ContextGLProgramType\");\nvar PassBase_1 = require(\"awayjs-renderergl/lib/surfaces/passes/PassBase\");\n/**\n * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point\n * of view from a light.\n */\nvar SingleObjectDepthPass = (function (_super) {\n    __extends(SingleObjectDepthPass, _super);\n    /**\n     * Creates a new SingleObjectDepthPass object.\n     */\n    function SingleObjectDepthPass(render, renderOwner, elementsClass, stage) {\n        _super.call(this, render, renderOwner, elementsClass, stage);\n        this._textureSize = 512;\n        this._polyOffset = new Float32Array([15, 0, 0, 0]);\n        this._projectionTexturesInvalid = true;\n        //this._pNumUsedStreams = 2;\n        //this._pNumUsedVertexConstants = 7;\n        //this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n        //\n        //this._pAnimatableAttributes = Array<string>(\"va0\", \"va1\";\n        //this._pAnimationTargetRegisters = Array<string>(\"vt0\", \"vt1\";\n    }\n    Object.defineProperty(SingleObjectDepthPass.prototype, \"textureSize\", {\n        /**\n         * The size of the depth map texture to render to.\n         */\n        get: function () {\n            return this._textureSize;\n        },\n        set: function (value) {\n            this._textureSize = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SingleObjectDepthPass.prototype, \"polyOffset\", {\n        /**\n         * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n         */\n        get: function () {\n            return this._polyOffset[0];\n        },\n        set: function (value) {\n            this._polyOffset[0] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype.dispose = function () {\n        if (this._textures) {\n            for (var key in this._textures) {\n                var texture = this._textures[key];\n                texture.dispose();\n            }\n            this._textures = null;\n        }\n    };\n    /**\n     * Updates the projection textures used to contain the depth renders.\n     */\n    SingleObjectDepthPass.prototype.updateProjectionTextures = function () {\n        if (this._textures) {\n            for (var key in this._textures) {\n                var texture = this._textures[key];\n                texture.dispose();\n            }\n        }\n        this._textures = new Object();\n        this._projections = new Object();\n        this._projectionTexturesInvalid = false;\n    };\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype._iGetVertexCode = function () {\n        var code;\n        // offset\n        code = \"mul vt7, vt1, vc4.x\t\\n\" +\n            \"add vt7, vt7, vt0\\n\" +\n            \"mov vt7.w, vt0.w\\n\";\n        // project\n        code += \"m44 vt2, vt7, vc0\\n\" +\n            \"mov op, vt2\\n\";\n        // perspective divide\n        code += \"div v0, vt2, vt2.w\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        // encode float -> rgba\n        code += \"mul ft0, fc0, v0.z\\n\" +\n            \"frc ft0, ft0\\n\" +\n            \"mul ft1, ft0.yzww, fc1\\n\" +\n            \"sub ft0, ft0, ft1\\n\" +\n            \"mov oc, ft0\\n\";\n        return code;\n    };\n    /**\n     * Gets the depth maps rendered for this object from all lights.\n     * @param renderableGL The renderableGL for which to retrieve the depth maps.\n     * @param stage3DProxy The Stage3DProxy object currently used for rendering.\n     * @return A list of depth map textures for all supported lights.\n     */\n    SingleObjectDepthPass.prototype._iGetDepthMap = function (renderableGL) {\n        return this._textures[renderableGL.renderable.id];\n    };\n    /**\n     * Retrieves the depth map projection maps for all lights.\n     * @param renderableGL The renderableGL for which to retrieve the projection maps.\n     * @return A list of projection maps for all supported lights.\n     */\n    SingleObjectDepthPass.prototype._iGetProjection = function (renderableGL) {\n        return this._projections[renderableGL.renderable.id];\n    };\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype._iRender = function (renderableGL, camera, viewProjection) {\n        var matrix;\n        var context = this._stage.context;\n        var len;\n        var light;\n        var lights = this._surface.lightPicker.allPickedLights;\n        var rId = renderableGL.renderable.id;\n        if (!this._textures[rId])\n            this._textures[rId] = new Single2DTexture_1.default(new Image2D_1.default(this._textureSize, this._textureSize));\n        if (!this._projections[rId])\n            this._projections[rId] = new Matrix3D_1.default();\n        len = lights.length;\n        // local position = enough\n        light = lights[0];\n        matrix = light.iGetObjectProjectionMatrix(renderableGL.sourceEntity, camera.sceneTransform, this._projections[rId]);\n        this._stage.setRenderTarget(this._textures[rId], true);\n        context.clear(1.0, 1.0, 1.0);\n        context.setProgramConstantsFromMatrix(ContextGLProgramType_1.default.VERTEX, 0, matrix, true);\n        context.setProgramConstantsFromArray(ContextGLProgramType_1.default.FRAGMENT, 0, this._enc, 2);\n        var elements = renderableGL.elements;\n        var elementsGL = this._shader._elementsPool.getAbstraction(elements);\n        elementsGL.activateVertexBufferVO(0, elements.positions);\n        elementsGL.activateVertexBufferVO(1, elements.normals);\n        elementsGL.getIndexBufferGL().draw(ContextGLDrawMode_1.default.TRIANGLES, 0, elements.numElements);\n    };\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype._iActivate = function (camera) {\n        if (this._projectionTexturesInvalid)\n            this.updateProjectionTextures();\n        // never scale\n        _super.prototype._iActivate.call(this, camera);\n        this._stage.context.setProgramConstantsFromArray(ContextGLProgramType_1.default.VERTEX, 4, this._polyOffset, 1);\n    };\n    return SingleObjectDepthPass;\n}(PassBase_1.default));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = SingleObjectDepthPass;\n\n},{\"awayjs-core/lib/geom/Matrix3D\":undefined,\"awayjs-core/lib/image/Image2D\":undefined,\"awayjs-display/lib/textures/Single2DTexture\":undefined,\"awayjs-renderergl/lib/surfaces/passes/PassBase\":undefined,\"awayjs-stagegl/lib/base/ContextGLDrawMode\":undefined,\"awayjs-stagegl/lib/base/ContextGLProgramType\":undefined}],\"awayjs-methodmaterials/lib/surfaces\":[function(require,module,exports){\n\"use strict\";\nvar MethodPass_1 = require(\"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\");\nexports.MethodPass = MethodPass_1.default;\nvar MethodPassMode_1 = require(\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\");\nexports.MethodPassMode = MethodPassMode_1.default;\nvar SingleObjectDepthPass_1 = require(\"awayjs-methodmaterials/lib/surfaces/passes/SingleObjectDepthPass\");\nexports.SingleObjectDepthPass = SingleObjectDepthPass_1.default;\nvar GL_MethodMaterialSurface_1 = require(\"awayjs-methodmaterials/lib/surfaces/GL_MethodMaterialSurface\");\nexports.GL_MethodMaterialSurface = GL_MethodMaterialSurface_1.default;\n\n},{\"awayjs-methodmaterials/lib/surfaces/GL_MethodMaterialSurface\":\"awayjs-methodmaterials/lib/surfaces/GL_MethodMaterialSurface\",\"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\",\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\",\"awayjs-methodmaterials/lib/surfaces/passes/SingleObjectDepthPass\":\"awayjs-methodmaterials/lib/surfaces/passes/SingleObjectDepthPass\"}]},{},[1])\n\n",
    "import * as data\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data\";\nimport * as methods\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods\";\nimport * as surfaces\t\t\t\tfrom \"awayjs-methodmaterials/lib/surfaces\";\nimport MethodMaterial\t\t\t\tfrom \"awayjs-methodmaterials/lib/MethodMaterial\";\nimport MethodMaterialMode\t\t\tfrom \"awayjs-methodmaterials/lib/MethodMaterialMode\";\n\nimport SurfacePool\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/SurfacePool\";\n\nSurfacePool.registerAbstraction(surfaces.GL_MethodMaterialSurface, MethodMaterial);\n\nexport {\n\tdata,\n\tmethods,\n\tsurfaces,\n\tMethodMaterial,\n\tMethodMaterialMode\n}",
    "class MethodMaterialMode\n{\n\t/**\n\t *\n\t */\n\tpublic static SINGLE_PASS:string = \"singlePass\";\n\n\t/**\n\t *\n\t */\n\tpublic static MULTI_PASS:string = \"multiPass\";\n}\n\nexport default MethodMaterialMode;",
    "﻿import Image2D\t\t\t\t\t\tfrom \"awayjs-core/lib/image/Image2D\";\n\nimport MaterialBase\t\t\t\t\tfrom \"awayjs-display/lib/materials/MaterialBase\";\nimport Single2DTexture\t\t\t\tfrom \"awayjs-display/lib/textures/Single2DTexture\";\nimport TextureBase\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport ContextGLCompareMode\t\t\tfrom \"awayjs-stagegl/lib/base/ContextGLCompareMode\";\n\nimport MethodMaterialMode\t\t\tfrom \"awayjs-methodmaterials/lib/MethodMaterialMode\";\nimport AmbientBasicMethod\t\t\tfrom \"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\";\nimport DiffuseBasicMethod\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\";\nimport EffectMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectMethodBase\";\nimport NormalBasicMethod\t\t\tfrom \"awayjs-methodmaterials/lib/methods/NormalBasicMethod\";\nimport ShadowMapMethodBase\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\";\nimport SpecularBasicMethod\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\";\n\n/**\n * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,\n * using material methods to define their appearance.\n */\nclass MethodMaterial extends MaterialBase\n{\n\tpublic static assetType:string = \"[materials MethodMaterial]\";\n\n\tprivate _effectMethods:Array<EffectMethodBase> = new Array<EffectMethodBase>();\n\tprivate _mode:string;\n\n\tprivate _ambientMethod:AmbientBasicMethod = new AmbientBasicMethod();\n\tprivate _shadowMethod:ShadowMapMethodBase;\n\tprivate _diffuseMethod:DiffuseBasicMethod = new DiffuseBasicMethod();\n\tprivate _normalMethod:NormalBasicMethod = new NormalBasicMethod();\n\tprivate _specularMethod:SpecularBasicMethod = new SpecularBasicMethod();\n\n\n\tprivate _depthCompareMode:string = ContextGLCompareMode.LESS_EQUAL;\n\n\t/**\n\t *\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn MethodMaterial.assetType;\n\t}\n\n\t/**\n\t * Creates a new MethodMaterial object.\n\t *\n\t * @param texture The texture used for the material's albedo color.\n\t * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.\n\t * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to false.\n\t * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to false.\n\t */\n\tconstructor(image?:Image2D, alpha?:number);\n\tconstructor(color?:number, alpha?:number);\n\tconstructor(imageColor:any = null, alpha:number = 1)\n\t{\n\t\tsuper(imageColor, alpha);\n\n\t\tthis._mode = MethodMaterialMode.SINGLE_PASS;\n\n\t\t//add default methods owners\n\t\tthis._ambientMethod.iAddOwner(this);\n\t\tthis._diffuseMethod.iAddOwner(this);\n\t\tthis._normalMethod.iAddOwner(this);\n\t\tthis._specularMethod.iAddOwner(this);\n\n\t\t//set a texture if an image is present\n\t\tif (imageColor instanceof Image2D)\n\t\t\tthis._ambientMethod.texture = new Single2DTexture();\n\t}\n\n\n\tpublic get mode():string\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:string)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\n\t\tthis._mode = value;\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The depth compare mode used to render the renderables using this material.\n\t *\n\t * @see away.stagegl.ContextGLCompareMode\n\t */\n\n\tpublic get depthCompareMode():string\n\t{\n\t\treturn this._depthCompareMode;\n\t}\n\n\tpublic set depthCompareMode(value:string)\n\t{\n\t\tif (this._depthCompareMode == value)\n\t\t\treturn;\n\n\t\tthis._depthCompareMode = value;\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The texture object to use for the ambient colour.\n\t */\n\tpublic get diffuseTexture():TextureBase\n\t{\n\t\treturn this._diffuseMethod.texture;\n\t}\n\n\tpublic set diffuseTexture(value:TextureBase)\n\t{\n\t\tthis._diffuseMethod.texture = value;\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._ambientMethod;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._ambientMethod == value)\n\t\t\treturn;\n\n\t\tif (this._ambientMethod)\n\t\t\tthis._ambientMethod.iRemoveOwner(this);\n\n\t\tthis._ambientMethod = value;\n\n\t\tif (this._ambientMethod)\n\t\t\tthis._ambientMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._shadowMethod;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._shadowMethod == value)\n\t\t\treturn;\n\n\t\tif (this._shadowMethod)\n\t\t\tthis._shadowMethod.iRemoveOwner(this);\n\n\t\tthis._shadowMethod = value;\n\n\t\tif (this._shadowMethod)\n\t\t\tthis._shadowMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._diffuseMethod;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._diffuseMethod == value)\n\t\t\treturn;\n\n\t\tif (this._diffuseMethod)\n\t\t\tthis._diffuseMethod.iRemoveOwner(this);\n\n\t\tthis._diffuseMethod = value;\n\n\t\tif (this._diffuseMethod)\n\t\t\tthis._diffuseMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._specularMethod;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._specularMethod == value)\n\t\t\treturn;\n\n\t\tif (this._specularMethod)\n\t\t\tthis._specularMethod.iRemoveOwner(this);\n\n\t\tthis._specularMethod = value;\n\n\t\tif (this._specularMethod)\n\t\t\tthis._specularMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._normalMethod;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._normalMethod == value)\n\t\t\treturn;\n\n\t\tif (this._normalMethod)\n\t\t\tthis._normalMethod.iRemoveOwner(this);\n\n\t\tthis._normalMethod = value;\n\n\t\tif (this._normalMethod)\n\t\t\tthis._normalMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._effectMethods.length;\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tmethod.iAddOwner(this);\n\n\t\tthis._effectMethods.push(method);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\treturn this._effectMethods[index];\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tmethod.iAddOwner(this);\n\n\t\tthis._effectMethods.splice(index, 0, method);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tmethod.iRemoveOwner(this);\n\n\t\tthis._effectMethods.splice(this._effectMethods.indexOf(method), 1);\n\n\t\tthis.invalidate();\n\t}\n}\n\nexport default MethodMaterial;",
    "import GL_TextureBase\t\t\t\tfrom \"awayjs-renderergl/lib/textures/GL_TextureBase\";\n\nimport MethodPass\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\";\nimport ShadingMethodBase\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadingMethodBase\";\n\n/**\n * MethodVO contains data for a given shader object for the use within a single material.\n * This allows shader methods to be shared across materials while their non-public state differs.\n */\nclass MethodVO\n{\n\tpublic useMethod:boolean = true;\n\n\tpublic method:ShadingMethodBase;\n\tpublic pass:MethodPass;\n\n\t// public register indices\n\tpublic textureGL:GL_TextureBase;\n\tpublic secondaryTextureGL:GL_TextureBase; // sometimes needed for composites\n\tpublic vertexConstantsIndex:number;\n\tpublic secondaryVertexConstantsIndex:number; // sometimes needed for composites\n\tpublic fragmentConstantsIndex:number;\n\tpublic secondaryFragmentConstantsIndex:number; // sometimes needed for composites\n\n\t// internal stuff for the material to know before assembling code\n\tpublic needsProjection:boolean;\n\tpublic needsView:boolean;\n\tpublic needsNormals:boolean;\n\tpublic needsTangents:boolean;\n\tpublic needsGlobalVertexPos:boolean;\n\tpublic needsGlobalFragmentPos:boolean;\n\t/**\n\t * Creates a new MethodVO object.\n\t */\n\tconstructor(method:ShadingMethodBase, pass:MethodPass)\n\t{\n\t\tthis.method = method;\n\t\tthis.pass = pass;\n\t}\n\n\t/**\n\t * Resets the values of the value object to their \"unused\" state.\n\t */\n\tpublic reset()\n\t{\n\t\tthis.method.iReset();\n\n\t\tthis.vertexConstantsIndex = -1;\n\t\tthis.secondaryVertexConstantsIndex = -1;\n\t\tthis.fragmentConstantsIndex = -1;\n\t\tthis.secondaryFragmentConstantsIndex = -1;\n\n\t\tthis.needsProjection = false;\n\t\tthis.needsView = false;\n\t\tthis.needsNormals = false;\n\t\tthis.needsTangents = false;\n\t\tthis.needsGlobalVertexPos = false;\n\t\tthis.needsGlobalFragmentPos = false;\n\t}\n}\n\nexport default MethodVO;\n",
    "export {default as MethodVO}\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";",
    "import AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport ShadingMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadingMethodBase\";\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass AmbientBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number;\n\tprivate _alpha:number = 1;\n\n\tpublic _texture:TextureBase;\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _strength:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, this._texture));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!methodVO.textureGL) {\n\t\t\tthis._color = shader.numLights? 0xFFFFFF : methodVO.pass._surface.style.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tif (this._strength == value)\n\t\t\treturn;\n\n\t\tthis._strength = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The texture to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:AmbientBasicMethod = <AmbientBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (methodVO.textureGL) {\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tvar ambientInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (methodVO.textureGL)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._strength;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._strength;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._strength;\n\t}\n}\n\nexport default AmbientBasicMethod;",
    "import AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport AmbientBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\";\n\n/**\n * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to\n * approximate global lighting rather than lights.\n */\nclass AmbientEnvMapMethod extends AmbientBasicMethod\n{\n\t/**\n\t * Creates a new <code>AmbientEnvMapMethod</code> object.\n\t *\n\t * @param envMap The cube environment map to use for the ambient lighting.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, this._texture));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (this._texture)? methodVO.textureGL._iGetFragmentCode(targetReg, regCache, sharedRegisters, sharedRegisters.normalFragment) : \"\";\n\t}\n}\n\nexport default AmbientEnvMapMethod;",
    "import AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport ShadingMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadingMethodBase\";\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass CurveBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tpublic _texture:TextureBase;\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, this._texture));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!methodVO.textureGL) {\n\t\t\tthis._color = methodVO.pass._surface.style.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The texture to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:CurveBasicMethod = <CurveBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n    /*\n    public iGeVertexCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string {\n        var code:string = \"\";\n        code = \"mov \" + sharedRegisters.uvVarying + \" \" + registerCache.uv +  \" \\n\";\n    }*/\n    public iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar ambientInputRegister:ShaderRegisterElement;\n\n\t\tif (methodVO.textureGL) {\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tambientInputRegister = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n        code = \"mov \" + targetReg + \", \" + sharedRegisters.uvVarying + \"\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (methodVO.textureGL)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\nexport default CurveBasicMethod;",
    "import AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\n\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport ShadingMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadingMethodBase\";\nimport LightingMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/LightingMethodBase\";\n\n/**\n * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.\n */\nclass DiffuseBasicMethod extends LightingMethodBase\n{\n\tprivate _multiply:boolean = true;\n\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\n\tpublic _texture:TextureBase;\n\tprivate _ambientColor:number;\n\tprivate _ambientColorR:number = 1;\n\tprivate _ambientColorG:number = 1;\n\tprivate _ambientColorB:number = 1;\n\tprivate _color:number = 0xffffff;\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Set internally if diffuse color component multiplies or replaces the ambient color\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this._multiply;\n\t}\n\n\tpublic set multiply(value:boolean)\n\t{\n\t\tif (this._multiply == value)\n\t\t\treturn;\n\n\t\tthis._multiply = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, null));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\n\t\tif (shader.numLights > 0) {\n\t\t\tshader.usesCommonData = true;\n\t\t\tmethodVO.needsNormals = true;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tif (shader.numLights > 0) {\n\t\t\tthis._ambientColor = methodVO.pass._surface.style.color;\n\t\t\tthis.updateAmbientColor();\n\t\t} else {\n\t\t\tthis._ambientColor = null;\n\t\t}\n\t}\n\n\t/**\n\t * The color of the diffuse reflection when not using a texture.\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number)\n\t{\n\t\tif (this._color == value)\n\t\t\treturn;\n\n\t\tthis._color = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The texture to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar diff:DiffuseBasicMethod = <DiffuseBasicMethod> method;\n\n\t\tthis.texture = diff.texture;\n\t\tthis.multiply = diff.multiply;\n\t\tthis.color = diff.color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pTotalLightColorReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \", \" + sharedRegisters.normalFragment + \"\\n\" +\n\t\t\t\t\"max \" + t + \".w, \" + t + \".x, \" + sharedRegisters.commons + \".y\\n\";\n\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".w, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"tex \" + t + \", \" + sharedRegisters.normalFragment + \", \" + cubeMapReg + \" <cube,linear,miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tvar diffuseColor:ShaderRegisterElement;\n\t\tvar cutOffReg:ShaderRegisterElement;\n\n\t\t// incorporate input from ambient\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += this.pApplyShadow(shader, methodVO, registerCache, sharedRegisters);\n\n\t\tregisterCache.addFragmentTempUsages(diffuseColor = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar ambientColorRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = ambientColorRegister.index*4;\n\n\t\tif (this._texture) {\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(diffuseColor, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\t\t} else {\n\t\t\tvar diffuseInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\t\tcode += \"mov \" + diffuseColor + \", \" + diffuseInputRegister + \"\\n\";\n\t\t}\n\n\t\tcode += \"sat \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\"mul \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\";\n\n\t\tif (this._multiply) {\n\t\t\tcode += \"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\";\n\t\t} else if (this._texture) {\n\t\t\tcode += \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + ambientColorRegister + \"\\n\" + // multiply target by ambient for total ambient\n\t\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" + // ambient * (1 - totalLightColor)\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; //add diffuse color and ambient color\n\t\t} else {\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" + // ambient * (1 - totalLightColor)\n\t\t\t\t\"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\" + // add diffuse color and  ambient color\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; // multiply by target which could be texture or white\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\tregisterCache.removeFragmentTempUsage(diffuseColor);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Generate the code that applies the calculated shadow to the diffuse light\n\t * @param methodVO The MethodVO object for which the compilation is currently happening.\n\t * @param regCache The register cache the compiler is currently using for the register management.\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tif (this._multiply) {\n\t\t\t\tdata[index + 4] = this._colorR*this._ambientColorR;\n\t\t\t\tdata[index + 5] = this._colorG*this._ambientColorG;\n\t\t\t\tdata[index + 6] = this._colorB*this._ambientColorB;\n\t\t\t} else {\n\t\t\t\tdata[index + 4] = this._colorR;\n\t\t\t\tdata[index + 5] = this._colorG;\n\t\t\t\tdata[index + 6] = this._colorB;\n\t\t\t}\n\t\t\tdata[index + 7] = 1;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the diffuse color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (this._color & 0xff)/0xff;\n\t}\n\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateAmbientColor()\n\t{\n\t\tthis._ambientColorR = ((this._ambientColor >> 16) & 0xff)/0xff;\n\t\tthis._ambientColorG = ((this._ambientColor >> 8) & 0xff)/0xff;\n\t\tthis._ambientColorB = (this._ambientColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\n\t\t//TODO move this to Activate (ambientR/G/B currently calc'd in render state)\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = shader.ambientR*this._ambientColorR;\n\t\tdata[index + 1] = shader.ambientG*this._ambientColorG;\n\t\tdata[index + 2] = shader.ambientB*this._ambientColorB;\n\t\tdata[index + 3] = 1;\n\t}\n}\n\nexport default DiffuseBasicMethod;",
    "import Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\";\nimport DiffuseCompositeMethod\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\";\n\n/**\n * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.\n */\nclass DiffuseCelMethod extends DiffuseCompositeMethod\n{\n\tprivate _levels:number /*uint*/;\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\n\t/**\n\t * Creates a new DiffuseCelMethod object.\n\t * @param levels The amount of shadow gradations.\n\t * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.\n\t */\n\tconstructor(levels:number /*uint*/ = 3, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampDiffuse(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._levels = levels;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tdata[index + 1] = 1;\n\t\tdata[index + 2] = 0;\n\t}\n\n\t/**\n\t * The amount of shadow gradations.\n\t */\n\tpublic get levels():number /*uint*/\n\t{\n\t\treturn this._levels;\n\t}\n\n\tpublic set levels(value:number /*uint*/)\n\t{\n\t\tthis._levels = value;\n\t}\n\n\t/**\n\t * The smoothness of the edge between 2 shading levels.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = this._levels;\n\t\tdata[index + 3] = this._smoothness;\n\t}\n\n\t/**\n\t * Snaps the diffuse shading of the wrapped method to one of the levels.\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the diffuse strength in the \"w\" component.\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampDiffuse(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"frc \" + targetReg + \".z, \" + targetReg + \".w\\n\" +\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t\"mov \" + targetReg + \".x, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"rcp \" + targetReg + \".x,\" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\n\t\t\t// previous clamped strength\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".x\\n\" +\n\n\t\t\t// fract/epsilon (so 0 - epsilon will become 0 - 1)\n\t\t\t\"div \" + targetReg + \".z, \" + targetReg + \".z, \" + this._dataReg + \".w\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t// 1-z\n\t\t\t\"sub \" + targetReg + \".z, \" + this._dataReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t}\n}\n\nexport default DiffuseCelMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\nimport ISurface\t\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\nimport ShadingMethodEvent\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\";\n\n/**\n * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the\n * calculated diffuse reflection strength.\n */\nclass DiffuseCompositeMethod extends DiffuseBasicMethod\n{\n\tpublic pBaseMethod:DiffuseBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new <code>DiffuseCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.\n\t * @param baseMethod The base diffuse method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis.pBaseMethod = baseMethod || new DiffuseBasicMethod();\n\t\tthis.pBaseMethod._iModulateMethod = modulateMethod;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base diffuse method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this.pBaseMethod;\n\t}\n\n\tpublic set baseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this.pBaseMethod == value)\n\t\t\treturn;\n\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod = value;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\tpublic iAddOwner(owner:ISurface)\n\t{\n\t\tsuper.iAddOwner(owner);\n\n\t\tthis.pBaseMethod.iAddOwner(owner);\n\t}\n\n\tpublic iRemoveOwner(owner:ISurface)\n\t{\n\t\tsuper.iRemoveOwner(owner);\n\n\t\tthis.pBaseMethod.iRemoveOwner(owner);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this.pBaseMethod.texture;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis.pBaseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this.pBaseMethod.color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set color(value:number)\n\t{\n\t\tthis.pBaseMethod.color = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this.pBaseMethod.multiply;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set multiply(value:boolean)\n\t{\n\t\tthis.pBaseMethod.multiply = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis.pBaseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.pBaseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis.pBaseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport default DiffuseCompositeMethod;",
    "import GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\";\n\n/**\n * DiffuseDepthMethod provides a debug method to visualise depth maps\n */\nclass DiffuseDepthMethod extends DiffuseBasicMethod\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = 1.0;\n\t\tdata[index + 1] = 1/255.0;\n\t\tdata[index + 2] = 1/65025.0;\n\t\tdata[index + 3] = 1/16581375.0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement;\n\t\tvar decReg:ShaderRegisterElement;\n\n\t\tif (!this._texture)\n\t\t\tthrow new Error(\"DiffuseDepthMethod requires texture!\");\n\n\t\t// incorporate input from ambient\n\t\tif (shader.numLights > 0) {\n\t\t\tif (sharedRegisters.shadowTarget)\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t\t\tcode += \"add \" + targetReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"sat \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\t\tregisterCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);\n\t\t} else {\n\t\t\ttemp = targetReg;\n\t\t}\n\n\t\tdecReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\"dp4 \" + temp + \".x, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"mov \" + temp + \".yz, \" + temp + \".xx\t\t\t\\n\" +\n\t\t\t\"mov \" + temp + \".w, \" + decReg + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + decReg + \".xxx, \" + temp + \".xyz\\n\";\n\n\t\tif (shader.numLights == 0)\n\t\t\treturn code;\n\n\t\tcode += \"mul \" + targetReg + \".xyz, \" + temp + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mov \" + targetReg + \".w, \" + temp + \".w\\n\";\n\n\t\tif (shader.numLights > 0)\n\t\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport default DiffuseDepthMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\";\n\n/**\n * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient\n * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude\n * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate\n * scattered light within the skin attributing to the final colour)\n */\nclass DiffuseGradientMethod extends DiffuseBasicMethod\n{\n\tprivate _gradient:TextureBase;\n\n\t/**\n\t * Creates a new DiffuseGradientMethod object.\n\t * @param gradient A texture that contains the light colour based on the angle. This can be used to change\n\t * the light colour due to subsurface scattering when the surface faces away from the light.\n\t */\n\tconstructor(gradient:TextureBase)\n\t{\n\t\tsuper();\n\n\t\tthis._gradient = gradient;\n\n\t\tif (this._gradient)\n\t\t\tthis.iAddTexture(this._gradient);\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._gradient);\n\t}\n\n\t/**\n\t * A texture that contains the light colour based on the angle. This can be used to change the light colour\n\t * due to subsurface scattering when the surface faces away from the light.\n\t */\n\tpublic get gradient():TextureBase\n\t{\n\t\treturn this._gradient;\n\t}\n\n\tpublic set gradient(value:TextureBase)\n\t{\n\t\tif (this._gradient == value)\n\t\t\treturn;\n\n\t\tif (this._gradient)\n\t\t\tthis.iRemoveTexture(this._gradient);\n\n\t\tthis._gradient = value;\n\n\t\tif (this._gradient)\n\t\t\tthis.iAddTexture(this._gradient);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(t, registerCache, sharedRegisters, t) +\n\t\t\t//\t\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + t + \".w\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + lightColReg + \".xyz\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar t:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn \"mov \" + t + \", \" + sharedRegisters.shadowTarget + \".wwww\\n\" +\n\t\t\tmethodVO.secondaryTextureGL._iGetFragmentCode(t, regCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tif (shader.numLights > 0)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n}\n\nexport default DiffuseGradientMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\";\nimport DiffuseCompositeMethod\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\";\n\n/**\n * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse\n * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather\n * than only the diffuse lighting value.\n */\nclass DiffuseLightMapMethod extends DiffuseCompositeMethod\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t * This can be used to add pre-calculated shadows or occlusion.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t * This can be used to add pre-calculated lighting or global illumination.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new DiffuseLightMapMethod method.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t\tthis._lightMap = lightMap;\n\t\tthis.blendMode = blendMode;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see DiffuseLightMapMethod.ADD\n\t * @see DiffuseLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture containing the light map data.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iRemoveTexture(this._lightMap);\n\n\t\tthis._lightMap = value;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase DiffuseLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase DiffuseLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcode += super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n}\n\nexport default DiffuseLightMapMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\";\nimport DiffuseCompositeMethod\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\";\nimport SingleObjectDepthPass\t\t\tfrom \"awayjs-methodmaterials/lib/surfaces/passes/SingleObjectDepthPass\";\n\n/**\n * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of\n * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.\n * It can be used for candle wax, ice, skin, ...\n */\nclass DiffuseSubSurfaceMethod extends DiffuseCompositeMethod\n{\n\tprivate _depthPass:SingleObjectDepthPass;\n\tprivate _lightProjVarying:ShaderRegisterElement;\n\tprivate _propReg:ShaderRegisterElement;\n\tprivate _scattering:number;\n\tprivate _translucency:number = 1;\n\tprivate _lightColorReg:ShaderRegisterElement;\n\tprivate _scatterColor:number /*uint*/ = 0xffffff;\n\tprivate _colorReg:ShaderRegisterElement;\n\tprivate _decReg:ShaderRegisterElement;\n\tprivate _scatterR:number = 1.0;\n\tprivate _scatterG:number = 1.0;\n\tprivate _scatterB:number = 1.0;\n\tprivate _targetReg:ShaderRegisterElement;\n\t\n\t/**\n\t * Creates a new <code>DiffuseSubSurfaceMethod</code> object.\n\t *\n\t * @param depthMapSize The size of the depth map used.\n\t * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(depthMapSize:number /*int*/ = 512, depthMapOffset:number = 15, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.pBaseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.scatterLight(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\t//this._passes = new Array<MaterialPassGLBase>();\n\t\t//this._depthPass = new SingleObjectDepthPass();\n\t\t//this._depthPass.textureSize = depthMapSize;\n\t\t//this._depthPass.polyOffset = depthMapOffset;\n\t\t//this._passes.push(this._depthPass);\n\t\tthis._scattering = 0.2;\n\t\tthis._translucency = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar data:Float32Array = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryVertexConstantsIndex;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = -.5;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\t\n\t\tdata = shader.fragmentConstantData;\n\t\tindex = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index + 3] = 1.0;\n\t\tdata[index + 4] = 1.0;\n\t\tdata[index + 5] = 1/255;\n\t\tdata[index + 6] = 1/65025;\n\t\tdata[index + 7] = 1/16581375;\n\t\tdata[index + 10] = .5;\n\t\tdata[index + 11] = -.1;\n\t}\n\t\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._lightProjVarying = null;\n\t\tthis._propReg = null;\n\t\tthis._lightColorReg = null;\n\t\tthis._colorReg = null;\n\t\tthis._decReg = null;\n\t\tthis._targetReg = null;\n\t}\n\t\n\t/**\n\t * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low\n\t * values for skin.\n\t */\n\tpublic get scattering():number\n\t{\n\t\treturn this._scattering;\n\t}\n\t\n\tpublic set scattering(value:number)\n\t{\n\t\tthis._scattering = value;\n\t}\n\t\n\t/**\n\t * The translucency of the object.\n\t */\n\tpublic get translucency():number\n\t{\n\t\treturn this._translucency;\n\t}\n\t\n\tpublic set translucency(value:number)\n\t{\n\t\tthis._translucency = value;\n\t}\n\t\n\t/**\n\t * The colour of the \"insides\" of the object, ie: the colour the light becomes after leaving the object.\n\t */\n\tpublic get scatterColor():number /*uint*/\n\t{\n\t\treturn this._scatterColor;\n\t}\n\t\n\tpublic set scatterColor(scatterColor:number /*uint*/)\n\t{\n\t\tthis._scatterColor = scatterColor;\n\t\tthis._scatterR = ((scatterColor >> 16) & 0xff)/0xff;\n\t\tthis._scatterG = ((scatterColor >> 8) & 0xff)/0xff;\n\t\tthis._scatterB = (scatterColor & 0xff)/0xff;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tvar lightProjection:ShaderRegisterElement;\n\t\tvar toTexRegister:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\t\t\n\t\ttoTexRegister = registerCache.getFreeVertexConstant();\n\t\tmethodVO.secondaryVertexConstantsIndex = toTexRegister.index*4;\n\n\t\tthis._lightProjVarying = registerCache.getFreeVarying();\n\t\tlightProjection = registerCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\t\n\t\tcode += \"m44 \" + temp + \", vt0, \" + lightProjection + \"\\n\" +\n\t\t\t\"div \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xy\\n\" +\n\t\t\t\"add \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xx\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".w, va0.w\\n\";\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._colorReg = registerCache.getFreeFragmentConstant();\n\t\tthis._decReg = registerCache.getFreeFragmentConstant();\n\t\tthis._propReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._colorReg.index*4;\n\t\t\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pIsFirstLight = true;\n\t\tthis._lightColorReg = lightColReg;\n\t\treturn super.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\t\n\t\tcode += \"mul \" + temp + \".xyz, \" + this._lightColorReg + \".xyz, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + this._colorReg + \".xyz\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t\n\t\tif (this._targetReg != sharedRegisters.viewDirFragment)\n\t\t\tregisterCache.removeFragmentTempUsage(targetReg);\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._scatterR;\n\t\tdata[index + 1] = this._scatterG;\n\t\tdata[index + 2] = this._scatterB;\n\t\tdata[index + 8] = this._scattering;\n\t\tdata[index + 9] = this._translucency;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._depthPass._iGetDepthMap(renderable));\n\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\n\t\tthis._depthPass._iGetProjection(renderable).copyRawDataTo(shader.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);\n\t}\n\t\n\t/**\n\t * Generates the code for this method\n\t */\n\tprivate scatterLight(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// only scatter first light\n\t\tif (!this._pIsFirstLight)\n\t\t\treturn \"\";\n\n\t\tthis._pIsFirstLight = false;\n\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.viewDirFragment)\n\t\t\tthis._targetReg = sharedRegisters.viewDirFragment;\n\t\telse\n\t\t\tregisterCache.addFragmentTempUsages(this._targetReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._lightProjVarying) +\n\t\t\t// reencode RGBA\n\t\t\t\"dp4 \" + targetReg + \".z, \" + temp + \", \" + this._decReg + \"\\n\";\n\t\t// currentDistanceToLight - closestDistanceToLight\n\t\tcode += \"sub \" + targetReg + \".z, \" + this._lightProjVarying + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t\"sub \" + targetReg + \".z, \" + this._propReg + \".x, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".z, \" + this._propReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t// targetReg.x contains dot(lightDir, normal)\n\t\t\t// modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)\n\t\t\t\"neg \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"mul \" + this._targetReg + \".w, \" + targetReg + \".z, \" + targetReg + \".y\\n\" +\n\t\t\t\n\t\t\t// blend diffuse: d' = (1-s)*d + s*1\n\t\t\t\"sub \" + targetReg + \".y, \" + this._colorReg + \".w, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t\t\n\t\treturn code;\n\t}\n}\n\nexport default DiffuseSubSurfaceMethod;",
    "import Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\";\n\n/**\n * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be \"wrapped around\" the normally dark area, to some extent.\n * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.\n */\nclass DiffuseWrapMethod extends DiffuseBasicMethod\n{\n\tprivate _wrapDataRegister:ShaderRegisterElement;\n\tprivate _wrapFactor:number;\n\n\t/**\n\t * Creates a new DiffuseWrapMethod object.\n\t * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap\n\t */\n\tconstructor(wrapFactor:number = .5)\n\t{\n\t\tsuper();\n\n\t\tthis.wrapFactor = wrapFactor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._wrapDataRegister = null;\n\t}\n\n\t/**\n\t * A factor to indicate the amount by which the light is allowed to wrap.\n\t */\n\tpublic get wrapFactor():number\n\t{\n\t\treturn this._wrapFactor;\n\t}\n\n\tpublic set wrapFactor(value:number)\n\t{\n\t\tthis._wrapFactor = value;\n\t\tthis._wrapFactor = 1/(value + 1);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\t\tthis._wrapDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index*4;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + t + \".y, \" + t + \".x, \" + this._wrapDataRegister + \".x\\n\" +\n\t\t\t\"mul \" + t + \".y, \" + t + \".y, \" + this._wrapDataRegister + \".y\\n\" +\n\t\t\t\"sat \" + t + \".w, \" + t + \".y\\n\" +\n\t\t\t\"mul \" + t + \".xz, \" + t + \".w, \" + lightDirReg + \".wz\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, lightDirReg, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".x, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._wrapFactor;\n\t\tdata[index + 1] = 1/(this._wrapFactor + 1);\n\t}\n}\n\nexport default DiffuseWrapMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectMethodBase\";\n\n/**\n * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used\n * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water\n * etc).\n */\nclass EffectAlphaMaskMethod extends EffectMethodBase\n{\n\tprivate _texture:TextureBase;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectAlphaMaskMethod object.\n\t *\n\t * @param texture The texture to use as the alpha mask.\n\t * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.\n\t */\n\tconstructor(texture:TextureBase, useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for\n\t * instance to tile the main texture and normal map while providing untiled alpha, for example to define the\n\t * transparency over a tiled water surface.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture to use as the alpha mask.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \".x\\n\";\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n}\n\nexport default EffectAlphaMaskMethod;",
    "import Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectMethodBase\";\n\n/**\n * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.\n */\nclass EffectColorMatrixMethod extends EffectMethodBase\n{\n\tprivate _matrix:Array<number>;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t *\n\t * @param matrix An array of 20 items for 4 x 5 color transform.\n\t */\n\tconstructor(matrix:Array<number>)\n\t{\n\t\tsuper();\n\n\t\tif (matrix.length != 20)\n\t\t\tthrow new Error(\"Matrix length must be 20!\");\n\n\t\tthis._matrix = matrix;\n\t}\n\n\t/**\n\t * The 4 x 5 matrix to transform the color of the material.\n\t */\n\tpublic get colorMatrix():Array<number>\n\t{\n\t\treturn this._matrix;\n\t}\n\n\tpublic set colorMatrix(value:Array<number>)\n\t{\n\t\tthis._matrix = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\n\t\tvar colorOffsetReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += \"m44 \" + temp + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + temp + \", \" + colorOffsetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar matrix:Array<number> = this._matrix;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\t// r\n\t\tdata[index] = matrix[0];\n\t\tdata[index + 1] = matrix[1];\n\t\tdata[index + 2] = matrix[2];\n\t\tdata[index + 3] = matrix[3];\n\n\t\t// g\n\t\tdata[index + 4] = matrix[5];\n\t\tdata[index + 5] = matrix[6];\n\t\tdata[index + 6] = matrix[7];\n\t\tdata[index + 7] = matrix[8];\n\n\t\t// b\n\t\tdata[index + 8] = matrix[10];\n\t\tdata[index + 9] = matrix[11];\n\t\tdata[index + 10] = matrix[12];\n\t\tdata[index + 11] = matrix[13];\n\n\t\t// a\n\t\tdata[index + 12] = matrix[15];\n\t\tdata[index + 13] = matrix[16];\n\t\tdata[index + 14] = matrix[17];\n\t\tdata[index + 15] = matrix[18];\n\n\t\t// rgba offset\n\t\tdata[index + 16] = matrix[4];\n\t\tdata[index + 17] = matrix[9];\n\t\tdata[index + 18] = matrix[14];\n\t\tdata[index + 19] = matrix[19];\n\t}\n}\n\nexport default EffectColorMatrixMethod;",
    "import ColorTransform\t\t\t\tfrom \"awayjs-core/lib/geom/ColorTransform\";\n\nimport Stage\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport ShaderBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport EffectMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectMethodBase\";\n\n/**\n * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a\n * ColorTransform object.\n */\nclass EffectColorTransformMethod extends EffectMethodBase\n{\n\tprivate _colorTransform:ColorTransform;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this._colorTransform;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tthis._colorTransform = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar colorOffsReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\t//TODO: AGAL <> GLSL\n\n\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" + \"add \" + targetReg + \", \" + targetReg + \", \" + colorOffsReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar inv:number = 1/0xff;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\tdata[index] = this._colorTransform.redMultiplier;\n\t\tdata[index + 1] = this._colorTransform.greenMultiplier;\n\t\tdata[index + 2] = this._colorTransform.blueMultiplier;\n\t\tdata[index + 3] = this._colorTransform.alphaMultiplier;\n\t\tdata[index + 4] = this._colorTransform.redOffset*inv;\n\t\tdata[index + 5] = this._colorTransform.greenOffset*inv;\n\t\tdata[index + 6] = this._colorTransform.blueOffset*inv;\n\t\tdata[index + 7] = this._colorTransform.alphaOffset*inv;\n\n\t}\n}\n\nexport default EffectColorTransformMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectMethodBase\";\n\n/**\n * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.\n */\nclass EffectEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates an EffectEnvMapMethod object.\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the surface.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (value == this._mask)\n\t\t\treturn;\n\n\t\tif (this._mask)\n\t\t\tthis.iRemoveTexture(this._mask);\n\n\t\tthis._mask = value;\n\n\t\tif (this._mask)\n\t\t\tthis.iAddTexture(this._mask);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tif (this._envMap)\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._envMap);\n\n\t\tif (this._mask) {\n\t\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\t// r = I - 2(I.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + sharedRegisters.normalFragment + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" + // -.5\n\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\tif (this._mask) {\n\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + temp + \", \" + temp2 + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + dataRegister + \".x\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport default EffectEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectMethodBase\";\n\n/**\n * EffectFogMethod provides a method to add distance-based fog to a material.\n */\nclass EffectFogMethod extends EffectMethodBase\n{\n\tprivate _minDistance:number = 0;\n\tprivate _maxDistance:number = 1000;\n\tprivate _fogColor:number /*uint*/;\n\tprivate _fogR:number;\n\tprivate _fogG:number;\n\tprivate _fogB:number;\n\n\t/**\n\t * Creates a new EffectFogMethod object.\n\t * @param minDistance The distance from which the fog starts appearing.\n\t * @param maxDistance The distance at which the fog is densest.\n\t * @param fogColor The colour of the fog.\n\t */\n\tconstructor(minDistance:number, maxDistance:number, fogColor:number /*uint*/ = 0x808080)\n\t{\n\t\tsuper();\n\t\tthis.minDistance = minDistance;\n\t\tthis.maxDistance = maxDistance;\n\t\tthis.fogColor = fogColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 6] = 0;\n\t\tdata[index + 7] = 0;\n\t}\n\n\t/**\n\t * The distance from which the fog starts appearing.\n\t */\n\tpublic get minDistance():number\n\t{\n\t\treturn this._minDistance;\n\t}\n\n\tpublic set minDistance(value:number)\n\t{\n\t\tthis._minDistance = value;\n\t}\n\n\t/**\n\t * The distance at which the fog is densest.\n\t */\n\tpublic get maxDistance():number\n\t{\n\t\treturn this._maxDistance;\n\t}\n\n\tpublic set maxDistance(value:number)\n\t{\n\t\tthis._maxDistance = value;\n\t}\n\n\t/**\n\t * The colour of the fog.\n\t */\n\tpublic get fogColor():number /*uint*/\n\t{\n\t\treturn this._fogColor;\n\t}\n\n\tpublic set fogColor(value:number/*uint*/)\n\t{\n\t\tthis._fogColor = value;\n\t\tthis._fogR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._fogG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._fogB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._fogR;\n\t\tdata[index + 1] = this._fogG;\n\t\tdata[index + 2] = this._fogB;\n\t\tdata[index + 4] = this._minDistance;\n\t\tdata[index + 5] = 1/(this._maxDistance - this._minDistance);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar fogColor:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar fogData:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\t\tmethodVO.fragmentConstantsIndex = fogColor.index*4;\n\n\t\tcode += \"sub \" + temp2 + \".w, \" + sharedRegisters.projectionFragment + \".z, \" + fogData + \".x\\n\" +\n\t\t\t\t\"mul \" + temp2 + \".w, \" + temp2 + \".w, \" + fogData + \".y\\n\" +\n\t\t\t\t\"sat \" + temp2 + \".w, \" + temp2 + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \", \" + fogColor + \", \" + targetReg + \"\\n\" + // (fogColor- col)\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + temp2 + \".w\\n\" + // (fogColor- col)*fogRatio\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\"; // fogRatio*(fogColor- col) + col\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport default EffectFogMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectMethodBase\";\n\n/**\n * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets\n * stronger as the viewing angle becomes more grazing.\n */\nclass EffectFresnelEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = 0;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates a new <code>EffectFresnelEnvMapMethod</code> object.\n\t *\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the material.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._envMap);\n\n\t\tif (this._mask != null) {\n\t\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (this._mask == value)\n\t\t\treturn;\n\n\t\tif (this._mask)\n\t\t\tthis.iRemoveTexture(this._mask);\n\n\t\tthis._mask = value;\n\n\t\tif (this._mask)\n\t\t\tthis.iAddTexture(this._mask);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._alpha;\n\t\tdata[index + 1] = this._normalReflectance;\n\t\tdata[index + 2] = this._fresnelPower;\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\t// r = V - 2(V.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + normalReg + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + viewDirReg + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\t\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +               \t// -.5\n\t\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\t// calculate fresnel term\n\t\tcode += \"dp3 \" + viewDirReg + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +  // dot(V, H)\n\t\t\t\t\"sub \" + viewDirReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +       // base = 1-dot(V, H)\n\t\t\t\t\"pow \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + dataRegister + \".z\\n\" +       // exp = pow(base, 5)\n\t\t\t\t\"sub \" + normalReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +        // 1 - exp\n\t\t\t\t\"mul \" + normalReg + \".w, \" + dataRegister + \".y, \" + normalReg + \".w\\n\" +         // f0*(1 - exp)\n\t\t\t\t\"add \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + normalReg + \".w\\n\" +          // exp + f0*(1 - exp)\n\n\t\t\t\t// total alpha\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + dataRegister + \".x, \" + viewDirReg + \".w\\n\";\n\n\t\tif (this._mask) {\n\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + temp2 + \".x, \" + viewDirReg + \".w\\n\";\n\t\t}\n\n\t\t// blend\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + viewDirReg + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport default EffectFresnelEnvMapMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectMethodBase\";\n\n/**\n * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.\n * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather\n * than the whole pixel colour.\n */\nclass EffectLightMapMethod extends EffectMethodBase\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectLightMapMethod object.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tif (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._lightMap = lightMap;\n\t\tthis._blendMode = blendMode;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureGL = shader.getAbstraction(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see EffectLightMapMethod.ADD\n\t * @see EffectLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tif (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The lightMap containing the light map.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iRemoveTexture(this._lightMap);\n\n\t\tthis._lightMap = value;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase EffectLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase EffectLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n}\n\nexport default EffectLightMapMethod;",
    "import IAsset\t\t\t\t\t\tfrom \"awayjs-core/lib/library/IAsset\";\nimport AbstractMethodError\t\t\tfrom \"awayjs-core/lib/errors/AbstractMethodError\";\n\nimport ShaderBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport ShadingMethodBase\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadingMethodBase\";\n\n/**\n * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,\n * and are in essence post-process effects on the materials.\n */\nclass EffectMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset EffectMethod]\";\n\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn EffectMethodBase.assetType;\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register that will be containing the method's output.\n\t * @private\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t}\n}\n\nexport default EffectMethodBase;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectMethodBase\";\n\n/**\n * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.\n */\nclass EffectRefractionEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\n\tprivate _dispersionR:number = 0;\n\tprivate _dispersionG:number = 0;\n\tprivate _dispersionB:number = 0;\n\tprivate _useDispersion:boolean;\n\tprivate _refractionIndex:number;\n\tprivate _alpha:number = 1;\n\n\t/**\n\t * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015\n\t *\n\t * @param envMap The environment map containing the refracted scene.\n\t * @param refractionIndex The refractive index of the material.\n\t * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tconstructor(envMap:TextureBase, refractionIndex:number = .1, dispersionR:number = 0, dispersionG:number = 0, dispersionB:number = 0)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._dispersionR = dispersionR;\n\t\tthis._dispersionG = dispersionG;\n\t\tthis._dispersionB = dispersionB;\n\t\tthis._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tthis._refractionIndex = refractionIndex;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index + 4] = 1;\n\t\tdata[index + 5] = 0;\n\t\tdata[index + 7] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._envMap);\n\t}\n\n\t/**\n\t * The cube environment map to use for the refraction.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * The refractive index of the material.\n\t */\n\tpublic get refractionIndex():number\n\t{\n\t\treturn this._refractionIndex;\n\t}\n\n\tpublic set refractionIndex(value:number)\n\t{\n\t\tthis._refractionIndex = value;\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionR():number\n\t{\n\t\treturn this._dispersionR;\n\t}\n\n\tpublic set dispersionR(value:number)\n\t{\n\t\tthis._dispersionR = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionG():number\n\t{\n\t\treturn this._dispersionG;\n\t}\n\n\tpublic set dispersionG(value:number)\n\t{\n\t\tthis._dispersionG = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionB():number\n\t{\n\t\treturn this._dispersionB;\n\t}\n\n\tpublic set dispersionB(value:number)\n\t{\n\t\tthis._dispersionB = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual\n\t * material. A value of 1 will make it appear fully transparent.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\tdata[index] = this._dispersionR + this._refractionIndex;\n\n\t\tif (this._useDispersion) {\n\t\t\tdata[index + 1] = this._dispersionG + this._refractionIndex;\n\t\t\tdata[index + 2] = this._dispersionB + this._refractionIndex;\n\t\t}\n\t\tdata[index + 3] = this._alpha;\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: data2.x could use common reg, so only 1 reg is used\n\t\tvar data:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar data2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar refractionDir:ShaderRegisterElement;\n\t\tvar refractionColor:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement;\n\n\t\tmethodVO.fragmentConstantsIndex = data.index*4;\n\n\t\trefractionDir = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionDir, 1);\n\t\trefractionColor = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionColor, 1);\n\t\ttemp = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\"mul \" + temp + \".x, \" + data + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\"mul \" + refractionDir + \", \" + data + \".x, \" + viewDirReg + \"\\n\" +\n\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\tmethodVO.textureGL._iGetFragmentCode(refractionColor, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\"sub \" + refractionColor + \".w, \" + refractionColor + \".w, fc0.x\t\\n\" +\n\t\t\t\"kil \" + refractionColor + \".w\\n\";\n\n\t\tif (this._useDispersion) {\n\t\t\t// GREEN\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".y, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".y, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".y, \" + temp + \".y\\n\";\n\n\t\t\t// BLUE\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".z, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".z, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".z, \" + temp + \".z\\n\";\n\t\t}\n\n\t\tcode += \"sub \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mul \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + data + \".w\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + refractionColor + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(refractionDir);\n\t\tregisterCache.removeFragmentTempUsage(refractionColor);\n\n\t\t// restore\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport default EffectRefractionEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport EffectMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectMethodBase\";\n\n/**\n * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.\n */\nclass EffectRimLightMethod extends EffectMethodBase\n{\n\tpublic static ADD:string = \"add\";\n\tpublic static MULTIPLY:string = \"multiply\";\n\tpublic static MIX:string = \"mix\";\n\n\tprivate _color:number /*uint*/;\n\tprivate _blendMode:string;\n\tprivate _colorR:number;\n\tprivate _colorG:number;\n\tprivate _colorB:number;\n\tprivate _strength:number;\n\tprivate _power:number;\n\n\t/**\n\t * Creates a new <code>EffectRimLightMethod</code> object.\n\t *\n\t * @param color The colour of the rim light.\n\t * @param strength The strength of the rim light.\n\t * @param power The power of the rim light. Higher values will result in a higher edge fall-off.\n\t * @param blend The blend mode with which to add the light to the object.\n\t */\n\tconstructor(color:number /*uint*/ = 0xffffff, strength:number = .4, power:number = 2, blend:string = \"mix\")\n\t{\n\t\tsuper();\n\n\t\tthis._blendMode = blend;\n\t\tthis._strength = strength;\n\t\tthis._power = power;\n\n\t\tthis.color = color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\n\t/**\n\t * The blend mode with which to add the light to the object.\n\t *\n\t * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.\n\t * EffectRimLightMethod.ADD adds the rim light with the material's colour.\n\t * EffectRimLightMethod.MIX provides normal alpha blending.\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The color of the rim light.\n\t */\n\tpublic get color():number /*uint*/\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number /*uint*/)\n\t{\n\t\tthis._color = value;\n\t\tthis._colorR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * The strength of the rim light.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._strength = value;\n\t}\n\n\t/**\n\t * The power of the rim light. Higher values will result in a higher edge fall-off.\n\t */\n\tpublic get power():number\n\t{\n\t\treturn this._power;\n\t}\n\n\tpublic set power(value:number)\n\t{\n\t\tthis._power = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._colorR;\n\t\tdata[index + 1] = this._colorG;\n\t\tdata[index + 2] = this._colorB;\n\t\tdata[index + 4] = this._strength;\n\t\tdata[index + 5] = this._power;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataRegister2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"sat \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"pow \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + dataRegister + \".w, \" + temp + \".x\\n\";\n\n\t\tif (this._blendMode == EffectRimLightMethod.ADD) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else {\n\t\t\tcode += \"sub \" + temp + \".xyz, \" + dataRegister + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n}\n\nexport default EffectRimLightMethod;",
    "import ShaderBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport LightingShader\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport ShadingMethodBase\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadingMethodBase\";\n\n/**\n * LightingMethodBase provides an abstract base method for shading methods that uses lights.\n * Used for diffuse and specular shaders only.\n */\nclass LightingMethodBase extends ShadingMethodBase\n{\n\t/**\n\t * A method that is exposed to wrappers in case the strength needs to be controlled\n\t */\n\tpublic _iModulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string;\n\n\t/**\n\t * Creates a new LightingMethodBase.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * Get the fragment shader code that will be needed before any per-light code is added.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @private\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param lightDirReg The register containing the light direction vector.\n\t * @param lightColReg The register containing the light colour.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light probe object.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param cubeMapReg The register containing the cube map for the current probe\n\t * @param weightRegister A string representation of the register + component containing the current weight\n\t * @param regCache The register cache providing any necessary registers to the shader\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register containing the final shading output.\n\t * @private\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n}\n\nexport default LightingMethodBase;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport ShadingMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadingMethodBase\";\n\n/**\n * NormalBasicMethod is the default method for standard tangent-space normal mapping.\n */\nclass NormalBasicMethod extends ShadingMethodBase\n{\n\tprivate _texture:TextureBase;\n\n\t/**\n\t * Creates a new NormalBasicMethod object.\n\t */\n\tconstructor(texture:TextureBase = null)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\tif (this._texture && shader.normalDependencies)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iOutputsTangentNormals():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar s:any = method;\n\t\tvar bnm:NormalBasicMethod = <NormalBasicMethod> method;\n\n\t\tif (bnm.texture != null)\n\t\t\tthis.texture = bnm.texture;\n\t}\n\n\t/**\n\t * A texture to modulate the direction of the surface for each texel (normal map). The default normal method expects\n\t * tangent-space normal maps, but others could expect object-space maps.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._texture)\n\t\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._texture)\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\n\t\tcode += \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport default NormalBasicMethod;",
    "import Single2DTexture\t\t\t\t\tfrom \"awayjs-display/lib/textures/Single2DTexture\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport NormalBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/NormalBasicMethod\";\nimport ShadingMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadingMethodBase\";\n\n/**\n * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.\n */\nclass NormalHeightMapMethod extends NormalBasicMethod\n{\n\tprivate _worldXYRatio:number;\n\tprivate _worldXZRatio:number;\n\n\t/**\n\t * Creates a new NormalHeightMapMethod method.\n\t *\n\t * @param heightMap The texture containing the height data. 0 means low, 1 means high.\n\t * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.\n\t * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.\n\t * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.\n\t */\n\tconstructor(heightMap:TextureBase, worldWidth:number, worldHeight:number, worldDepth:number)\n\t{\n\t\tsuper();\n\n\t\tthis.texture = heightMap;\n\t\tthis._worldXYRatio = worldWidth/worldHeight;\n\t\tthis._worldXZRatio = worldDepth/worldHeight;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = 1/(<Single2DTexture> this.texture).image2D.width;\n\t\tdata[index + 1] = 1/(<Single2DTexture> this.texture).image2D.height;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 4] = this._worldXYRatio;\n\t\tdata[index + 5] = this._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get tangentSpace():boolean\n\t{\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tsuper.copyFrom(method);\n\n\t\tthis._worldXYRatio = (<NormalHeightMapMethod> method)._worldXYRatio;\n\t\tthis._worldXZRatio = (<NormalHeightMapMethod> method)._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode+= methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".xzzz\\n\" +\n\n\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".zyzz\\n\" +\n\n\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\n\t\t\t\"sub \" + targetReg + \".z, \" + targetReg + \".z, \" + temp + \".x\\n\" +\n\t\t\t\"mov \" + targetReg + \".y, \" + dataReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".xz, \" + targetReg + \".xz, \" + dataReg2 + \".xy\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport default NormalHeightMapMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport NormalBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/NormalBasicMethod\";\n\n/**\n * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.\n */\nclass NormalSimpleWaterMethod extends NormalBasicMethod\n{\n\tprivate _secondaryNormalMap:TextureBase;\n\tprivate _water1OffsetX:number = 0;\n\tprivate _water1OffsetY:number = 0;\n\tprivate _water2OffsetX:number = 0;\n\tprivate _water2OffsetY:number = 0;\n\n\t/**\n\t * Creates a new NormalSimpleWaterMethod object.\n\t * @param waveMap1 A normal map containing one layer of a wave structure.\n\t * @param waveMap2 A normal map containing a second layer of a wave structure.\n\t */\n\tconstructor(normalMap:TextureBase = null, secondaryNormalMap:TextureBase = null)\n\t{\n\t\tsuper(normalMap);\n\n\t\tthis._secondaryNormalMap = secondaryNormalMap;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iAddTexture(this._secondaryNormalMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = 0;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\t\t\n\t\tif (this._secondaryNormalMap) {\n\t\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._secondaryNormalMap);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the X-axis.\n\t */\n\tpublic get water1OffsetX():number\n\t{\n\t\treturn this._water1OffsetX;\n\t}\n\n\tpublic set water1OffsetX(value:number)\n\t{\n\t\tthis._water1OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the Y-axis.\n\t */\n\tpublic get water1OffsetY():number\n\t{\n\t\treturn this._water1OffsetY;\n\t}\n\n\tpublic set water1OffsetY(value:number)\n\t{\n\t\tthis._water1OffsetY = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the X-axis.\n\t */\n\tpublic get water2OffsetX():number\n\t{\n\t\treturn this._water2OffsetX;\n\t}\n\n\tpublic set water2OffsetX(value:number)\n\t{\n\t\tthis._water2OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the Y-axis.\n\t */\n\tpublic get water2OffsetY():number\n\t{\n\t\treturn this._water2OffsetY;\n\t}\n\n\tpublic set water2OffsetY(value:number)\n\t{\n\t\tthis._water2OffsetY = value;\n\t}\n\n\t/**\n\t * A second normal map that will be combined with the first to create a wave-like animation pattern.\n\t */\n\tpublic get secondaryNormalMap():TextureBase\n\t{\n\t\treturn this._secondaryNormalMap;\n\t}\n\n\tpublic set secondaryNormalMap(value:TextureBase)\n\t{\n\t\tif (this._secondaryNormalMap == value)\n\t\t\treturn;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iRemoveTexture(this._secondaryNormalMap);\n\n\t\tthis._secondaryNormalMap = value;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iAddTexture(this._secondaryNormalMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\tthis._secondaryNormalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\n\t\tdata[index + 4] = this._water1OffsetX;\n\t\tdata[index + 5] = this._water1OffsetY;\n\t\tdata[index + 6] = this._water2OffsetX;\n\t\tdata[index + 7] = this._water2OffsetY;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".xyxy\\n\";\n\n\t\tif (this.texture)\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, temp);\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".zwzw\\n\";\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp);\n\n\t\tcode +=\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\t\t\\n\" +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + dataReg + \".x\t\\n\" +\n\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\t\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\t\t\t\t\t\t\t\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport default NormalSimpleWaterMethod;",
    "import AssetBase\t\t\t\t\tfrom \"awayjs-core/lib/library/AssetBase\";\n\nimport Camera\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport ISurface\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\nimport TextureBase\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShadingMethodEvent\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport ShaderBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\n\n\n/**\n * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile\n * the final shading program.\n */\nclass ShadingMethodBase extends AssetBase\n{\n\tpublic _textures:Array<TextureBase> = new Array<TextureBase>();\n\n\tpublic _owners:Array<ISurface> = new Array<ISurface>();\n\tpublic _counts:Array<number> = new Array<number>();\n\n\tpublic static assetType:string = \"[asset ShadingMethod]\";\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadingMethodBase.assetType;\n\t}\n\n\t/**\n\t * Create a new ShadingMethodBase object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Initializes the properties for a MethodVO, including register and texture indices.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t}\n\n\t/**\n\t * Initializes unchanging shader constants using the data from a MethodVO.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\n\t}\n\n\t/**\n\t * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iUsesTangentSpace():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Cleans up any resources used by the current object.\n\t */\n\tpublic dispose()\n\t{\n\n\t}\n\n\n\tpublic iAddOwner(owner:ISurface)\n\t{\n\t\t//a method can be used more than once in the same material, so we check for this\n\t\tvar index:number = this._owners.indexOf(owner);\n\n\t\tif (index != -1) {\n\t\t\tthis._counts[index]++;\n\t\t} else {\n\t\t\tthis._owners.push(owner);\n\t\t\tthis._counts.push(1);\n\n\t\t\t//add textures\n\t\t\tvar len:number = this._textures.length;\n\t\t\tfor (var i:number = 0; i< len; i++)\n\t\t\t\towner.addTexture(this._textures[i]);\n\t\t}\n\t}\n\n\tpublic iRemoveOwner(owner:ISurface)\n\t{\n\t\tvar index:number = this._owners.indexOf(owner);\n\n\t\tif (this._counts[index] != 1) {\n\t\t\tthis._counts[index]--;\n\t\t} else {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tthis._counts.splice(index, 1);\n\n\t\t\t//remove textures\n\t\t\tvar len:number = this._textures.length;\n\t\t\tfor (var i:number = 0; i< len; i++)\n\t\t\t\towner.removeTexture(this._textures[i]);\n\t\t}\n\t}\n\n\n\t/**\n\t *\n\t */\n\tpublic iAddTexture(texture:TextureBase)\n\t{\n\t\tthis._textures.push(texture);\n\n\t\tvar len:number = this._owners.length;\n\t\tfor (var i:number = 0; i < len; i++)\n\t\t\tthis._owners[i].addTexture(texture);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic iRemoveTexture(texture:TextureBase)\n\t{\n\t\tthis._textures.splice(this._textures.indexOf(texture), 1);\n\n\t\tvar len:number = this._owners.length;\n\t\tfor (var i:number = 0; i < len; i++)\n\t\t\tthis._owners[i].removeTexture(texture);\n\t}\n\n\t/**\n\t * Resets the compilation state of the method.\n\t *\n\t * @internal\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Resets the method's state for compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t}\n\n\t/**\n\t * Get the vertex shader code for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn null;\n\t}\n\n\t/**\n\t * Sets the render state for this method.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Sets the render state for a single renderable.\n\t *\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param renderable The renderable currently being rendered.\n\t * @param stage The Stage object currently used for rendering.\n\t * @param camera The camera from which the scene is currently rendered.\n\t *\n\t * @internal\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\n\t}\n\n\t/**\n\t * Clears the render state for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Marks the shader program as invalid, so it will be recompiled before the next render.\n\t *\n\t * @internal\n\t */\n\tpublic iInvalidateShaderProgram()\n\t{\n\t\tthis.dispatchEvent(new ShadingMethodEvent(ShadingMethodEvent.SHADER_INVALIDATED));\n\t}\n\n\t/**\n\t * Copies the state from a ShadingMethodBase object into the current object.\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t}\n}\n\nexport default ShadingMethodBase;",
    "import AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\n\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport DirectionalLight\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\nimport CascadeShadowMapper\t\t\t\tfrom \"awayjs-display/lib/materials/shadowmappers/CascadeShadowMapper\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShadingMethodEvent\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport ShadowMapMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\";\nimport ShadowMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowMethodBase\";\n\n/**\n * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.\n * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.\n *\n * @see away.lights.CascadeShadowMapper\n */\nclass ShadowCascadeMethod extends ShadowMapMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\tprivate _cascadeShadowMapper:CascadeShadowMapper;\n\tprivate _depthMapCoordVaryings:Array<ShaderRegisterElement>;\n\tprivate _cascadeProjections:Array<ShaderRegisterElement>;\n\n\t/**\n\t * Creates a new ShadowCascadeMethod object.\n\t *\n\t * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t */\n\tconstructor(shadowMethodBase:ShadowMethodBase)\n\t{\n\t\tsuper(shadowMethodBase.castingLight);\n\n\t\tthis._baseMethod = shadowMethodBase;\n\t\tif (!(this._pCastingLight instanceof DirectionalLight))\n\t\t\tthrow new Error(\"ShadowCascadeMethod is only compatible with DirectionalLight\");\n\n\t\tthis._cascadeShadowMapper = <CascadeShadowMapper> this._pCastingLight.shadowMapper;\n\n\t\tif (!this._cascadeShadowMapper)\n\t\t\tthrow new Error(\"ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.\");\n\n\t\tthis._cascadeShadowMapper.addEventListener(AssetEvent.INVALIDATE, (event:AssetEvent) => this.onCascadeChange(event));\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\t}\n\n\t/**\n\t * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction\n\t * with a DirectionalShadowMapper.\n\t *\n\t * @see ShadowHardMethod\n\t * @see ShadowSoftMethod\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar tempVO:MethodVO = new MethodVO(this._baseMethod, methodVO.pass);\n\t\tthis._baseMethod.iInitVO(shader, tempVO);\n\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = .5;\n\t\tfragmentData[index + 7] = -.5;\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tvertexData[index] = .5;\n\t\tvertexData[index + 1] = -.5;\n\t\tvertexData[index + 2] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._cascadeProjections = null;\n\t\tthis._depthMapCoordVaryings = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeVertexConstant();\n\n\t\tthis.initProjectionsRegs(registerCache);\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + this._cascadeProjections[i] + \"\\n\" +\n\t\t\t\t\"add \" + this._depthMapCoordVaryings[i] + \", \" + temp + \", \" + dataReg + \".zzwz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Creates the registers for the cascades' projection coordinates.\n\t */\n\tprivate initProjectionsRegs(registerCache:ShaderRegisterCache)\n\t{\n\t\tthis._cascadeProjections = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\t\tthis._depthMapCoordVaryings = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tthis._depthMapCoordVaryings[i] = registerCache.getFreeVarying();\n\t\t\tthis._cascadeProjections[i] = registerCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvar decReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistanceReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistances:Array<string> = Array<string>( planeDistanceReg + \".x\", planeDistanceReg + \".y\", planeDistanceReg + \".z\", planeDistanceReg + \".w\" );\n\t\tvar code:string;\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar inQuad:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(inQuad, 1);\n\t\tvar uvCoord:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvCoord, 1);\n\n\t\t// assume lowest partition is selected, will be overwritten later otherwise\n\t\tcode = \"mov \" + uvCoord + \", \" + this._depthMapCoordVaryings[numCascades - 1] + \"\\n\";\n\n\t\tfor (var i:number = numCascades - 2; i >= 0; --i) {\n\t\t\tvar uvProjection:ShaderRegisterElement = this._depthMapCoordVaryings[i];\n\n\t\t\t// calculate if in texturemap (result == 0 or 1, only 1 for a single partition)\n\t\t\tcode += \"slt \" + inQuad + \".z, \" + sharedRegisters.projectionFragment + \".z, \" + planeDistances[i] + \"\\n\"; // z = x > minX, w = y > minY\n\n\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t// linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)\n\t\t\tcode += \"sub \" + temp + \", \" + uvProjection + \", \" + uvCoord + \"\\n\" +\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + inQuad + \".z\\n\" +\n\t\t\t\t\"add \" + uvCoord + \", \" + uvCoord + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(inQuad);\n\n\t\tcode += \"div \" + uvCoord + \", \" + uvCoord + \", \" + uvCoord + \".w\\n\" +\n\t\t\t\"mul \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zw\\n\" +\n\t\t\t\"add \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zz\\n\";\n\n\t\tcode += this._baseMethod._iGetCascadeFragmentCode(shader, methodVO, decReg, uvCoord, targetReg, registerCache, sharedRegisters) +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + dataReg + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(uvCoord);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar vertexIndex:number = methodVO.vertexConstantsIndex;\n\n\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/(this._cascadeShadowMapper.depth*this._pEpsilon);\n\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvertexIndex += 4;\n\t\tfor (var k:number = 0; k < numCascades; ++k) {\n\t\t\tthis._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);\n\t\t\tvertexIndex += 16;\n\t\t}\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar fragmentIndex:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[fragmentIndex + 5] = 1 - this._pAlpha;\n\n\t\tvar nearPlaneDistances:Array<number> = this._cascadeShadowMapper._iNearPlaneDistances;\n\n\t\tfragmentIndex += 8;\n\t\tfor (var i:number = 0; i < numCascades; ++i)\n\t\t\tfragmentData[fragmentIndex + i] = nearPlaneDistances[i];\n\n\t\tthis._baseMethod.iActivateForCascade(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t}\n\n\t/**\n\t * Called when the shadow mappers cascade configuration changes.\n\t */\n\tprivate onCascadeChange(event:AssetEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport default ShadowCascadeMethod;",
    "import BitmapImage2D\t\t\t\t\tfrom \"awayjs-core/lib/image/BitmapImage2D\";\n\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport DirectionalLight\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\nimport Single2DTexture\t\t\t\t\tfrom \"awayjs-display/lib/textures/Single2DTexture\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport ShadowMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowMethodBase\";\n\n/**\n * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.\n */\nclass ShadowDitheredMethod extends ShadowMethodBase\n{\n\tprivate static _grainTexture:Single2DTexture;\n\tprivate static _grainUsages:number /*int*/;\n\tprivate static _grainBitmapImage2D:BitmapImage2D;\n\tprivate _depthMapSize:number /*int*/;\n\tprivate _range:number;\n\tprivate _numSamples:number /*int*/;\n\n\t/**\n\t * Creates a new ShadowDitheredMethod object.\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 4, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\n\t\t++ShadowDitheredMethod._grainUsages;\n\n\t\tif (!ShadowDitheredMethod._grainTexture)\n\t\t\tthis.initGrainTexture();\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tif (value < 1)\n\t\t\tvalue = 1;\n\t\telse if (value > 24)\n\t\t\tvalue = 24;\n\n\t\tif (this._numSamples == value)\n\t\t\treturn;\n\n\t\tthis._numSamples = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(ShadowDitheredMethod._grainTexture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = 1/this._numSamples;\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range*2;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value/2;\n\t}\n\n\t/**\n\t * Creates a texture containing the dithering noise texture.\n\t */\n\tprivate initGrainTexture()\n\t{\n\t\tShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D(64, 64, false);\n\t\tvar vec:Array<number> /*uint*/ = new Array<number>();\n\t\tvar len:number /*uint*/ = 4096;\n\t\tvar step:number = 1/(this._depthMapSize*this._range);\n\t\tvar r:number, g:number;\n\n\t\tfor (var i:number /*uint*/ = 0; i < len; ++i) {\n\t\t\tr = 2*(Math.random() - .5);\n\t\t\tg = 2*(Math.random() - .5);\n\t\t\tif (r < 0)\n\t\t\t\tr -= step; else\n\t\t\t\tr += step;\n\t\t\tif (g < 0)\n\t\t\t\tg -= step; else\n\t\t\t\tg += step;\n\t\t\tif (r > 1)\n\t\t\t\tr = 1; else if (r < -1)\n\t\t\t\tr = -1;\n\t\t\tif (g > 1)\n\t\t\t\tg = 1; else if (g < -1)\n\t\t\t\tg = -1;\n\t\t\tvec[i] = (Math.floor((r*.5 + .5)*0xff) << 16) | (Math.floor((g*.5 + .5)*0xff) << 8);\n\t\t}\n\n\t\tShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);\n\t\tShadowDitheredMethod._grainTexture = new Single2DTexture(ShadowDitheredMethod._grainBitmapImage2D);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (--ShadowDitheredMethod._grainUsages == 0) {\n\t\t\tShadowDitheredMethod._grainTexture.dispose();\n\t\t\tShadowDitheredMethod._grainBitmapImage2D.dispose();\n\t\t\tShadowDitheredMethod._grainTexture = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 9] = (stage.width - 1)/63;\n\t\tdata[index + 10] = (stage.height - 1)/63;\n\t\tdata[index + 11] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, customDataReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar numSamples:number /*int*/ = this._numSamples;\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar projectionReg:ShaderRegisterElement = sharedRegisters.projectionFragment;\n\n\t\tcode += \"div \" + uvReg + \", \" + projectionReg + \", \" + projectionReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".xy, \" + uvReg + \".xy, \" + customDataReg + \".yz\\n\";\n\n\t\twhile (numSamples > 0) {\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, uvReg);\n\t\t\t} else {\n\t\t\t\tcode += \"mov \" + temp + \", \" + uvReg + \".zwxy \\n\" +\n\t\t\t\t\tmethodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, temp);\n\t\t\t}\n\n\t\t\t// keep grain in uvReg.zw\n\t\t\tcode += \"sub \" + uvReg + \".zw, \" + uvReg + \".xy, fc0.xx\\n\" + // uv-.5\n\t\t\t\t\"mul \" + uvReg + \".zw, \" + uvReg + \".zw, \" + customDataReg + \".w\\n\"; // (tex unpack scale and tex scale in one)\n\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\t// first sample\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".zw, \" + this._pDepthMapCoordReg + \".xy\\n\" +\n\t\t\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t\t\t} else {\n\t\t\t\tcode += this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\t\t\t}\n\n\t\t\tif (numSamples > 4)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 1)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 5)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 2) {\n\t\t\t\tcode += \"neg \" + uvReg + \".w, \" + uvReg + \".w\\n\"; // will be rotated 90 degrees when being accessed as wz\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".wz, \" + this._pDepthMapCoordReg + \".xy\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\t\t\t}\n\n\t\t\tif (numSamples > 6)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 3)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 7)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tnumSamples -= 8;\n\t\t}\n\n\t\tregCache.removeFragmentTempUsage(temp);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\t\tcode += \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + customDataReg + \".x\\n\"; // average\n\t\treturn code;\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uvReg The uv register for the tap.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, uvReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + temp + \".z, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \".z\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = (stage.width - 1)/63;\n\t\tdata[index + 2] = (stage.height - 1)/63;\n\t\tdata[index + 3] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);\n\t}\n}\n\nexport default ShadowDitheredMethod;",
    "import DirectionalLight\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport ShadowMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowMethodBase\";\n\n/**\n * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison\n * results of neighbouring pixels.\n */\nclass ShadowFilteredMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadow\n\t */\n\tconstructor(castingLight:DirectionalLight)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = .5;\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tfragmentData[index + 9] = size;\n\t\tfragmentData[index + 10] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthCol, 1);\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tcode += \"mov \" + uvReg + \", \" + this._pDepthMapCoordReg + \"\\n\" +\n\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" + \t// (1, 0)\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mov \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".y, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".z\\n\" +\t// (0, 1)\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\t// (1, 1)\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t// recalculate fraction, since we ran out of registers :(\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + uvReg + \".w\\n\";\n\n\t\tregCache.removeFragmentTempUsage(depthCol);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = size;\n\t\tdata[index + 1] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar predicate:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(predicate, 1);\n\n\t\tcode = methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".x, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".z, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".y, \" + depthProjection + \".y, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"sub \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".y, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"mul \" + temp + \".xy, \" + depthProjection + \".xy, \" + dataReg + \".x\\n\" +\n\t\t\t\"frc \" + temp + \".xy, \" + temp + \".xy\\n\" +\n\n\t\t\t// some strange register juggling to prevent agal bugging out\n\t\t\t\"sub \" + depthProjection + \", \" + predicate + \".xyzw, \" + predicate + \".zwxy\\n\" +\n\t\t\t\"mul \" + depthProjection + \", \" + depthProjection + \", \" + temp + \".x\\n\" +\n\n\t\t\t\"add \" + predicate + \".xy, \" + predicate + \".xy, \" + depthProjection + \".zw\\n\" +\n\n\t\t\t\"sub \" + predicate + \".y, \" + predicate + \".y, \" + predicate + \".x\\n\" +\n\t\t\t\"mul \" + predicate + \".y, \" + predicate + \".y, \" + temp + \".y\\n\" +\n\t\t\t\"add \" + targetRegister + \".w, \" + predicate + \".x, \" + predicate + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(predicate);\n\t\treturn code;\n\t}\n}\n\nexport default ShadowFilteredMethod;",
    "import LightBase\t\t\t\t\t\tfrom \"awayjs-display/lib/display/LightBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport ShadowMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowMethodBase\";\n\n/**\n * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.\n */\nclass ShadowHardMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new ShadowHardMethod object.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\"; // 0 if in shadow\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar epsReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar posReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar depthSampleCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthSampleCol, 1);\n\t\tvar lightDir:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(lightDir, 1);\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += \"sub \" + lightDir + \", \" + sharedRegisters.globalPositionVarying + \", \" + posReg + \"\\n\" +\n\t\t\t\"dp3 \" + lightDir + \".w, \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\t\t\t\"mul \" + lightDir + \".w, \" + lightDir + \".w, \" + posReg + \".w\\n\" +\n\t\t\t\"nrm \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthSampleCol, regCache, sharedRegisters, lightDir) +\n\t\t\t\"dp4 \" + depthSampleCol + \".z, \" + depthSampleCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + lightDir + \".w, \" + epsReg + \".x\\n\" +    // offset by epsilon\n\n\t\t\t\"slt \" + targetReg + \".w, \" + targetReg + \".w, \" + depthSampleCol + \".z\\n\"; // 0 if in shadow\n\n\t\tregCache.removeFragmentTempUsage(lightDir);\n\t\tregCache.removeFragmentTempUsage(depthSampleCol);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + targetRegister + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t}\n}\n\nexport default ShadowHardMethod;",
    "import IAsset\t\t\t\t\t\t\tfrom \"awayjs-core/lib/library/IAsset\";\n\nimport LightBase\t\t\t\t\t\tfrom \"awayjs-display/lib/display/LightBase\";\nimport ShadowMapperBase\t\t\t\t\tfrom \"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase\";\n\nimport ShadingMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadingMethodBase\";\n\n/**\n * ShadowMapMethodBase provides an abstract base method for shadow map methods.\n */\nclass ShadowMapMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset ShadowMapMethod]\";\n\n\tpublic _pCastingLight:LightBase;\n\tpublic _pShadowMapper:ShadowMapperBase;\n\n\tpublic _pEpsilon:number = .02;\n\tpublic _pAlpha:number = 1;\n\n\t/**\n\t * Creates a new ShadowMapMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper();\n\t\tthis._pCastingLight = castingLight;\n\t\tcastingLight.shadowsEnabled = true;\n\t\tthis._pShadowMapper = castingLight.shadowMapper;\n\n\t\tthis.iAddTexture(castingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadowMapMethodBase.assetType;\n\t}\n\n\t/**\n\t * The \"transparency\" of the shadows. This allows making shadows less strong.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._pAlpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._pAlpha = value;\n\t}\n\n\t/**\n\t * The light casting the shadows.\n\t */\n\tpublic get castingLight():LightBase\n\t{\n\t\treturn this._pCastingLight;\n\t}\n\n\t/**\n\t * A small value to counter floating point precision errors when comparing values in the shadow map with the\n\t * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._pEpsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._pEpsilon = value;\n\t}\n}\n\nexport default ShadowMapMethodBase;",
    "import Vector3D\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Vector3D\";\nimport AbstractMethodError\t\t\t\tfrom \"awayjs-core/lib/errors/AbstractMethodError\";\n\nimport LightBase\t\t\t\t\t\tfrom \"awayjs-display/lib/display/LightBase\";\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport DirectionalLight\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\nimport PointLight\t\t\t\t\t\tfrom \"awayjs-display/lib/display/PointLight\";\nimport DirectionalShadowMapper\t\t\tfrom \"awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport ShadowMapMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\";\n\n/**\n * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.\n */\nclass ShadowMethodBase extends ShadowMapMethodBase\n{\n\tpublic _pDepthMapCoordReg:ShaderRegisterElement;\n\tpublic _pUsePoint:boolean;\n\n\t/**\n\t * Creates a new ShadowMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis._pUsePoint = (castingLight instanceof PointLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsView = true;\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsGlobalFragmentPos = this._pUsePoint;\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = 0;\n\t\tfragmentData[index + 7] = 1;\n\n\t\tif (this._pUsePoint) {\n\t\t\tfragmentData[index + 8] = 0;\n\t\t\tfragmentData[index + 9] = 0;\n\t\t\tfragmentData[index + 10] = 0;\n\t\t\tfragmentData[index + 11] = 1;\n\t\t}\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tif (index != -1) {\n\t\t\tvertexData[index] = .5;\n\t\t\tvertexData[index + 1] = .5;\n\t\t\tvertexData[index + 2] = 0.0;\n\t\t\tvertexData[index + 3] = 1.0;\n\t\t}\n\t}\n\n\t/**\n\t * Wrappers that override the vertex shader need to set this explicitly\n\t */\n\tpublic get _iDepthMapCoordReg():ShaderRegisterElement\n\t{\n\t\treturn this._pDepthMapCoordReg;\n\t}\n\n\tpublic set _iDepthMapCoordReg(value:ShaderRegisterElement)\n\t{\n\t\tthis._pDepthMapCoordReg = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pDepthMapCoordReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._pUsePoint? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters):this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a point light.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic _pGetPointVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tmethodVO.vertexConstantsIndex = -1;\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic pGetPlanarVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeVertexVectorTemp();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tvar depthMapProj:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tthis._pDepthMapCoordReg = regCache.getFreeVarying();\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\t// todo: can epsilon be applied here instead of fragment shader?\n\n\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + depthMapProj + \"\\n\" +\n\t\t\t\"div \" + temp + \", \" + temp + \", \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + dataReg + \".xy\\n\" +\n\t\t\t\"add \" + this._pDepthMapCoordReg + \", \" + temp + \", \" + dataReg + \".xxwz\\n\";\n\t\t//\"sub \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._pUsePoint? this._pGetPointFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tcode += \"add \" + targetReg + \".w, \" + targetReg + \".w, fc\" + (methodVO.fragmentConstantsIndex/4 + 1) + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a planar shadow map.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a point light.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (!this._pUsePoint)\n\t\t\t(<DirectionalShadowMapper> this._pShadowMapper).iDepthProjection.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);\n\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Gets the fragment code for combining this method with a cascaded shadow map method.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param decodeRegister The register containing the data to decode the shadow map depth value.\n\t * @param depthTexture The texture containing the shadow map.\n\t * @param depthProjection The projection of the fragment relative to the light.\n\t * @param targetRegister The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\n\t\tif (this._pUsePoint)\n\t\t\tfragmentData[index + 4] = -Math.pow(1/((<PointLight> this._pCastingLight).fallOff*this._pEpsilon), 2);\n\t\telse\n\t\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/((<DirectionalShadowMapper> this._pShadowMapper).depth*this._pEpsilon);\n\n\t\tfragmentData[index + 5] = 1 - this._pAlpha;\n\n\t\tif (this._pUsePoint) {\n\t\t\tvar pos:Vector3D = this._pCastingLight.scenePosition;\n\t\t\tfragmentData[index + 8] = pos.x;\n\t\t\tfragmentData[index + 9] = pos.y;\n\t\t\tfragmentData[index + 10] = pos.z;\n\t\t\t// used to decompress distance\n\t\t\tvar f:number = (<PointLight> this._pCastingLight).fallOff;\n\t\t\tfragmentData[index + 11] = 1/(2*f*f);\n\t\t}\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * Sets the method state for cascade shadow mapping.\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n}\n\nexport default ShadowMethodBase;",
    "import NearDirectionalShadowMapper\t\tfrom \"awayjs-display/lib/materials/shadowmappers/NearDirectionalShadowMapper\";\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShadingMethodEvent\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport ShadowMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowMethodBase\";\n\n// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work\n/**\n * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize\n * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.\n *\n * @see away.lights.NearDirectionalShadowMapper\n */\nclass ShadowNearMethod extends ShadowMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\n\tprivate _fadeRatio:number;\n\tprivate _nearShadowMapper:NearDirectionalShadowMapper;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new ShadowNearMethod object.\n\t * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tconstructor(baseMethod:ShadowMethodBase, fadeRatio:number = .1)\n\t{\n\t\tsuper(baseMethod.castingLight);\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod;\n\t\tthis._fadeRatio = fadeRatio;\n\t\tthis._nearShadowMapper = <NearDirectionalShadowMapper> this._pCastingLight.shadowMapper;\n\t\tif (!this._nearShadowMapper)\n\t\t\tthrow new Error(\"ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.\");\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base shadow map method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index + 2] = 0;\n\t\tfragmentData[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._baseMethod.alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._baseMethod.alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._baseMethod.epsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._baseMethod.epsilon = value;\n\t}\n\n\t/**\n\t * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tpublic get fadeRatio():number\n\t{\n\t\treturn this._fadeRatio;\n\t}\n\n\tpublic set fadeRatio(value:number)\n\t{\n\t\tthis._fadeRatio = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._baseMethod.iGetFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentSingleTemp();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"abs \" + temp + \", \" + sharedRegisters.projectionFragment + \".w\\n\" +\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + dataReg + \".x\\n\" +\n\t\t\t\"mul \" + temp + \", \" + temp + \", \" + dataReg + \".y\\n\" +\n\t\t\t\"sat \" + temp + \", \" + temp + \"\\n\" +\n\t\t\t\"sub \" + temp + \", \" + dataReg + \".w,\" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\t// todo: move this to activate (needs camera)\n\t\tvar near:number = camera.projection.near;\n\t\tvar d:number = camera.projection.far - near;\n\t\tvar maxDistance:number = this._nearShadowMapper.coverageRatio;\n\t\tvar minDistance:number = maxDistance*(1 - this._fadeRatio);\n\n\t\tmaxDistance = near + maxDistance*d;\n\t\tminDistance = near + minDistance*d;\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = minDistance;\n\t\tfragmentData[index + 1] = 1/(maxDistance - minDistance);\n\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport default ShadowNearMethod;",
    "import PoissonLookup\t\t\t\t\tfrom \"awayjs-core/lib/geom/PoissonLookup\";\n\nimport DirectionalLight\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport ShadowMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowMethodBase\";\n\n/**\n * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.\n */\nclass ShadowSoftMethod extends ShadowMethodBase\n{\n\tprivate _range:number = 1;\n\tprivate _numSamples:number /*int*/;\n\tprivate _offsets:Array<number>;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 5, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tthis._numSamples = value;\n\t\t\n\t\tif (this._numSamples < 1)\n\t\t\tthis._numSamples = 1;\n\t\telse if (this._numSamples > 32)\n\t\t\tthis._numSamples = 32;\n\n\t\tthis._offsets = PoissonLookup.getDistribution(this._numSamples);\n\t\t\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1/this._numSamples;\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = .5*this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex + 10;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: move some things to super\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decReg, targetReg, regCache, sharedRegisters, dataReg);\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uv The uv register for the tap.\n\t * @param texture The texture register containing the depth map.\n\t * @param decode The register containing the depth map decoding data.\n\t * @param target The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData, uvReg:ShaderRegisterElement):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetRegister + \".w, \" + targetRegister + \".w, \" + uvReg + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = 0;\n\t\tindex += 2;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\n\t\tif (len%4 == 0) {\n\t\t\tdata[index + len] = 0;\n\t\t\tdata[index + len + 1] = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthTexture The texture register containing the depth map.\n\t * @param decodeRegister The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t * @param dataReg The register containing additional data.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData, dataReg:ShaderRegisterElement):string\n\t{\n\t\tvar code:string;\n\t\tvar uvReg:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tvar offsets:Array<string> = new Array<string>(dataReg + \".zw\");\n\t\tvar numRegs:number /*int*/ = this._numSamples >> 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < numRegs; ++i) {\n\t\t\tvar reg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\toffsets.push(reg + \".xy\");\n\t\t\toffsets.push(reg + \".zw\");\n\t\t}\n\n\t\tfor (i = 0; i < this._numSamples; ++i) {\n\t\t\tif (i == 0) {\n\t\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t\tcode = \"add \" + uvReg + \", \" + this._pDepthMapCoordReg + \", \" + dataReg + \".zwyy\\n\" +\n\t\t\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetRegister + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow;\n\t\t\t} else {\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + offsets[i] + \"\\n\" +\n\t\t\t\t\tthis.addSample(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg);\n\t\t\t}\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(uvReg);\n\n\t\tcode += \"mul \" + targetRegister + \".w, \" + targetRegister + \".w, \" + dataReg + \".x\\n\"; // average\n\n\t\treturn code;\n\t}\n}\n\nexport default ShadowSoftMethod;",
    "import LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport SpecularBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\";\n\n/**\n * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for\n * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.\n * The tangent vectors are used as the surface groove directions.\n */\nclass SpecularAnisotropicMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularAnisotropicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsTangents = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\t// (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k\n\n\t\tcode += \"nrm \" + t + \".xyz, \" + sharedRegisters.tangentVarying + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".w, \" + t + \".xyz, \" + lightDirReg + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".z, \" + t + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\";\n\n\t\t// (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k\n\t\tcode += \"sin \" + t + \".x, \" + t + \".w\\n\" +\n\t\t\t\"sin \" + t + \".y, \" + t + \".z\\n\" +\n\t\t\t// (t.x * t.y - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"mul \" + t + \".x, \" + t + \".x, \" + t + \".y\\n\" +\n\t\t\t// (t.x - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"cos \" + t + \".z, \" + t + \".z\\n\" +\n\t\t\t\"cos \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t// (t.x - t.w*t.z) ^ k\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + t + \".z\\n\" +\n\t\t\t// (t.x - t.w) ^ k\n\t\t\t\"sub \" + t + \".w, \" + t + \".x, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport default SpecularAnisotropicMethod;",
    "import AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\n\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport LightingMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/LightingMethodBase\";\nimport ShadingMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadingMethodBase\";\n\n/**\n * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated\n * version of Phong specularity).\n */\nclass SpecularBasicMethod extends LightingMethodBase\n{\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\tpublic _pSpecularTexData:ShaderRegisterElement;\n\tpublic _pSpecularDataRegister:ShaderRegisterElement;\n\n\tprivate _texture:TextureBase;\n\n\tprivate _gloss:number = 50;\n\tprivate _strength:number = 1;\n\tprivate _color:number = 0xffffff;\n\tpublic _iSpecularR:number = 1;\n\tpublic _iSpecularG:number = 1;\n\tpublic _iSpecularB:number = 1;\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new SpecularBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\t\tmethodVO.needsView = shader.numLights > 0;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, null));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\n\t/**\n\t * The glossiness of the material (sharpness of the specular highlight).\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._gloss = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular highlights.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tif (value == this._strength)\n\t\t\treturn;\n\n\t\tthis._strength = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The colour of the specular reflection of the surface.\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number)\n\t{\n\t\tif (this._color == value)\n\t\t\treturn;\n\n\t\t// specular is now either enabled or disabled\n\t\tif (this._color == 0 || value == 0)\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._color = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * A texture that defines the strength of specular reflections for each texel in the red channel,\n\t * and the gloss factor (sharpness) in the green channel. You can use Specular2DTexture if you want to easily set\n\t * specular and gloss maps from grayscale images, but correctly authored images are preferred.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\n\t\tvar m:any = method;\n\t\tvar bsm:SpecularBasicMethod = <SpecularBasicMethod> method;\n\n\t\tvar spec:SpecularBasicMethod = bsm;//SpecularBasicMethod(method);\n\t\tthis.texture = spec.texture;\n\t\tthis.strength = spec.strength;\n\t\tthis.color = spec.color;\n\t\tthis.gloss = spec.gloss;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._pTotalLightColorReg = null;\n\t\tthis._pSpecularTexData = null;\n\t\tthis._pSpecularDataRegister = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tthis._pSpecularDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index*4;\n\n\t\tif (this._texture) {\n\n\t\t\tthis._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(this._pSpecularTexData, 1);\n\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(this._pSpecularTexData, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\t\t}\n\n\t\tthis._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\t// blinn-phong half vector model\n\t\tcode += \"add \" + t + \", \" + lightDirReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"nrm \" + t + \".xyz, \" + t + \"\\n\" +\n\t\t\t\t\"dp3 \" + t + \".w, \" + normalReg + \", \" + t + \"\\n\" +\n\t\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else {\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\t\t}\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \", \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\n\t\tcode += \"dp3 \" + t + \".w, \" + normalReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t\t\"mul \" + t + \", \" + t + \".w, \" + normalReg + \"\\n\" +\n\t\t\t\t\"sub \" + t + \", \" + t + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"tex \" + t + \", \" + t + \", \" + cubeMapReg + \" <cube,\" + \"linear\" + \",miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply strength modulation from texture\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularTexData + \".x\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pSpecularTexData);\n\t\t}\n\n\t\t// apply material's specular reflection\n\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularDataRegister + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\";\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._iSpecularR;\n\t\tdata[index + 1] = this._iSpecularG;\n\t\tdata[index + 2] = this._iSpecularB;\n\t\tdata[index + 3] = this._gloss;\n\t}\n\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the specular color data used by the render state.\n\t */\n\tprivate updateSpecular()\n\t{\n\t\tthis._iSpecularR = (( this._color >> 16) & 0xff)/0xff*this._strength;\n\t\tthis._iSpecularG = (( this._color >> 8) & 0xff)/0xff*this._strength;\n\t\tthis._iSpecularB = ( this._color & 0xff)/0xff*this._strength;\n\t}\n}\n\nexport default SpecularBasicMethod;",
    "import Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport SpecularBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\";\nimport SpecularCompositeMethod\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\";\n\n/**\n * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.\n */\nclass SpecularCelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\tprivate _specularCutOff:number = .1;\n\n\t/**\n\t * Creates a new SpecularCelMethod object.\n\t * @param specularCutOff The threshold at which the specular highlight should be shown.\n\t * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.\n\t */\n\tconstructor(specularCutOff:number = .5, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._specularCutOff = specularCutOff;\n\t}\n\n\t/**\n\t * The smoothness of the highlight edge.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * The threshold at which the specular highlight should be shown.\n\t */\n\tpublic get specularCutOff():number\n\t{\n\t\treturn this._specularCutOff;\n\t}\n\n\tpublic set specularCutOff(value:number)\n\t{\n\t\tthis._specularCutOff = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._smoothness;\n\t\tdata[index + 1] = this._specularCutOff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the specular strength in the \"w\" component, and either the half-vector or the reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" + // x - cutoff\n\t\t\t\"div \" + targetReg + \".y, \" + targetReg + \".y, \" + this._dataReg + \".x\\n\" + // (x - cutoff)/epsilon\n\t\t\t\"sat \" + targetReg + \".y, \" + targetReg + \".y\\n\" +\n\t\t\t\"sge \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n}\n\nexport default SpecularCelMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\nimport ISurface\t\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport ShadingMethodEvent\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport SpecularBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\";\n\n/**\n * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the\n * calculated specular reflection strength.\n */\nclass SpecularCompositeMethod extends SpecularBasicMethod\n{\n\tprivate _baseMethod:SpecularBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new <code>SpecularCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.\n\t * @param baseMethod The base specular method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod || new SpecularBasicMethod();\n\t\tthis._baseMethod._iModulateMethod = modulateMethod;\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\n\tpublic iAddOwner(owner:ISurface)\n\t{\n\t\tsuper.iAddOwner(owner);\n\n\t\tthis._baseMethod.iAddOwner(owner);\n\t}\n\n\tpublic iRemoveOwner(owner:ISurface)\n\t{\n\t\tsuper.iRemoveOwner(owner);\n\n\t\tthis._baseMethod.iRemoveOwner(owner);\n\t}\n\n\t/**\n\t * The base specular method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():SpecularBasicMethod\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._baseMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._baseMethod.gloss = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._baseMethod.strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._baseMethod.strength = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this._baseMethod.color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set color(value:number)\n\t{\n\t\tthis._baseMethod.color = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis._baseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._baseMethod.texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis._baseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @return\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport default SpecularCompositeMethod;",
    "import Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport SpecularBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\";\nimport SpecularCompositeMethod\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\";\n\n/**\n * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.\n */\nclass SpecularFresnelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _incidentLight:boolean;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = .028; // default value for skin\n\n\t/**\n\t * Creates a new SpecularFresnelMethod object.\n\t * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.\n\t */\n\tconstructor(basedOnSurface:boolean = true, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\t// may want to offer diff speculars\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.modulateSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._incidentLight = !basedOnSurface;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tshader.fragmentConstantData[index + 2] = 1;\n\t\tshader.fragmentConstantData[index + 3] = 0;\n\t}\n\n\t/**\n\t * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t */\n\tpublic get basedOnSurface():boolean\n\t{\n\t\treturn !this._incidentLight;\n\t}\n\n\tpublic set basedOnSurface(value:boolean)\n\t{\n\t\tif (this._incidentLight != value)\n\t\t\treturn;\n\n\t\tthis._incidentLight = !value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = this._normalReflectance;\n\t\tfragmentData[index + 1] = this._fresnelPower;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Applies the fresnel effect to the specular strength.\n\t *\n\t * @param vo The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param target The register containing the specular strength in the \"w\" component, and the half-vector/reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared registers created by the compiler.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate modulateSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\n\t\tcode = \"dp3 \" + targetReg + \".y, \" + sharedRegisters.viewDirFragment + \".xyz, \" + (this._incidentLight? targetReg : sharedRegisters.normalFragment) + \".xyz\\n\" +   // dot(V, H)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // base = 1-dot(V, H)\n\t\t\t\"pow \" + targetReg + \".x, \" + targetReg + \".y, \" + this._dataReg + \".y\\n\" +             // exp = pow(base, 5)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // 1 - exp\n\t\t\t\"mul \" + targetReg + \".y, \" + this._dataReg + \".x, \" + targetReg + \".y\\n\" +             // f0*(1 - exp)\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".x, \" + targetReg + \".y\\n\" +          // exp + f0*(1 - exp)\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\n\t\treturn code;\n\t}\n\n}\n\nexport default SpecularFresnelMethod;",
    "import LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport SpecularBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\";\n\n/**\n * SpecularPhongMethod provides a specular method that provides Phong highlights.\n */\nclass SpecularPhongMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularPhongMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement =sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement =sharedRegisters.normalFragment;\n\n\t\t// phong model\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \", \" + normalReg + \"\\n\" + // sca1 = light.normal\n\n\t\t\t//find the reflected light vector R\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" + // sca1 = sca1*2\n\t\t\t\"mul \" + t + \".xyz, \" + normalReg + \", \" + t + \".w\\n\" + // vec1 = normal*sca1\n\t\t\t\"sub \" + t + \".xyz, \" + t + \", \" + lightDirReg + \"\\n\" + // vec1 = vec1 - light (light vector is negative)\n\n\t\t\t//smooth the edge as incidence angle approaches 90\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" +sharedRegisters.commons + \".w\\n\" + // sca1 = sca1 + smoothtep;\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\" + // sca1 range 0 - 1\n\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + t + \".w\\n\" + // vec1 = vec1*sca1\n\n\t\t\t//find the dot product between R and V\n\t\t\t\"dp3 \" + t + \".w, \" + t + \", \" + viewDirReg + \"\\n\" + // sca1 = vec1.view\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport default SpecularPhongMethod;",
    "export {default as AmbientBasicMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\";\nexport {default as AmbientEnvMapMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod\";\nexport {default as CurveBasicMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/CurveBasicMethod\";\nexport {default as DiffuseBasicMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\";\nexport {default as DiffuseCelMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseCelMethod\";\nexport {default as DiffuseCompositeMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\";\nexport {default as DiffuseDepthMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseDepthMethod\";\nexport {default as DiffuseGradientMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseGradientMethod\";\nexport {default as DiffuseLightMapMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod\";\nexport {default as DiffuseSubSurfaceMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod\";\nexport {default as DiffuseWrapMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseWrapMethod\";\nexport {default as EffectAlphaMaskMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod\";\nexport {default as EffectColorMatrixMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod\";\nexport {default as EffectColorTransformMethod}\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\";\nexport {default as EffectEnvMapMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectEnvMapMethod\";\nexport {default as EffectFogMethod}\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectFogMethod\";\nexport {default as EffectFresnelEnvMapMethod}\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod\";\nexport {default as EffectLightMapMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectLightMapMethod\";\nexport {default as EffectMethodBase}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectMethodBase\";\nexport {default as EffectRefractionEnvMapMethod}\tfrom \"awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod\";\nexport {default as EffectRimLightMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectRimLightMethod\";\nexport {default as LightingMethodBase}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/LightingMethodBase\";\nexport {default as NormalBasicMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/NormalBasicMethod\";\nexport {default as NormalHeightMapMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/NormalHeightMapMethod\";\nexport {default as NormalSimpleWaterMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod\";\nexport {default as ShadingMethodBase}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadingMethodBase\";\nexport {default as ShadowCascadeMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowCascadeMethod\";\nexport {default as ShadowDitheredMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowDitheredMethod\";\nexport {default as ShadowFilteredMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowFilteredMethod\";\nexport {default as ShadowHardMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowHardMethod\";\nexport {default as ShadowMapMethodBase}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\";\nexport {default as ShadowMethodBase}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowMethodBase\";\nexport {default as ShadowNearMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowNearMethod\";\nexport {default as ShadowSoftMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowSoftMethod\";\nexport {default as SpecularAnisotropicMethod}\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod\";\nexport {default as SpecularBasicMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\";\nexport {default as SpecularCelMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularCelMethod\";\nexport {default as SpecularCompositeMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\";\nexport {default as SpecularFresnelMethod}\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularFresnelMethod\";\nexport {default as SpecularPhongMethod}\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularPhongMethod\";",
    "import BlendMode\t\t\t\t\t\tfrom \"awayjs-core/lib/image/BlendMode\";\nimport AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\n\nimport StaticLightPicker\t\t\t\tfrom \"awayjs-display/lib/materials/lightpickers/StaticLightPicker\";\n\nimport ContextGLCompareMode\t\t\t\tfrom \"awayjs-stagegl/lib/base/ContextGLCompareMode\";\n\nimport IElementsClassGL\t\t\t\t\tfrom \"awayjs-renderergl/lib/elements/IElementsClassGL\";\nimport GL_SurfaceBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/GL_SurfaceBase\";\nimport SurfacePool\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/SurfacePool\";\n\nimport MethodMaterial\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/MethodMaterial\";\nimport MethodMaterialMode\t\t\t\tfrom \"awayjs-methodmaterials/lib/MethodMaterialMode\";\nimport MethodPassMode\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\";\nimport MethodPass\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\";\nimport EffectMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectMethodBase\";\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass GL_MethodMaterialSurface extends GL_SurfaceBase\n{\n\tprivate _material:MethodMaterial;\n\tprivate _pass:MethodPass;\n\tprivate _casterLightPass:MethodPass;\n\tprivate _nonCasterLightPasses:Array<MethodPass>;\n\t\n\t/**\n\t * The maximum total number of lights provided by the light picker.\n\t */\n\tprivate get numLights():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights + this._material.lightPicker.numCastingDirectionalLights + this._material.lightPicker.numCastingPointLights : 0;\n\t}\n\n\t/**\n\t * The amount of lights that don't cast shadows.\n\t */\n\tprivate get numNonCasters():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights : 0;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(material:MethodMaterial, elementsClass:IElementsClassGL, pool:SurfacePool)\n\t{\n\t\tsuper(material, elementsClass, pool);\n\n\t\tthis._material = material;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pUpdateRender()\n\t{\n\t\tsuper._pUpdateRender();\n\n\t\tthis.initPasses();\n\n\t\tthis.setBlendAndCompareModes();\n\n\t\tthis._pClearPasses();\n\n\t\tif (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this._casterLightPass)\n\t\t\t\tthis._pAddPass(this._casterLightPass);\n\n\t\t\tif (this._nonCasterLightPasses)\n\t\t\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\t\t\tthis._pAddPass(this._nonCasterLightPasses[i]);\n\t\t}\n\n\t\tif (this._pass)\n\t\t\tthis._pAddPass(this._pass);\n\t}\n\n\t/**\n\t * Initializes all the passes and their dependent passes.\n\t */\n\tprivate initPasses()\n\t{\n\t\t// let the effects pass handle everything if there are no lights, when there are effect methods applied\n\t\t// after shading, or when the material mode is single pass.\n\t\tif (this.numLights == 0 || this._material.numEffectMethods > 0 || this._material.mode == MethodMaterialMode.SINGLE_PASS)\n\t\t\tthis.initEffectPass();\n\t\telse if (this._pass)\n\t\t\tthis.removeEffectPass();\n\n\t\t// only use a caster light pass if shadows need to be rendered\n\t\tif (this._material.shadowMethod && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initCasterLightPass();\n\t\telse if (this._casterLightPass)\n\t\t\tthis.removeCasterLightPass();\n\n\t\t// only use non caster light passes if there are lights that don't cast\n\t\tif (this.numNonCasters > 0 && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initNonCasterLightPasses();\n\t\telse if (this._nonCasterLightPasses)\n\t\t\tthis.removeNonCasterLightPasses();\n\t}\n\n\t/**\n\t * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.\n\t */\n\tprivate setBlendAndCompareModes()\n\t{\n\t\tvar forceSeparateMVP:boolean = Boolean(this._casterLightPass || this._pass);\n\n\t\t// caster light pass is always first if it exists, hence it uses normal blending\n\t\tif (this._casterLightPass) {\n\t\t\tthis._casterLightPass.forceSeparateMVP = forceSeparateMVP;\n\t\t\tthis._casterLightPass.shader.setBlendMode(BlendMode.NORMAL);\n\t\t\tthis._casterLightPass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\n\t\tif (this._nonCasterLightPasses) {\n\t\t\tvar firstAdditiveIndex:number = 0;\n\n\t\t\t// if there's no caster light pass, the first non caster light pass will be the first\n\t\t\t// and should use normal blending\n\t\t\tif (!this._casterLightPass) {\n\t\t\t\tthis._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[0].shader.setBlendMode(BlendMode.NORMAL);\n\t\t\t\tthis._nonCasterLightPasses[0].shader.depthCompareMode = this._material.depthCompareMode;\n\t\t\t\tfirstAdditiveIndex = 1;\n\t\t\t}\n\n\t\t\t// all lighting passes following the first light pass should use additive blending\n\t\t\tfor (var i:number = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {\n\t\t\t\tthis._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[i].shader.setBlendMode(BlendMode.ADD);\n\t\t\t\tthis._nonCasterLightPasses[i].shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t}\n\t\t}\n\n\t\tif (this._casterLightPass || this._nonCasterLightPasses) {\n\t\t\t//cannot be blended by blendmode property if multipass enabled\n\t\t\tthis._pRequiresBlending = false;\n\n\t\t\t// there are light passes, so this should be blended in\n\t\t\tif (this._pass) {\n\t\t\t\tthis._pass.mode = MethodPassMode.EFFECTS;\n\t\t\t\tthis._pass.forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._pass.shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t\tthis._pass.shader.setBlendMode(BlendMode.LAYER);\n\t\t\t}\n\n\t\t} else if (this._pass) {\n\t\t\tthis._pRequiresBlending = (this._material.blendMode != BlendMode.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));\n\t\t\t// effects pass is the only pass, so it should just blend normally\n\t\t\tthis._pass.mode = MethodPassMode.SUPER_SHADER;\n\t\t\tthis._pass.preserveAlpha = this._pRequiresBlending;\n\t\t\tthis._pass.forceSeparateMVP = false;\n\t\t\tthis._pass.colorTransform = this._material.colorTransform;\n\t\t\tthis._pass.shader.setBlendMode((this._material.blendMode == BlendMode.NORMAL && this._pRequiresBlending)? BlendMode.LAYER : this._material.blendMode);\n\t\t\tthis._pass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\t}\n\n\tprivate initCasterLightPass()\n\t{\n\n\t\tif (this._casterLightPass == null)\n\t\t\tthis._casterLightPass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._elementsClass, this._stage);\n\n\t\tthis._casterLightPass.lightPicker = new StaticLightPicker([this._material.shadowMethod.castingLight]);\n\t\tthis._casterLightPass.shadowMethod = this._material.shadowMethod;\n\t\tthis._casterLightPass.diffuseMethod = this._material.diffuseMethod;\n\t\tthis._casterLightPass.ambientMethod = this._material.ambientMethod;\n\t\tthis._casterLightPass.normalMethod = this._material.normalMethod;\n\t\tthis._casterLightPass.specularMethod = this._material.specularMethod;\n\t}\n\n\tprivate removeCasterLightPass()\n\t{\n\t\tthis._casterLightPass.dispose();\n\t\tthis._pRemovePass(this._casterLightPass);\n\t\tthis._casterLightPass = null;\n\t}\n\n\tprivate initNonCasterLightPasses()\n\t{\n\t\tthis.removeNonCasterLightPasses();\n\t\tvar pass:MethodPass;\n\t\tvar numDirLights:number = this._material.lightPicker.numDirectionalLights;\n\t\tvar numPointLights:number = this._material.lightPicker.numPointLights;\n\t\tvar numLightProbes:number = this._material.lightPicker.numLightProbes;\n\t\tvar dirLightOffset:number = 0;\n\t\tvar pointLightOffset:number = 0;\n\t\tvar probeOffset:number = 0;\n\n\t\tif (!this._casterLightPass) {\n\t\t\tnumDirLights += this._material.lightPicker.numCastingDirectionalLights;\n\t\t\tnumPointLights += this._material.lightPicker.numCastingPointLights;\n\t\t}\n\n\t\tthis._nonCasterLightPasses = new Array<MethodPass>();\n\n\t\twhile (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {\n\t\t\tpass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._elementsClass, this._stage);\n\t\t\tpass.includeCasters = this._material.shadowMethod == null;\n\t\t\tpass.directionalLightsOffset = dirLightOffset;\n\t\t\tpass.pointLightsOffset = pointLightOffset;\n\t\t\tpass.lightProbesOffset = probeOffset;\n\t\t\tpass.lightPicker = this._material.lightPicker;\n\t\t\tpass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tpass.ambientMethod = this._material.ambientMethod;\n\t\t\tpass.normalMethod = this._material.normalMethod;\n\t\t\tpass.specularMethod = this._material.specularMethod;\n\t\t\tthis._nonCasterLightPasses.push(pass);\n\n\t\t\tdirLightOffset += pass.numDirectionalLights;\n\t\t\tpointLightOffset += pass.numPointLights;\n\t\t\tprobeOffset += pass.numLightProbes;\n\t\t}\n\t}\n\n\tprivate removeNonCasterLightPasses()\n\t{\n\t\tif (!this._nonCasterLightPasses)\n\t\t\treturn;\n\n\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\tthis._pRemovePass(this._nonCasterLightPasses[i]);\n\n\t\tthis._nonCasterLightPasses = null;\n\t}\n\n\tprivate removeEffectPass()\n\t{\n\t\tif (this._pass.ambientMethod != this._material.ambientMethod)\n\t\t\tthis._pass.ambientMethod.dispose();\n\n\t\tif (this._pass.diffuseMethod != this._material.diffuseMethod)\n\t\t\tthis._pass.diffuseMethod.dispose();\n\n\t\tif (this._pass.specularMethod != this._material.specularMethod)\n\t\t\tthis._pass.specularMethod.dispose();\n\n\t\tif (this._pass.normalMethod != this._material.normalMethod)\n\t\t\tthis._pass.normalMethod.dispose();\n\n\t\tthis._pRemovePass(this._pass);\n\t\tthis._pass = null;\n\t}\n\n\tprivate initEffectPass()\n\t{\n\t\tif (this._pass == null)\n\t\t\tthis._pass = new MethodPass(MethodPassMode.SUPER_SHADER, this, this._material, this._elementsClass, this._stage);\n\n\t\tif (this._material.mode == MethodMaterialMode.SINGLE_PASS) {\n\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\tthis._pass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tthis._pass.specularMethod = this._material.specularMethod;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t\tthis._pass.shadowMethod = this._material.shadowMethod;\n\t\t} else if (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this.numLights == 0) {\n\t\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\t} else {\n\t\t\t\tthis._pass.ambientMethod = null;\n\t\t\t}\n\n\t\t\tthis._pass.preserveAlpha = false;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t}\n\n\t\t//update effect methods\n\t\tvar i:number = 0;\n\t\tvar effectMethod:EffectMethodBase;\n\t\tvar len:number = Math.max(this._material.numEffectMethods, this._pass.numEffectMethods);\n\n\t\twhile (i < len) {\n\t\t\teffectMethod = this._material.getEffectMethodAt(i);\n\t\t\tif (effectMethod != this._pass.getEffectMethodAt(i)) {\n\t\t\t\tthis._pass.removeEffectMethodAt(i);\n\n\t\t\t\tif (effectMethod != null) {\n\t\t\t\t\tif (i < this._pass.numEffectMethods)\n\t\t\t\t\t\tthis._pass.addEffectMethodAt(effectMethod, i);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis._pass.addEffectMethod(effectMethod);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic onClear(event:AssetEvent)\n\t{\n\t\tsuper.onClear(event);\n\n\t\t//TODO\n\t}\n}\n\nexport default GL_MethodMaterialSurface;",
    "class PassMode\n{\n\t/**\n\t *\n\t */\n\tpublic static EFFECTS:number = 0x01;\n\n\t/**\n\t *\n\t */\n\tpublic static LIGHTING:number = 0x02;\n\n\t/**\n\t *\n\t */\n\tpublic static SUPER_SHADER:number = 0x03;\n}\n\nexport default PassMode;",
    "import ColorTransform\t\t\t\t\tfrom \"awayjs-core/lib/geom/ColorTransform\";\nimport Matrix\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Matrix\";\nimport Matrix3D\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Matrix3D\";\nimport Matrix3DUtils\t\t\t\t\tfrom \"awayjs-core/lib/geom/Matrix3DUtils\";\nimport Vector3D\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Vector3D\";\nimport AbstractMethodError\t\t\t\tfrom \"awayjs-core/lib/errors/AbstractMethodError\";\nimport AssetEvent\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\nimport MaterialBase\t\t\t\t\t\tfrom \"awayjs-display/lib/materials/MaterialBase\";\n\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport ISurface\t\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\nimport LightPickerBase\t\t\t\t\tfrom \"awayjs-display/lib/materials/lightpickers/LightPickerBase\";\nimport LightSources\t\t\t\t\t\tfrom \"awayjs-display/lib/materials/LightSources\";\n\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport RendererBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/RendererBase\";\nimport LightingShader\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport ShadingMethodEvent\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport ShaderRegisterElement\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport PassBase\t\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/passes/PassBase\";\nimport ILightingPass\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/passes/ILightingPass\";\nimport IElementsClassGL\t\t\t\t\tfrom \"awayjs-renderergl/lib/elements/IElementsClassGL\";\n\nimport MethodVO\t\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/data/MethodVO\";\nimport AmbientBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\";\nimport DiffuseBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\";\nimport EffectColorTransformMethod\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\";\nimport EffectMethodBase\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/EffectMethodBase\";\nimport LightingMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/LightingMethodBase\";\nimport NormalBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/NormalBasicMethod\";\nimport ShadowMapMethodBase\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\";\nimport SpecularBasicMethod\t\t\t\tfrom \"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\";\nimport MethodPassMode\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\";\nimport GL_MethodMaterialSurface\t\t\t\tfrom \"awayjs-methodmaterials/lib/surfaces/GL_MethodMaterialSurface\";\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass MethodPass extends PassBase implements ILightingPass\n{\n\tprivate _maxLights:number = 3;\n\n\tprivate _mode:number = 0x03;\n\tprivate _material:MaterialBase;\n\tprivate _lightPicker:LightPickerBase;\n\n\tprivate _includeCasters:boolean = true;\n\n\tpublic _iColorTransformMethodVO:MethodVO;\n\tpublic _iNormalMethodVO:MethodVO;\n\tpublic _iAmbientMethodVO:MethodVO;\n\tpublic _iShadowMethodVO:MethodVO;\n\tpublic _iDiffuseMethodVO:MethodVO;\n\tpublic _iSpecularMethodVO:MethodVO;\n\tpublic _iMethodVOs:Array<MethodVO> = new Array<MethodVO>();\n\n\tpublic _numEffectDependencies:number = 0;\n\n\tprivate _onLightsChangeDelegate:(event:AssetEvent) => void;\n\tprivate _onMethodInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\tpublic numDirectionalLights:number = 0;\n\n\tpublic numPointLights:number = 0;\n\n\tpublic numLightProbes:number = 0;\n\n\tpublic pointLightsOffset:number = 0;\n\t\n\tpublic directionalLightsOffset:number= 0;\n\t\n\tpublic lightProbesOffset:number = 0;\n\t\n\t/**\n\t *\n\t */\n\tpublic get mode():number\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:number)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\t\t\n\t\tthis._mode = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * Indicates whether or not shadow casting lights need to be included.\n\t */\n\tpublic get includeCasters():boolean\n\t{\n\t\treturn this._includeCasters;\n\t}\n\n\tpublic set includeCasters(value:boolean)\n\t{\n\t\tif (this._includeCasters == value)\n\t\t\treturn;\n\n\t\tthis._includeCasters = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * \n\t * @returns {LightPickerBase}\n\t */\n\tpublic get lightPicker():LightPickerBase\n\t{\n\t\treturn this._lightPicker;\n\t}\n\n\tpublic set lightPicker(value:LightPickerBase)\n\t{\n\t\t//if (this._lightPicker == value)\n\t\t//\treturn;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\tthis._lightPicker = value;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.addEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\tthis._updateLights();\n\t}\n\t\n\t/**\n\t * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and\n\t * compatibility for constrained mode.\n\t */\n\tpublic get enableLightFallOff():boolean\n\t{\n\t\treturn this._material.enableLightFallOff;\n\t}\n\n\t/**\n\t * Define which light source types to use for diffuse reflections. This allows choosing between regular lights\n\t * and/or light probes for diffuse reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get diffuseLightSources():number\n\t{\n\t\treturn this._material.diffuseLightSources;\n\t}\n\n\t/**\n\t * Define which light source types to use for specular reflections. This allows choosing between regular lights\n\t * and/or light probes for specular reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get specularLightSources():number\n\t{\n\t\treturn this._material.specularLightSources;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(mode:number, render:GL_MethodMaterialSurface, renderOwner:MaterialBase, elementsClass:IElementsClassGL, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, elementsClass, stage);\n\n\t\tthis._mode = mode;\n\n\t\tthis._material = renderOwner;\n\n\t\tthis._onLightsChangeDelegate = (event:AssetEvent) => this.onLightsChange(event);\n\t\t\n\t\tthis._onMethodInvalidatedDelegate = (event:ShadingMethodEvent) => this.onMethodInvalidated(event);\n\n\t\tthis.lightPicker = renderOwner.lightPicker;\n\n\t\tif (this._shader == null)\n\t\t\tthis._updateShader();\n\t}\n\n\tprivate _updateShader()\n\t{\n\t\tif ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof LightingShader)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new LightingShader(this._elementsClass, this, this._stage);\n\t\t} else if (!(this._shader instanceof ShaderBase)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new ShaderBase(this._elementsClass, this, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the unchanging constant data for this material.\n\t */\n\tpublic _iInitConstantData(shader:ShaderBase)\n\t{\n\t\tsuper._iInitConstantData(shader);\n\n\t\t//Updates method constants if they have changed.\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tthis._iMethodVOs[i].method.iInitConstants(shader, this._iMethodVOs[i]);\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this.colorTransformMethod? this.colorTransformMethod.colorTransform : null;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tif (value) {\n\t\t\tif (this.colorTransformMethod == null)\n\t\t\t\tthis.colorTransformMethod = new EffectColorTransformMethod();\n\n\t\t\tthis.colorTransformMethod.colorTransform = value;\n\n\t\t} else if (!value) {\n\t\t\tif (this.colorTransformMethod)\n\t\t\t\tthis.colorTransformMethod = null;\n\t\t}\n\t}\n\n\t/**\n\t * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransformMethod():EffectColorTransformMethod\n\t{\n\t\treturn this._iColorTransformMethodVO? <EffectColorTransformMethod> this._iColorTransformMethodVO.method : null;\n\t}\n\n\tpublic set colorTransformMethod(value:EffectColorTransformMethod)\n\t{\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iColorTransformMethodVO) {\n\t\t\tthis._removeDependency(this._iColorTransformMethodVO);\n\t\t\tthis._iColorTransformMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iColorTransformMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iColorTransformMethodVO);\n\t\t}\n\t}\n\n\tprivate _removeDependency(methodVO:MethodVO, effectsDependency:boolean = false)\n\t{\n\t\tvar index:number = this._iMethodVOs.indexOf(methodVO);\n\n\t\tif (!effectsDependency)\n\t\t\tthis._numEffectDependencies--;\n\n\t\tmethodVO.method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\t\tthis._iMethodVOs.splice(index, 1);\n\n\t\tthis.invalidate();\n\t}\n\n\tprivate _addDependency(methodVO:MethodVO, effectsDependency:boolean = false, index:number = -1)\n\t{\n\t\tmethodVO.method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\n\t\tif (effectsDependency) {\n\t\t\tif (index != -1)\n\t\t\t\tthis._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t\telse\n\t\t\t\tthis._iMethodVOs.push(methodVO);\n\t\t\tthis._numEffectDependencies++;\n\t\t} else {\n\t\t\tthis._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t}\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._addDependency(new MethodVO(method, this), true);\n\t}\n\n\t/**\n\t * The number of \"effect\" methods added to the material.\n\t */\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._numEffectDependencies;\n\t}\n\n\t/**\n\t * Queries whether a given effects method was added to the material.\n\t *\n\t * @param method The method to be queried.\n\t * @return true if the method was added to the material, false otherwise.\n\t */\n\tpublic hasEffectMethod(method:EffectMethodBase):boolean\n\t{\n\t\treturn this.getDependencyForMethod(method) != null;\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn null;\n\n\t\treturn <EffectMethodBase> this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tthis._addDependency(new MethodVO(method, this), true, index);\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tvar methodVO:MethodVO = this.getDependencyForMethod(method);\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\t/**\n\t * remove an effect method at the specified index from the material.\n\t */\n\tpublic removeEffectMethodAt(index:number)\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn;\n\n\t\tvar methodVO:MethodVO = this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies];\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\tprivate getDependencyForMethod(method:EffectMethodBase):MethodVO\n\t{\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tif (this._iMethodVOs[i].method == method)\n\t\t\t\treturn this._iMethodVOs[i];\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._iNormalMethodVO? <NormalBasicMethod> this._iNormalMethodVO.method : null;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._iNormalMethodVO && this._iNormalMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iNormalMethodVO) {\n\t\t\tthis._removeDependency(this._iNormalMethodVO);\n\t\t\tthis._iNormalMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iNormalMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iNormalMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._iAmbientMethodVO? <AmbientBasicMethod> this._iAmbientMethodVO.method : null;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iAmbientMethodVO) {\n\t\t\tthis._removeDependency(this._iAmbientMethodVO);\n\t\t\tthis._iAmbientMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iAmbientMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iAmbientMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._iShadowMethodVO? <ShadowMapMethodBase> this._iShadowMethodVO.method : null;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._iShadowMethodVO && this._iShadowMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iShadowMethodVO) {\n\t\t\tthis._removeDependency(this._iShadowMethodVO);\n\t\t\tthis._iShadowMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iShadowMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iShadowMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._iDiffuseMethodVO? <DiffuseBasicMethod> this._iDiffuseMethodVO.method : null;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iDiffuseMethodVO) {\n\t\t\tthis._removeDependency(this._iDiffuseMethodVO);\n\t\t\tthis._iDiffuseMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iDiffuseMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iDiffuseMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._iSpecularMethodVO? <SpecularBasicMethod> this._iSpecularMethodVO.method : null;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iSpecularMethodVO) {\n\t\t\tthis._removeDependency(this._iSpecularMethodVO);\n\t\t\tthis._iSpecularMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iSpecularMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iSpecularMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\twhile (this._iMethodVOs.length)\n\t\t\tthis._removeDependency(this._iMethodVOs[0]);\n\n\t\tsuper.dispose();\n\n\t\tthis._iMethodVOs = null;\n\t}\n\n\t/**\n\t * Called when any method's shader code is invalidated.\n\t */\n\tprivate onMethodInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.invalidate();\n\t}\n\n\t// RENDER LOOP\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tsuper._iActivate(camera);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iActivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param renderable\n\t * @param stage\n\t * @param camera\n\t */\n\tpublic _iRender(renderable:GL_RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tsuper._iRender(renderable, camera, viewProjection);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iSetRenderState(this._shader, methodVO, renderable, this._stage, camera);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iDeactivate()\n\t{\n\t\tsuper._iDeactivate();\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iDeactivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\tpublic _iIncludeDependencies(shader:LightingShader)\n\t{\n\t\tsuper._iIncludeDependencies(shader);\n\n\t\t//TODO: fragment animtion should be compatible with lighting pass\n\t\tshader.usesFragmentAnimation = Boolean(this._mode == MethodPassMode.SUPER_SHADER);\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending)\n\t\t\tshader.usesCommonData = true;\n\n\t\tvar i:number;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tthis.setupAndCountDependencies(shader, this._iMethodVOs[i]);\n\n\t\tvar usesTangentSpace:boolean = true;\n\n\t\tvar methodVO:MethodVO;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif ((methodVO.useMethod = methodVO.method.iIsUsed(shader)) && !methodVO.method.iUsesTangentSpace())\n\t\t\t\tusesTangentSpace = false;\n\t\t}\n\n\t\tshader.outputsNormals = this._iNormalMethodVO && this._iNormalMethodVO.useMethod;\n\t\tshader.outputsTangentNormals = shader.outputsNormals && (<NormalBasicMethod> this._iNormalMethodVO.method).iOutputsTangentNormals();\n\t\tshader.usesTangentSpace = shader.outputsTangentNormals && !shader.usesProbes && usesTangentSpace;\n\n\t\tif (!shader.usesTangentSpace) {\n\t\t\tif (shader.viewDirDependencies > 0) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t} else if (this.numPointLights > 0 && shader.usesLights) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t\tif (Boolean(this._mode & MethodPassMode.EFFECTS))\n\t\t\t\t\tshader.usesGlobalPosFragment = true;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Counts the dependencies for a given method.\n\t * @param method The method to count the dependencies for.\n\t * @param methodVO The method's data for this material.\n\t */\n\tprivate setupAndCountDependencies(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.reset();\n\n\t\tmethodVO.method.iInitVO(shader, methodVO);\n\n\t\tif (methodVO.needsProjection)\n\t\t\tshader.projectionDependencies++;\n\n\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos) {\n\n\t\t\tshader.globalPosDependencies++;\n\n\t\t\tif (methodVO.needsGlobalFragmentPos)\n\t\t\t\tshader.usesGlobalPosFragment = true;\n\n\t\t}\n\n\t\tif (methodVO.needsNormals)\n\t\t\tshader.normalDependencies++;\n\n\t\tif (methodVO.needsTangents)\n\t\t\tshader.tangentDependencies++;\n\n\t\tif (methodVO.needsView)\n\t\t\tshader.viewDirDependencies++;\n\t}\n\n\tpublic _iGetPreLightingVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)\n\t\t\tcode += this._iAmbientMethodVO.method.iGetVertexCode(shader, this._iAmbientMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += this._iDiffuseMethodVO.method.iGetVertexCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += this._iSpecularMethodVO.method.iGetVertexCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPreLightingFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {\n\t\t\tcode += this._iAmbientMethodVO.method.iGetFragmentCode(shader, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\tif (this._iAmbientMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iAmbientMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPerLightDiffuseFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, diffuseColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerLight(shader, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerLightSpecularFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, specularColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerLight(shader, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeDiffuseFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerProbe(shader, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeSpecularFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerProbe(shader, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPostLightingVertexCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetVertexCode(shader, this._iShadowMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPostLightingFragmentCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending) {\n\t\t\tcode += \"add \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"div \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \", \" + sharedRegisters.shadedTarget + \".w\\n\" +\n\t\t\t\"sub \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"sat \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \"\\n\";\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetFragmentCode(shader, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPostLightingCode(shader, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\t// resolve other dependencies as well?\n\t\t\tif (this._iDiffuseMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iDiffuseMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPostLightingCode(shader, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\t\t\tif (this._iSpecularMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\t\t\tif (this._iSpecularMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);\n\n\t\treturn code;\n\t}\n\n\n\tpublic _iGetNormalVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._iNormalMethodVO.method.iGetVertexCode(shader, this._iNormalMethodVO, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetNormalFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._iNormalMethodVO.method.iGetFragmentCode(shader, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);\n\n\t\tif (this._iNormalMethodVO.needsView)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\n\t\tif (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)\n\t\t\tregisterCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetVertexCode(shader, methodVO, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)\n\t\t\t\t\tregCache.removeVertexTempUsage(sharedReg.globalPositionVertex);\n\t\t\t}\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetVertexCode(shader, this._iColorTransformMethodVO, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar alphaReg:ShaderRegisterElement;\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\talphaReg = regCache.getFreeFragmentSingleTemp();\n\t\t\tregCache.addFragmentTempUsages(alphaReg, 1);\n\t\t\tcode += \"mov \" + alphaReg + \", \" + sharedReg.shadedTarget + \".w\\n\";\n\t\t}\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetFragmentCode(shader, methodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsNormals)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.normalFragment);\n\n\t\t\t\tif (methodVO.needsView)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.viewDirFragment);\n\n\t\t\t}\n\t\t}\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\tcode += \"mov \" + sharedReg.shadedTarget + \".w, \" + alphaReg + \"\\n\";\n\t\t\tregCache.removeFragmentTempUsage(alphaReg);\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetFragmentCode(shader, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\t/**\n\t * Indicates whether the shader uses any shadows.\n\t */\n\tpublic _iUsesShadows(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iShadowMethodVO && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesSpecular(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iSpecularMethodVO);\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesDiffuse(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iDiffuseMethodVO);\n\t}\n\n\n\tprivate onLightsChange(event:AssetEvent)\n\t{\n\t\tthis._updateLights();\n\t}\n\n\tprivate _updateLights()\n\t{\n\t\tvar numDirectionalLightsOld:number = this.numDirectionalLights;\n\t\tvar numPointLightsOld:number = this.numPointLights;\n\t\tvar numLightProbesOld:number = this.numLightProbes;\n\n\t\tif (this._lightPicker && (this._mode & MethodPassMode.LIGHTING)) {\n\t\t\tthis.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);\n\t\t\tthis.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);\n\t\t\tthis.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);\n\n\t\t\tif (this._includeCasters) {\n\t\t\t\tthis.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;\n\t\t\t\tthis.numPointLights += this._lightPicker.numCastingPointLights;\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis.numDirectionalLights = 0;\n\t\t\tthis.numPointLights = 0;\n\t\t\tthis.numLightProbes = 0;\n\t\t}\n\n\t\tif (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {\n\t\t\tthis._updateShader();\n\n\t\t\tthis.invalidate();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the amount of directional lights this material will support.\n\t * @param numDirectionalLights The maximum amount of directional lights to support.\n\t * @return The amount of directional lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumDirectionalLights(numDirectionalLights:number):number\n\t{\n\t\treturn Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);\n\t}\n\n\t/**\n\t * Calculates the amount of point lights this material will support.\n\t * @param numDirectionalLights The maximum amount of point lights to support.\n\t * @return The amount of point lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumPointLights(numPointLights:number):number\n\t{\n\t\tvar numFree:number = this._maxLights - this.numDirectionalLights;\n\t\treturn Math.min(numPointLights - this.pointLightsOffset, numFree);\n\t}\n\n\t/**\n\t * Calculates the amount of light probes this material will support.\n\t * @param numDirectionalLights The maximum amount of light probes to support.\n\t * @return The amount of light probes this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumProbes(numLightProbes:number):number\n\t{\n\t\tvar numChannels:number = 0;\n\n\t\tif ((this.specularLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\tif ((this.diffuseLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\t// 4 channels available\n\t\treturn Math.min(numLightProbes - this.lightProbesOffset, (4/numChannels) | 0);\n\t}\n}\n\nexport default MethodPass;",
    "import Image2D\t\t\t\t\t\t\tfrom \"awayjs-core/lib/image/Image2D\";\nimport Matrix3D\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Matrix3D\";\n\nimport LightBase\t\t\t\t\t\tfrom \"awayjs-display/lib/display/LightBase\";\nimport Camera\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport MaterialBase\t\t\t\t\t\tfrom \"awayjs-display/lib/materials/MaterialBase\";\nimport ISurface\t\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\nimport Single2DTexture\t\t\t\t\tfrom \"awayjs-display/lib/textures/Single2DTexture\";\nimport TextureBase\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\nimport TriangleElements\t\t\t\t\tfrom \"awayjs-display/lib/graphics/TriangleElements\";\n\nimport ContextGLDrawMode\t\t\t\tfrom \"awayjs-stagegl/lib/base/ContextGLDrawMode\";\nimport ContextGLProgramType\t\t\t\tfrom \"awayjs-stagegl/lib/base/ContextGLProgramType\";\nimport IContextGL\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/IContextGL\";\nimport Stage\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport RendererBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/RendererBase\";\nimport ShaderBase\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport ShaderRegisterCache\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport ShaderRegisterData\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport PassBase\t\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/passes/PassBase\";\nimport IElementsClassGL\t\t\t\t\tfrom \"awayjs-renderergl/lib/elements/IElementsClassGL\";\nimport GL_RenderableBase\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport GL_SurfaceBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/GL_SurfaceBase\";\nimport GL_ElementsBase\t\t\t\t\tfrom \"awayjs-renderergl/lib/elements/GL_ElementsBase\";\n\n/**\n * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point\n * of view from a light.\n */\nclass SingleObjectDepthPass extends PassBase\n{\n\tprivate _textures:Object;\n\tprivate _projections:Object;\n\tprivate _textureSize:number /*uint*/ = 512;\n\tprivate _polyOffset:Float32Array = new Float32Array([15, 0, 0, 0]);\n\tprivate _enc:Float32Array;\n\tprivate _projectionTexturesInvalid:Boolean = true;\n\n\t/**\n\t * The size of the depth map texture to render to.\n\t */\n\tpublic get textureSize():number\n\t{\n\t\treturn this._textureSize;\n\t}\n\n\tpublic set textureSize(value:number)\n\t{\n\t\tthis._textureSize = value;\n\t}\n\n\t/**\n\t * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t */\n\tpublic get polyOffset():number\n\t{\n\t\treturn this._polyOffset[0];\n\t}\n\n\tpublic set polyOffset(value:number)\n\t{\n\t\tthis._polyOffset[0] = value;\n\t}\n\n\t/**\n\t * Creates a new SingleObjectDepthPass object.\n\t */\n\tconstructor(render:GL_SurfaceBase, renderOwner:ISurface, elementsClass:IElementsClassGL, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, elementsClass, stage);\n\n\t\t//this._pNumUsedStreams = 2;\n\t\t//this._pNumUsedVertexConstants = 7;\n\t\t//this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n\t\t//\n\t\t//this._pAnimatableAttributes = Array<string>(\"va0\", \"va1\";\n\t\t//this._pAnimationTargetRegisters = Array<string>(\"vt0\", \"vt1\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t\tthis._textures = null;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the projection textures used to contain the depth renders.\n\t */\n\tprivate updateProjectionTextures()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t}\n\n\t\tthis._textures = new Object();\n\t\tthis._projections = new Object();\n\t\tthis._projectionTexturesInvalid = false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode():string\n\t{\n\t\tvar code:string;\n\t\t// offset\n\t\tcode = \"mul vt7, vt1, vc4.x\t\\n\" +\n\t\t\t\t\"add vt7, vt7, vt0\\n\" +\n\t\t\t\t\"mov vt7.w, vt0.w\\n\";\n\t\t// project\n\t\tcode += \"m44 vt2, vt7, vc0\\n\" +\n\t\t\t\t\"mov op, vt2\\n\";\n\n\t\t// perspective divide\n\t\tcode += \"div v0, vt2, vt2.w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\t// encode float -> rgba\n\t\tcode += \"mul ft0, fc0, v0.z\\n\" +\n\t\t\t\t\"frc ft0, ft0\\n\" +\n\t\t\t\t\"mul ft1, ft0.yzww, fc1\\n\" +\n\t\t\t\t\"sub ft0, ft0, ft1\\n\" +\n\t\t\t\t\"mov oc, ft0\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the depth maps rendered for this object from all lights.\n\t * @param renderableGL The renderableGL for which to retrieve the depth maps.\n\t * @param stage3DProxy The Stage3DProxy object currently used for rendering.\n\t * @return A list of depth map textures for all supported lights.\n\t */\n\tpublic _iGetDepthMap(renderableGL:GL_RenderableBase):TextureBase\n\t{\n\t\treturn this._textures[renderableGL.renderable.id];\n\t}\n\n\t/**\n\t * Retrieves the depth map projection maps for all lights.\n\t * @param renderableGL The renderableGL for which to retrieve the projection maps.\n\t * @return A list of projection maps for all supported lights.\n\t */\n\tpublic _iGetProjection(renderableGL:GL_RenderableBase):Matrix3D\n\t{\n\t\treturn this._projections[renderableGL.renderable.id];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iRender(renderableGL:GL_RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tvar matrix:Matrix3D;\n\t\tvar context:IContextGL = this._stage.context;\n\t\tvar len:number /*uint*/;\n\t\tvar light:LightBase;\n\t\tvar lights:Array<LightBase> = this._surface.lightPicker.allPickedLights;\n\t\tvar rId:number = renderableGL.renderable.id;\n\n\t\tif (!this._textures[rId])\n\t\t\tthis._textures[rId] = new Single2DTexture(new Image2D(this._textureSize, this._textureSize));\n\n\t\tif (!this._projections[rId])\n\t\t\tthis._projections[rId] = new Matrix3D();\n\n\t\tlen = lights.length;\n\n\t\t// local position = enough\n\t\tlight = lights[0];\n\n\t\tmatrix = light.iGetObjectProjectionMatrix(renderableGL.sourceEntity, camera.sceneTransform, this._projections[rId]);\n\n\t\tthis._stage.setRenderTarget(this._textures[rId], true);\n\t\tcontext.clear(1.0, 1.0, 1.0);\n\t\tcontext.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, matrix, true);\n\t\tcontext.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, this._enc, 2);\n\n\t\tvar elements:TriangleElements = <TriangleElements> renderableGL.elements;\n\t\tvar elementsGL:GL_ElementsBase = this._shader._elementsPool.getAbstraction(elements);\n\n\t\telementsGL.activateVertexBufferVO(0, elements.positions);\n\t\telementsGL.activateVertexBufferVO(1, elements.normals);\n\t\telementsGL.getIndexBufferGL().draw(ContextGLDrawMode.TRIANGLES, 0, elements.numElements);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tif (this._projectionTexturesInvalid)\n\t\t\tthis.updateProjectionTextures();\n\n\t\t// never scale\n\t\tsuper._iActivate(camera);\n\n\t\tthis._stage.context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);\n\t}\n}\n\nexport default SingleObjectDepthPass;",
    "export {default as MethodPass}\t\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\";\nexport {default as MethodPassMode}\t\t\t\t\tfrom \"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\";\nexport {default as SingleObjectDepthPass}\t\t\tfrom \"awayjs-methodmaterials/lib/surfaces/passes/SingleObjectDepthPass\";\nexport {default as GL_MethodMaterialSurface}\t\tfrom \"awayjs-methodmaterials/lib/surfaces/GL_MethodMaterialSurface\";"
  ],
  "sourceRoot": ""
}