{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "awayjs-methodmaterials/methodmaterials.ts",
    "awayjs-methodmaterials.js",
    "awayjs-methodmaterials/lib/MethodMaterialMode.ts",
    "awayjs-methodmaterials/lib/MethodMaterial.ts",
    "awayjs-methodmaterials/lib/data/MethodVO.ts",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod.ts",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod.ts",
    "awayjs-methodmaterials/lib/render/MethodMaterialRender.ts",
    "awayjs-methodmaterials/lib/render/passes/MethodPassMode.ts",
    "awayjs-methodmaterials/lib/render/passes/MethodPass.ts",
    "awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass.ts"
  ],
  "names": [
    "require",
    "e",
    "t",
    "n",
    "r",
    "s",
    "o",
    "u",
    "a",
    "i",
    "f",
    "Error",
    "code",
    "l",
    "exports",
    "call",
    "length",
    "./methodmaterials.ts",
    "module",
    "RenderPool",
    "MethodMaterial",
    "MethodMaterialRender",
    "registerAbstraction",
    "methodmaterials",
    "awayjs-methodmaterials/lib/MethodMaterial",
    "awayjs-methodmaterials/lib/render/MethodMaterialRender",
    "awayjs-renderergl/lib/render/RenderPool",
    "undefined",
    "awayjs-methodmaterials/lib/MethodMaterialMode",
    "MethodMaterialMode",
    "SINGLE_PASS",
    "MULTI_PASS",
    "__extends",
    "this",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "__",
    "constructor",
    "prototype",
    "Image2D",
    "MaterialBase",
    "Single2DTexture",
    "ContextGLCompareMode",
    "AmbientBasicMethod",
    "DiffuseBasicMethod",
    "NormalBasicMethod",
    "SpecularBasicMethod",
    "_super",
    "imageColor",
    "alpha",
    "_effectMethods",
    "Array",
    "_ambientMethod",
    "_diffuseMethod",
    "_normalMethod",
    "_specularMethod",
    "_depthCompareMode",
    "LESS_EQUAL",
    "_mode",
    "iAddOwner",
    "texture",
    "Object",
    "defineProperty",
    "get",
    "assetType",
    "enumerable",
    "configurable",
    "set",
    "value",
    "invalidate",
    "iRemoveOwner",
    "_shadowMethod",
    "addEffectMethod",
    "method",
    "push",
    "getEffectMethodAt",
    "index",
    "addEffectMethodAt",
    "splice",
    "removeEffectMethod",
    "indexOf",
    "awayjs-core/lib/image/Image2D",
    "awayjs-display/lib/materials/MaterialBase",
    "awayjs-display/lib/textures/Single2DTexture",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod",
    "awayjs-stagegl/lib/base/ContextGLCompareMode",
    "awayjs-methodmaterials/lib/data/MethodVO",
    "MethodVO",
    "pass",
    "useMethod",
    "reset",
    "iReset",
    "vertexConstantsIndex",
    "secondaryVertexConstantsIndex",
    "fragmentConstantsIndex",
    "secondaryFragmentConstantsIndex",
    "needsProjection",
    "needsView",
    "needsNormals",
    "needsTangents",
    "needsGlobalVertexPos",
    "needsGlobalFragmentPos",
    "AssetEvent",
    "ShadingMethodBase",
    "_alpha",
    "_colorR",
    "_colorG",
    "_colorB",
    "_strength",
    "iInitVO",
    "shader",
    "methodVO",
    "_texture",
    "textureGL",
    "getAbstraction",
    "uvDependencies",
    "onClear",
    "CLEAR",
    "iInitConstants",
    "_color",
    "numLights",
    "_renderOwner",
    "style",
    "color",
    "updateColor",
    "iRemoveTexture",
    "iAddTexture",
    "iInvalidateShaderProgram",
    "copyFrom",
    "m",
    "iGetFragmentCode",
    "targetReg",
    "registerCache",
    "sharedRegisters",
    "_iGetFragmentCode",
    "uvVarying",
    "alphaThreshold",
    "cutOffReg",
    "getFreeFragmentConstant",
    "ambientInputRegister",
    "iActivate",
    "stage",
    "activate",
    "_render",
    "fragmentConstantData",
    "data",
    "iSetRenderState",
    "renderable",
    "camera",
    "_setRenderState",
    "awayjs-core/lib/events/AssetEvent",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod",
    "AmbientEnvMapMethod",
    "regCache",
    "normalFragment",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod",
    "CurveBasicMethod",
    "_ambient",
    "LightingMethodBase",
    "_multiply",
    "_ambientColorR",
    "_ambientColorG",
    "_ambientColorB",
    "iIsUsed",
    "usesCommonData",
    "_ambientColor",
    "updateAmbientColor",
    "dispose",
    "diff",
    "multiply",
    "iCleanCompilationData",
    "_pTotalLightColorReg",
    "iGetFragmentPreLightingCode",
    "_pIsFirstLight",
    "addFragmentTempUsages",
    "getFreeFragmentVectorTemp",
    "iGetFragmentCodePerLight",
    "lightDirReg",
    "lightColReg",
    "commons",
    "usesLightFallOff",
    "_iModulateMethod",
    "removeFragmentTempUsage",
    "iGetFragmentCodePerProbe",
    "cubeMapReg",
    "weightRegister",
    "iGetFragmentPostLightingCode",
    "diffuseColor",
    "shadowTarget",
    "pApplyShadow",
    "ambientColorRegister",
    "diffuseInputRegister",
    "ambientR",
    "ambientG",
    "ambientB",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod",
    "DiffuseCompositeMethod",
    "DiffuseCelMethod",
    "levels",
    "baseMethod",
    "_this",
    "_smoothness",
    "clampDiffuse",
    "_levels",
    "_dataReg",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod",
    "ShadingMethodEvent",
    "modulateMethod",
    "_onShaderInvalidatedDelegate",
    "event",
    "onShaderInvalidated",
    "pBaseMethod",
    "addEventListener",
    "SHADER_INVALIDATED",
    "removeEventListener",
    "owner",
    "iDeactivate",
    "iGetVertexCode",
    "awayjs-renderergl/lib/events/ShadingMethodEvent",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod",
    "DiffuseDepthMethod",
    "temp",
    "decReg",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod",
    "DiffuseGradientMethod",
    "gradient",
    "_gradient",
    "secondaryTextureGL",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod",
    "DiffuseLightMapMethod",
    "lightMap",
    "blendMode",
    "useSecondaryUV",
    "_useSecondaryUV",
    "_lightMap",
    "secondaryUVDependencies",
    "_blendMode",
    "ADD",
    "MULTIPLY",
    "secondaryUVVarying",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod",
    "DiffuseSubSurfaceMethod",
    "depthMapSize",
    "depthMapOffset",
    "_translucency",
    "_scatterColor",
    "_scatterR",
    "_scatterG",
    "_scatterB",
    "scatterLight",
    "_scattering",
    "vertexConstantData",
    "_lightProjVarying",
    "_propReg",
    "_lightColorReg",
    "_colorReg",
    "_decReg",
    "_targetReg",
    "scatterColor",
    "lightProjection",
    "toTexRegister",
    "getFreeVertexVectorTemp",
    "getFreeVertexConstant",
    "getFreeVarying",
    "viewDirFragment",
    "_depthPass",
    "_iGetDepthMap",
    "_iGetProjection",
    "copyRawDataTo",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod",
    "DiffuseWrapMethod",
    "wrapFactor",
    "_wrapDataRegister",
    "_wrapFactor",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod",
    "EffectMethodBase",
    "EffectAlphaMaskMethod",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod",
    "EffectColorMatrixMethod",
    "matrix",
    "_matrix",
    "colorMultReg",
    "colorOffsetReg",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod",
    "EffectColorTransformMethod",
    "_colorTransform",
    "colorOffsReg",
    "inv",
    "redMultiplier",
    "greenMultiplier",
    "blueMultiplier",
    "alphaMultiplier",
    "redOffset",
    "greenOffset",
    "blueOffset",
    "alphaOffset",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod",
    "EffectEnvMapMethod",
    "envMap",
    "_envMap",
    "_mask",
    "dataRegister",
    "temp2",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod",
    "EffectFogMethod",
    "minDistance",
    "maxDistance",
    "fogColor",
    "_minDistance",
    "_maxDistance",
    "_fogColor",
    "_fogR",
    "_fogG",
    "_fogB",
    "fogData",
    "projectionFragment",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod",
    "EffectFresnelEnvMapMethod",
    "_fresnelPower",
    "_normalReflectance",
    "viewDirReg",
    "normalReg",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod",
    "EffectLightMapMethod",
    "AbstractMethodError",
    "awayjs-core/lib/errors/AbstractMethodError",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod",
    "EffectRefractionEnvMapMethod",
    "refractionIndex",
    "dispersionR",
    "dispersionG",
    "dispersionB",
    "_dispersionR",
    "_dispersionG",
    "_dispersionB",
    "_useDispersion",
    "_refractionIndex",
    "useDispersion",
    "data2",
    "refractionDir",
    "refractionColor",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod",
    "EffectRimLightMethod",
    "strength",
    "power",
    "blend",
    "_power",
    "dataRegister2",
    "MIX",
    "normalDependencies",
    "iOutputsTangentNormals",
    "bnm",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod",
    "NormalHeightMapMethod",
    "heightMap",
    "worldWidth",
    "worldHeight",
    "worldDepth",
    "_worldXYRatio",
    "_worldXZRatio",
    "image2D",
    "width",
    "height",
    "dataReg",
    "dataReg2",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod",
    "NormalSimpleWaterMethod",
    "normalMap",
    "secondaryNormalMap",
    "_water1OffsetX",
    "_water1OffsetY",
    "_water2OffsetX",
    "_water2OffsetY",
    "_secondaryNormalMap",
    "AssetBase",
    "_textures",
    "_owners",
    "_counts",
    "iUsesTangentSpace",
    "len",
    "addTexture",
    "removeTexture",
    "dispatchEvent",
    "awayjs-core/lib/library/AssetBase",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod",
    "DirectionalLight",
    "ShadowMapMethodBase",
    "ShadowCascadeMethod",
    "shadowMethodBase",
    "castingLight",
    "_baseMethod",
    "_pCastingLight",
    "_cascadeShadowMapper",
    "shadowMapper",
    "INVALIDATE",
    "onCascadeChange",
    "tempVO",
    "depthMap",
    "fragmentData",
    "vertexData",
    "_cascadeProjections",
    "_depthMapCoordVaryings",
    "initProjectionsRegs",
    "numCascades",
    "globalPositionVertex",
    "planeDistanceReg",
    "planeDistances",
    "inQuad",
    "uvCoord",
    "uvProjection",
    "_iGetCascadeFragmentCode",
    "vertexIndex",
    "depth",
    "_pEpsilon",
    "k",
    "getDepthProjections",
    "fragmentIndex",
    "_pAlpha",
    "nearPlaneDistances",
    "_iNearPlaneDistances",
    "iActivateForCascade",
    "awayjs-display/lib/entities/DirectionalLight",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod",
    "BitmapImage2D",
    "ShadowMethodBase",
    "ShadowDitheredMethod",
    "numSamples",
    "range",
    "_depthMapSize",
    "_grainUsages",
    "_grainTexture",
    "initGrainTexture",
    "_numSamples",
    "_range",
    "_grainBitmapImage2D",
    "vec",
    "step",
    "g",
    "Math",
    "random",
    "floor",
    "setArray",
    "rect",
    "_pGetPlanarFragmentCode",
    "customDataReg",
    "getSampleCode",
    "uvReg",
    "projectionReg",
    "_pDepthMapCoordReg",
    "addSample",
    "decodeRegister",
    "depthProjection",
    "targetRegister",
    "awayjs-core/lib/image/BitmapImage2D",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod",
    "ShadowFilteredMethod",
    "size",
    "depthCol",
    "predicate",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod",
    "ShadowHardMethod",
    "_pGetPointFragmentCode",
    "epsReg",
    "posReg",
    "depthSampleCol",
    "lightDir",
    "globalPositionVarying",
    "castsShadows",
    "_pShadowMapper",
    "PointLight",
    "_pUsePoint",
    "_pGetPointVertexCode",
    "pGetPlanarVertexCode",
    "depthMapProj",
    "iDepthProjection",
    "pow",
    "fallOff",
    "pos",
    "scenePosition",
    "x",
    "y",
    "z",
    "awayjs-display/lib/entities/PointLight",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod",
    "ShadowNearMethod",
    "fadeRatio",
    "_fadeRatio",
    "_nearShadowMapper",
    "epsilon",
    "getFreeFragmentSingleTemp",
    "near",
    "projection",
    "far",
    "coverageRatio",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod",
    "PoissonLookup",
    "ShadowSoftMethod",
    "_offsets",
    "getDistribution",
    "texRange",
    "offsets",
    "numRegs",
    "reg",
    "awayjs-core/lib/geom/PoissonLookup",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod",
    "SpecularAnisotropicMethod",
    "tangentVarying",
    "_pSpecularTexData",
    "_pSpecularDataRegister",
    "_gloss",
    "_iSpecularR",
    "_iSpecularG",
    "_iSpecularB",
    "updateSpecular",
    "bsm",
    "spec",
    "gloss",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod",
    "SpecularCompositeMethod",
    "SpecularCelMethod",
    "specularCutOff",
    "_specularCutOff",
    "clampSpecular",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod",
    "SpecularFresnelMethod",
    "basedOnSurface",
    "modulateSpecular",
    "_incidentLight",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod",
    "SpecularPhongMethod",
    "BlendMode",
    "StaticLightPicker",
    "RenderBase",
    "MethodPassMode",
    "MethodPass",
    "material",
    "elementsClass",
    "pool",
    "_material",
    "lightPicker",
    "numLightProbes",
    "numDirectionalLights",
    "numPointLights",
    "numCastingDirectionalLights",
    "numCastingPointLights",
    "_pUpdateRender",
    "initPasses",
    "setBlendAndCompareModes",
    "_pClearPasses",
    "mode",
    "_casterLightPass",
    "_pAddPass",
    "_nonCasterLightPasses",
    "_pass",
    "numEffectMethods",
    "initEffectPass",
    "removeEffectPass",
    "shadowMethod",
    "initCasterLightPass",
    "removeCasterLightPass",
    "numNonCasters",
    "initNonCasterLightPasses",
    "removeNonCasterLightPasses",
    "forceSeparateMVP",
    "Boolean",
    "setBlendMode",
    "NORMAL",
    "depthCompareMode",
    "firstAdditiveIndex",
    "_pRequiresBlending",
    "EFFECTS",
    "LAYER",
    "alphaBlending",
    "colorTransform",
    "SUPER_SHADER",
    "preserveAlpha",
    "LIGHTING",
    "_elementsClass",
    "_stage",
    "diffuseMethod",
    "ambientMethod",
    "normalMethod",
    "specularMethod",
    "_pRemovePass",
    "numDirLights",
    "dirLightOffset",
    "pointLightOffset",
    "probeOffset",
    "includeCasters",
    "directionalLightsOffset",
    "pointLightsOffset",
    "lightProbesOffset",
    "effectMethod",
    "max",
    "removeEffectMethodAt",
    "awayjs-core/lib/image/BlendMode",
    "awayjs-display/lib/materials/lightpickers/StaticLightPicker",
    "awayjs-methodmaterials/lib/render/passes/MethodPass",
    "awayjs-methodmaterials/lib/render/passes/MethodPassMode",
    "awayjs-renderergl/lib/render/RenderBase",
    "PassMode",
    "LightSources",
    "LightingShader",
    "ShaderBase",
    "PassBase",
    "render",
    "renderOwner",
    "_maxLights",
    "_includeCasters",
    "_iMethodVOs",
    "_numEffectDependencies",
    "_onLightsChangeDelegate",
    "onLightsChange",
    "_onMethodInvalidatedDelegate",
    "onMethodInvalidated",
    "_shader",
    "_updateShader",
    "_updateLights",
    "_lightPicker",
    "enableLightFallOff",
    "diffuseLightSources",
    "specularLightSources",
    "_iInitConstantData",
    "colorTransformMethod",
    "_iColorTransformMethodVO",
    "_removeDependency",
    "_addDependency",
    "effectsDependency",
    "hasEffectMethod",
    "getDependencyForMethod",
    "_iNormalMethodVO",
    "_iAmbientMethodVO",
    "_iShadowMethodVO",
    "_iDiffuseMethodVO",
    "_iSpecularMethodVO",
    "_iActivate",
    "_iRender",
    "viewProjection",
    "_iDeactivate",
    "_iIncludeDependencies",
    "usesFragmentAnimation",
    "useAlphaPremultiplied",
    "usesBlending",
    "setupAndCountDependencies",
    "usesTangentSpace",
    "outputsNormals",
    "outputsTangentNormals",
    "usesProbes",
    "viewDirDependencies",
    "globalPosDependencies",
    "usesLights",
    "usesGlobalPosFragment",
    "projectionDependencies",
    "tangentDependencies",
    "_iGetPreLightingVertexCode",
    "_iGetPreLightingFragmentCode",
    "shadedTarget",
    "_iGetPerLightDiffuseFragmentCode",
    "diffuseColorReg",
    "_iGetPerLightSpecularFragmentCode",
    "specularColorReg",
    "_iGetPerProbeDiffuseFragmentCode",
    "texReg",
    "weightReg",
    "_iGetPerProbeSpecularFragmentCode",
    "_iGetPostLightingVertexCode",
    "_iGetPostLightingFragmentCode",
    "_iGetNormalVertexCode",
    "_iGetNormalFragmentCode",
    "removeVertexTempUsage",
    "_iGetVertexCode",
    "sharedReg",
    "alphaReg",
    "_iUsesShadows",
    "castingDirectionalLights",
    "castingPointLights",
    "_iUsesSpecular",
    "_iUsesDiffuse",
    "numDirectionalLightsOld",
    "numPointLightsOld",
    "numLightProbesOld",
    "calculateNumDirectionalLights",
    "calculateNumPointLights",
    "calculateNumProbes",
    "min",
    "numFree",
    "numChannels",
    "PROBES",
    "awayjs-display/lib/materials/LightSources",
    "awayjs-renderergl/lib/render/passes/PassBase",
    "awayjs-renderergl/lib/shaders/LightingShader",
    "awayjs-renderergl/lib/shaders/ShaderBase",
    "awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass",
    "Matrix3D",
    "ContextGLDrawMode",
    "ContextGLProgramType",
    "SingleObjectDepthPass",
    "_textureSize",
    "_polyOffset",
    "Float32Array",
    "_projectionTexturesInvalid",
    "key",
    "updateProjectionTextures",
    "_projections",
    "renderableOwner",
    "id",
    "context",
    "light",
    "lights",
    "allPickedLights",
    "rId",
    "iGetObjectProjectionMatrix",
    "sourceEntity",
    "setRenderTarget",
    "clear",
    "setProgramConstantsFromMatrix",
    "VERTEX",
    "setProgramConstantsFromArray",
    "FRAGMENT",
    "_enc",
    "elements",
    "elementsGL",
    "_elementsPool",
    "activateVertexBufferVO",
    "positions",
    "normals",
    "getIndexBufferVO",
    "draw",
    "TRIANGLES",
    "numElements",
    "awayjs-core/lib/geom/Matrix3D",
    "awayjs-stagegl/lib/base/ContextGLDrawMode",
    "awayjs-stagegl/lib/base/ContextGLProgramType"
  ],
  "mappings": "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",
  "file": "awayjs-methodmaterials.min.js",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "import RenderPool\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderPool\");\n\nimport MethodMaterial\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterial\");\nimport MethodMaterialRender\t\t\t= require(\"awayjs-methodmaterials/lib/render/MethodMaterialRender\");\n\nRenderPool.registerAbstraction(MethodMaterialRender, MethodMaterial);\n\n\n\n/**\n *\n * static shim\n */\nclass methodmaterials\n{\n\n}\n\nexport = methodmaterials;",
    null,
    "class MethodMaterialMode\n{\n\t/**\n\t *\n\t */\n\tpublic static SINGLE_PASS:string = \"singlePass\";\n\n\t/**\n\t *\n\t */\n\tpublic static MULTI_PASS:string = \"multiPass\";\n}\n\nexport = MethodMaterialMode;",
    "﻿import Image2D\t\t\t\t\t\t= require(\"awayjs-core/lib/image/Image2D\");\n\nimport IRenderOwner\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport StaticLightPicker\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\nimport MaterialBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\nimport Single2DTexture\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ContextGLCompareMode\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\n\nimport RenderPool\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderPool\");\n\nimport MethodMaterialMode\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\nimport AmbientBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport NormalBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,\n * using material methods to define their appearance.\n */\nclass MethodMaterial extends MaterialBase\n{\n\tpublic static assetType:string = \"[materials MethodMaterial]\";\n\n\tprivate _effectMethods:Array<EffectMethodBase> = new Array<EffectMethodBase>();\n\tprivate _mode:string;\n\n\tprivate _ambientMethod:AmbientBasicMethod = new AmbientBasicMethod();\n\tprivate _shadowMethod:ShadowMapMethodBase;\n\tprivate _diffuseMethod:DiffuseBasicMethod = new DiffuseBasicMethod();\n\tprivate _normalMethod:NormalBasicMethod = new NormalBasicMethod();\n\tprivate _specularMethod:SpecularBasicMethod = new SpecularBasicMethod();\n\n\n\tprivate _depthCompareMode:string = ContextGLCompareMode.LESS_EQUAL;\n\n\t/**\n\t *\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn MethodMaterial.assetType;\n\t}\n\n\t/**\n\t * Creates a new MethodMaterial object.\n\t *\n\t * @param texture The texture used for the material's albedo color.\n\t * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.\n\t * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to false.\n\t * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to false.\n\t */\n\tconstructor(image?:Image2D, alpha?:number);\n\tconstructor(color?:number, alpha?:number);\n\tconstructor(imageColor:any = null, alpha:number = 1)\n\t{\n\t\tsuper(imageColor, alpha);\n\n\t\tthis._mode = MethodMaterialMode.SINGLE_PASS;\n\n\t\t//add default methods owners\n\t\tthis._ambientMethod.iAddOwner(this);\n\t\tthis._diffuseMethod.iAddOwner(this);\n\t\tthis._normalMethod.iAddOwner(this);\n\t\tthis._specularMethod.iAddOwner(this);\n\n\t\t//set a texture if an image is present\n\t\tif (imageColor instanceof Image2D)\n\t\t\tthis._ambientMethod.texture = new Single2DTexture();\n\t}\n\n\n\tpublic get mode():string\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:string)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\n\t\tthis._mode = value;\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The depth compare mode used to render the renderables using this material.\n\t *\n\t * @see away.stagegl.ContextGLCompareMode\n\t */\n\n\tpublic get depthCompareMode():string\n\t{\n\t\treturn this._depthCompareMode;\n\t}\n\n\tpublic set depthCompareMode(value:string)\n\t{\n\t\tif (this._depthCompareMode == value)\n\t\t\treturn;\n\n\t\tthis._depthCompareMode = value;\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The texture object to use for the ambient colour.\n\t */\n\tpublic get diffuseTexture():TextureBase\n\t{\n\t\treturn this._diffuseMethod.texture;\n\t}\n\n\tpublic set diffuseTexture(value:TextureBase)\n\t{\n\t\tthis._diffuseMethod.texture = value;\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._ambientMethod;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._ambientMethod == value)\n\t\t\treturn;\n\n\t\tif (this._ambientMethod)\n\t\t\tthis._ambientMethod.iRemoveOwner(this);\n\n\t\tthis._ambientMethod = value;\n\n\t\tif (this._ambientMethod)\n\t\t\tthis._ambientMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._shadowMethod;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._shadowMethod == value)\n\t\t\treturn;\n\n\t\tif (this._shadowMethod)\n\t\t\tthis._shadowMethod.iRemoveOwner(this);\n\n\t\tthis._shadowMethod = value;\n\n\t\tif (this._shadowMethod)\n\t\t\tthis._shadowMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._diffuseMethod;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._diffuseMethod == value)\n\t\t\treturn;\n\n\t\tif (this._diffuseMethod)\n\t\t\tthis._diffuseMethod.iRemoveOwner(this);\n\n\t\tthis._diffuseMethod = value;\n\n\t\tif (this._diffuseMethod)\n\t\t\tthis._diffuseMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._specularMethod;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._specularMethod == value)\n\t\t\treturn;\n\n\t\tif (this._specularMethod)\n\t\t\tthis._specularMethod.iRemoveOwner(this);\n\n\t\tthis._specularMethod = value;\n\n\t\tif (this._specularMethod)\n\t\t\tthis._specularMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._normalMethod;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._normalMethod == value)\n\t\t\treturn;\n\n\t\tif (this._normalMethod)\n\t\t\tthis._normalMethod.iRemoveOwner(this);\n\n\t\tthis._normalMethod = value;\n\n\t\tif (this._normalMethod)\n\t\t\tthis._normalMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._effectMethods.length;\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tmethod.iAddOwner(this);\n\n\t\tthis._effectMethods.push(method);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\treturn this._effectMethods[index];\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tmethod.iAddOwner(this);\n\n\t\tthis._effectMethods.splice(index, 0, method);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tmethod.iRemoveOwner(this);\n\n\t\tthis._effectMethods.splice(this._effectMethods.indexOf(method), 1);\n\n\t\tthis.invalidate();\n\t}\n}\n\nexport = MethodMaterial;",
    "import GL_TextureBase\t\t\t\t= require(\"awayjs-renderergl/lib/textures/GL_TextureBase\");\n\nimport MethodPass\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPass\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * MethodVO contains data for a given shader object for the use within a single material.\n * This allows shader methods to be shared across materials while their non-public state differs.\n */\nclass MethodVO\n{\n\tpublic useMethod:boolean = true;\n\n\tpublic method:ShadingMethodBase;\n\tpublic pass:MethodPass;\n\n\t// public register indices\n\tpublic textureGL:GL_TextureBase;\n\tpublic secondaryTextureGL:GL_TextureBase; // sometimes needed for composites\n\tpublic vertexConstantsIndex:number;\n\tpublic secondaryVertexConstantsIndex:number; // sometimes needed for composites\n\tpublic fragmentConstantsIndex:number;\n\tpublic secondaryFragmentConstantsIndex:number; // sometimes needed for composites\n\n\t// internal stuff for the material to know before assembling code\n\tpublic needsProjection:boolean;\n\tpublic needsView:boolean;\n\tpublic needsNormals:boolean;\n\tpublic needsTangents:boolean;\n\tpublic needsGlobalVertexPos:boolean;\n\tpublic needsGlobalFragmentPos:boolean;\n\t/**\n\t * Creates a new MethodVO object.\n\t */\n\tconstructor(method:ShadingMethodBase, pass:MethodPass)\n\t{\n\t\tthis.method = method;\n\t\tthis.pass = pass;\n\t}\n\n\t/**\n\t * Resets the values of the value object to their \"unused\" state.\n\t */\n\tpublic reset()\n\t{\n\t\tthis.method.iReset();\n\n\t\tthis.vertexConstantsIndex = -1;\n\t\tthis.secondaryVertexConstantsIndex = -1;\n\t\tthis.fragmentConstantsIndex = -1;\n\t\tthis.secondaryFragmentConstantsIndex = -1;\n\n\t\tthis.needsProjection = false;\n\t\tthis.needsView = false;\n\t\tthis.needsNormals = false;\n\t\tthis.needsTangents = false;\n\t\tthis.needsGlobalVertexPos = false;\n\t\tthis.needsGlobalFragmentPos = false;\n\t}\n}\n\nexport = MethodVO;\n",
    "import AssetEvent\t\t\t\t\t\t= require(\"awayjs-core/lib/events/AssetEvent\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass AmbientBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number;\n\tprivate _alpha:number = 1;\n\n\tpublic _texture:TextureBase;\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _strength:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, this._texture));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!methodVO.textureGL) {\n\t\t\tthis._color = shader.numLights? 0xFFFFFF : methodVO.pass._renderOwner.style.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tif (this._strength == value)\n\t\t\treturn;\n\n\t\tthis._strength = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The texture to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:AmbientBasicMethod = <AmbientBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (methodVO.textureGL) {\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tvar ambientInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (methodVO.textureGL)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._strength;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._strength;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._strength;\n\t}\n}\n\nexport = AmbientBasicMethod;",
    "import AssetEvent\t\t\t\t\t\t= require(\"awayjs-core/lib/events/AssetEvent\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\n\n/**\n * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to\n * approximate global lighting rather than lights.\n */\nclass AmbientEnvMapMethod extends AmbientBasicMethod\n{\n\t/**\n\t * Creates a new <code>AmbientEnvMapMethod</code> object.\n\t *\n\t * @param envMap The cube environment map to use for the ambient lighting.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, this._texture));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (this._texture)? methodVO.textureGL._iGetFragmentCode(targetReg, regCache, sharedRegisters, sharedRegisters.normalFragment) : \"\";\n\t}\n}\n\nexport = AmbientEnvMapMethod;",
    "import AssetEvent\t\t\t\t\t\t= require(\"awayjs-core/lib/events/AssetEvent\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass CurveBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tpublic _texture:TextureBase;\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, this._texture));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (!methodVO.textureGL) {\n\t\t\tthis._color = methodVO.pass._renderOwner.style.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The texture to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:CurveBasicMethod = <CurveBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n    /*\n    public iGeVertexCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string {\n        var code:string = \"\";\n        code = \"mov \" + sharedRegisters.uvVarying + \" \" + registerCache.uv +  \" \\n\";\n    }*/\n    public iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar ambientInputRegister:ShaderRegisterElement;\n\n\t\tif (methodVO.textureGL) {\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tambientInputRegister = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n        code = \"mov \" + targetReg + \", \" + sharedRegisters.uvVarying + \"\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (methodVO.textureGL)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\nexport = CurveBasicMethod;",
    "import AssetEvent\t\t\t\t\t\t= require(\"awayjs-core/lib/events/AssetEvent\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\n\n/**\n * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.\n */\nclass DiffuseBasicMethod extends LightingMethodBase\n{\n\tprivate _multiply:boolean = true;\n\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\n\tpublic _texture:TextureBase;\n\tprivate _ambientColor:number;\n\tprivate _ambientColorR:number = 1;\n\tprivate _ambientColorG:number = 1;\n\tprivate _ambientColorB:number = 1;\n\tprivate _color:number = 0xffffff;\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Set internally if diffuse color component multiplies or replaces the ambient color\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this._multiply;\n\t}\n\n\tpublic set multiply(value:boolean)\n\t{\n\t\tif (this._multiply == value)\n\t\t\treturn;\n\n\t\tthis._multiply = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, null));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\n\t\tif (shader.numLights > 0) {\n\t\t\tshader.usesCommonData = true;\n\t\t\tmethodVO.needsNormals = true;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tif (shader.numLights > 0) {\n\t\t\tthis._ambientColor = methodVO.pass._renderOwner.style.color;\n\t\t\tthis.updateAmbientColor();\n\t\t} else {\n\t\t\tthis._ambientColor = null;\n\t\t}\n\t}\n\n\t/**\n\t * The color of the diffuse reflection when not using a texture.\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number)\n\t{\n\t\tif (this._color == value)\n\t\t\treturn;\n\n\t\tthis._color = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The texture to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar diff:DiffuseBasicMethod = <DiffuseBasicMethod> method;\n\n\t\tthis.texture = diff.texture;\n\t\tthis.multiply = diff.multiply;\n\t\tthis.color = diff.color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pTotalLightColorReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \", \" + sharedRegisters.normalFragment + \"\\n\" +\n\t\t\t\t\"max \" + t + \".w, \" + t + \".x, \" + sharedRegisters.commons + \".y\\n\";\n\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".w, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"tex \" + t + \", \" + sharedRegisters.normalFragment + \", \" + cubeMapReg + \" <cube,linear,miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tvar diffuseColor:ShaderRegisterElement;\n\t\tvar cutOffReg:ShaderRegisterElement;\n\n\t\t// incorporate input from ambient\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += this.pApplyShadow(shader, methodVO, registerCache, sharedRegisters);\n\n\t\tregisterCache.addFragmentTempUsages(diffuseColor = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar ambientColorRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = ambientColorRegister.index*4;\n\n\t\tif (this._texture) {\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(diffuseColor, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\t\t} else {\n\t\t\tvar diffuseInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\t\tcode += \"mov \" + diffuseColor + \", \" + diffuseInputRegister + \"\\n\";\n\t\t}\n\n\t\tcode += \"sat \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\"mul \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\";\n\n\t\tif (this._multiply) {\n\t\t\tcode += \"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\";\n\t\t} else if (this._texture) {\n\t\t\tcode += \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + ambientColorRegister + \"\\n\" + // multiply target by ambient for total ambient\n\t\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" + // ambient * (1 - totalLightColor)\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; //add diffuse color and ambient color\n\t\t} else {\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" + // ambient * (1 - totalLightColor)\n\t\t\t\t\"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\" + // add diffuse color and  ambient color\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; // multiply by target which could be texture or white\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\tregisterCache.removeFragmentTempUsage(diffuseColor);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Generate the code that applies the calculated shadow to the diffuse light\n\t * @param methodVO The MethodVO object for which the compilation is currently happening.\n\t * @param regCache The register cache the compiler is currently using for the register management.\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tif (this._multiply) {\n\t\t\t\tdata[index + 4] = this._colorR*this._ambientColorR;\n\t\t\t\tdata[index + 5] = this._colorG*this._ambientColorG;\n\t\t\t\tdata[index + 6] = this._colorB*this._ambientColorB;\n\t\t\t} else {\n\t\t\t\tdata[index + 4] = this._colorR;\n\t\t\t\tdata[index + 5] = this._colorG;\n\t\t\t\tdata[index + 6] = this._colorB;\n\t\t\t}\n\t\t\tdata[index + 7] = 1;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the diffuse color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (this._color & 0xff)/0xff;\n\t}\n\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateAmbientColor()\n\t{\n\t\tthis._ambientColorR = ((this._ambientColor >> 16) & 0xff)/0xff;\n\t\tthis._ambientColorG = ((this._ambientColor >> 8) & 0xff)/0xff;\n\t\tthis._ambientColorB = (this._ambientColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\n\t\t//TODO move this to Activate (ambientR/G/B currently calc'd in render state)\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = shader.ambientR*this._ambientColorR;\n\t\tdata[index + 1] = shader.ambientG*this._ambientColorG;\n\t\tdata[index + 2] = shader.ambientB*this._ambientColorB;\n\t\tdata[index + 3] = 1;\n\t}\n}\n\nexport = DiffuseBasicMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.\n */\nclass DiffuseCelMethod extends DiffuseCompositeMethod\n{\n\tprivate _levels:number /*uint*/;\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\n\t/**\n\t * Creates a new DiffuseCelMethod object.\n\t * @param levels The amount of shadow gradations.\n\t * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.\n\t */\n\tconstructor(levels:number /*uint*/ = 3, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampDiffuse(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._levels = levels;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tdata[index + 1] = 1;\n\t\tdata[index + 2] = 0;\n\t}\n\n\t/**\n\t * The amount of shadow gradations.\n\t */\n\tpublic get levels():number /*uint*/\n\t{\n\t\treturn this._levels;\n\t}\n\n\tpublic set levels(value:number /*uint*/)\n\t{\n\t\tthis._levels = value;\n\t}\n\n\t/**\n\t * The smoothness of the edge between 2 shading levels.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = this._levels;\n\t\tdata[index + 3] = this._smoothness;\n\t}\n\n\t/**\n\t * Snaps the diffuse shading of the wrapped method to one of the levels.\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the diffuse strength in the \"w\" component.\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampDiffuse(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"frc \" + targetReg + \".z, \" + targetReg + \".w\\n\" +\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t\"mov \" + targetReg + \".x, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"rcp \" + targetReg + \".x,\" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\n\t\t\t// previous clamped strength\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".x\\n\" +\n\n\t\t\t// fract/epsilon (so 0 - epsilon will become 0 - 1)\n\t\t\t\"div \" + targetReg + \".z, \" + targetReg + \".z, \" + this._dataReg + \".w\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t// 1-z\n\t\t\t\"sub \" + targetReg + \".z, \" + this._dataReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t}\n}\n\nexport = DiffuseCelMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the\n * calculated diffuse reflection strength.\n */\nclass DiffuseCompositeMethod extends DiffuseBasicMethod\n{\n\tpublic pBaseMethod:DiffuseBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new <code>DiffuseCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.\n\t * @param baseMethod The base diffuse method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis.pBaseMethod = baseMethod || new DiffuseBasicMethod();\n\t\tthis.pBaseMethod._iModulateMethod = modulateMethod;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base diffuse method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this.pBaseMethod;\n\t}\n\n\tpublic set baseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this.pBaseMethod == value)\n\t\t\treturn;\n\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod = value;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\tpublic iAddOwner(owner:IRenderOwner)\n\t{\n\t\tsuper.iAddOwner(owner);\n\n\t\tthis.pBaseMethod.iAddOwner(owner);\n\t}\n\n\tpublic iRemoveOwner(owner:IRenderOwner)\n\t{\n\t\tsuper.iRemoveOwner(owner);\n\n\t\tthis.pBaseMethod.iRemoveOwner(owner);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this.pBaseMethod.texture;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis.pBaseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this.pBaseMethod.color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set color(value:number)\n\t{\n\t\tthis.pBaseMethod.color = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this.pBaseMethod.multiply;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set multiply(value:boolean)\n\t{\n\t\tthis.pBaseMethod.multiply = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis.pBaseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.pBaseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis.pBaseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = DiffuseCompositeMethod;",
    "import RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseDepthMethod provides a debug method to visualise depth maps\n */\nclass DiffuseDepthMethod extends DiffuseBasicMethod\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = 1.0;\n\t\tdata[index + 1] = 1/255.0;\n\t\tdata[index + 2] = 1/65025.0;\n\t\tdata[index + 3] = 1/16581375.0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement;\n\t\tvar decReg:ShaderRegisterElement;\n\n\t\tif (!this._texture)\n\t\t\tthrow new Error(\"DiffuseDepthMethod requires texture!\");\n\n\t\t// incorporate input from ambient\n\t\tif (shader.numLights > 0) {\n\t\t\tif (sharedRegisters.shadowTarget)\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t\t\tcode += \"add \" + targetReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"sat \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\t\tregisterCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);\n\t\t} else {\n\t\t\ttemp = targetReg;\n\t\t}\n\n\t\tdecReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\"dp4 \" + temp + \".x, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"mov \" + temp + \".yz, \" + temp + \".xx\t\t\t\\n\" +\n\t\t\t\"mov \" + temp + \".w, \" + decReg + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + decReg + \".xxx, \" + temp + \".xyz\\n\";\n\n\t\tif (shader.numLights == 0)\n\t\t\treturn code;\n\n\t\tcode += \"mul \" + targetReg + \".xyz, \" + temp + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mov \" + targetReg + \".w, \" + temp + \".w\\n\";\n\n\t\tif (shader.numLights > 0)\n\t\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseDepthMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient\n * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude\n * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate\n * scattered light within the skin attributing to the final colour)\n */\nclass DiffuseGradientMethod extends DiffuseBasicMethod\n{\n\tprivate _gradient:TextureBase;\n\n\t/**\n\t * Creates a new DiffuseGradientMethod object.\n\t * @param gradient A texture that contains the light colour based on the angle. This can be used to change\n\t * the light colour due to subsurface scattering when the surface faces away from the light.\n\t */\n\tconstructor(gradient:TextureBase)\n\t{\n\t\tsuper();\n\n\t\tthis._gradient = gradient;\n\n\t\tif (this._gradient)\n\t\t\tthis.iAddTexture(this._gradient);\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._gradient);\n\t}\n\n\t/**\n\t * A texture that contains the light colour based on the angle. This can be used to change the light colour\n\t * due to subsurface scattering when the surface faces away from the light.\n\t */\n\tpublic get gradient():TextureBase\n\t{\n\t\treturn this._gradient;\n\t}\n\n\tpublic set gradient(value:TextureBase)\n\t{\n\t\tif (this._gradient == value)\n\t\t\treturn;\n\n\t\tif (this._gradient)\n\t\t\tthis.iRemoveTexture(this._gradient);\n\n\t\tthis._gradient = value;\n\n\t\tif (this._gradient)\n\t\t\tthis.iAddTexture(this._gradient);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(t, registerCache, sharedRegisters, t) +\n\t\t\t//\t\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + t + \".w\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + lightColReg + \".xyz\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar t:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn \"mov \" + t + \", \" + sharedRegisters.shadowTarget + \".wwww\\n\" +\n\t\t\tmethodVO.secondaryTextureGL._iGetFragmentCode(t, regCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tif (shader.numLights > 0)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n}\n\nexport = DiffuseGradientMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse\n * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather\n * than only the diffuse lighting value.\n */\nclass DiffuseLightMapMethod extends DiffuseCompositeMethod\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t * This can be used to add pre-calculated shadows or occlusion.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t * This can be used to add pre-calculated lighting or global illumination.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new DiffuseLightMapMethod method.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t\tthis._lightMap = lightMap;\n\t\tthis.blendMode = blendMode;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see DiffuseLightMapMethod.ADD\n\t * @see DiffuseLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture containing the light map data.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iRemoveTexture(this._lightMap);\n\n\t\tthis._lightMap = value;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase DiffuseLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase DiffuseLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcode += super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n}\n\nexport = DiffuseLightMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\nimport SingleObjectDepthPass\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/SingleObjectDepthPass\");\n\n/**\n * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of\n * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.\n * It can be used for candle wax, ice, skin, ...\n */\nclass DiffuseSubSurfaceMethod extends DiffuseCompositeMethod\n{\n\tprivate _depthPass:SingleObjectDepthPass;\n\tprivate _lightProjVarying:ShaderRegisterElement;\n\tprivate _propReg:ShaderRegisterElement;\n\tprivate _scattering:number;\n\tprivate _translucency:number = 1;\n\tprivate _lightColorReg:ShaderRegisterElement;\n\tprivate _scatterColor:number /*uint*/ = 0xffffff;\n\tprivate _colorReg:ShaderRegisterElement;\n\tprivate _decReg:ShaderRegisterElement;\n\tprivate _scatterR:number = 1.0;\n\tprivate _scatterG:number = 1.0;\n\tprivate _scatterB:number = 1.0;\n\tprivate _targetReg:ShaderRegisterElement;\n\t\n\t/**\n\t * Creates a new <code>DiffuseSubSurfaceMethod</code> object.\n\t *\n\t * @param depthMapSize The size of the depth map used.\n\t * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(depthMapSize:number /*int*/ = 512, depthMapOffset:number = 15, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.pBaseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.scatterLight(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\t//this._passes = new Array<MaterialPassGLBase>();\n\t\t//this._depthPass = new SingleObjectDepthPass();\n\t\t//this._depthPass.textureSize = depthMapSize;\n\t\t//this._depthPass.polyOffset = depthMapOffset;\n\t\t//this._passes.push(this._depthPass);\n\t\tthis._scattering = 0.2;\n\t\tthis._translucency = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar data:Float32Array = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryVertexConstantsIndex;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = -.5;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\t\n\t\tdata = shader.fragmentConstantData;\n\t\tindex = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index + 3] = 1.0;\n\t\tdata[index + 4] = 1.0;\n\t\tdata[index + 5] = 1/255;\n\t\tdata[index + 6] = 1/65025;\n\t\tdata[index + 7] = 1/16581375;\n\t\tdata[index + 10] = .5;\n\t\tdata[index + 11] = -.1;\n\t}\n\t\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._lightProjVarying = null;\n\t\tthis._propReg = null;\n\t\tthis._lightColorReg = null;\n\t\tthis._colorReg = null;\n\t\tthis._decReg = null;\n\t\tthis._targetReg = null;\n\t}\n\t\n\t/**\n\t * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low\n\t * values for skin.\n\t */\n\tpublic get scattering():number\n\t{\n\t\treturn this._scattering;\n\t}\n\t\n\tpublic set scattering(value:number)\n\t{\n\t\tthis._scattering = value;\n\t}\n\t\n\t/**\n\t * The translucency of the object.\n\t */\n\tpublic get translucency():number\n\t{\n\t\treturn this._translucency;\n\t}\n\t\n\tpublic set translucency(value:number)\n\t{\n\t\tthis._translucency = value;\n\t}\n\t\n\t/**\n\t * The colour of the \"insides\" of the object, ie: the colour the light becomes after leaving the object.\n\t */\n\tpublic get scatterColor():number /*uint*/\n\t{\n\t\treturn this._scatterColor;\n\t}\n\t\n\tpublic set scatterColor(scatterColor:number /*uint*/)\n\t{\n\t\tthis._scatterColor = scatterColor;\n\t\tthis._scatterR = ((scatterColor >> 16) & 0xff)/0xff;\n\t\tthis._scatterG = ((scatterColor >> 8) & 0xff)/0xff;\n\t\tthis._scatterB = (scatterColor & 0xff)/0xff;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tvar lightProjection:ShaderRegisterElement;\n\t\tvar toTexRegister:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\t\t\n\t\ttoTexRegister = registerCache.getFreeVertexConstant();\n\t\tmethodVO.secondaryVertexConstantsIndex = toTexRegister.index*4;\n\n\t\tthis._lightProjVarying = registerCache.getFreeVarying();\n\t\tlightProjection = registerCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\t\n\t\tcode += \"m44 \" + temp + \", vt0, \" + lightProjection + \"\\n\" +\n\t\t\t\"div \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xy\\n\" +\n\t\t\t\"add \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xx\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".w, va0.w\\n\";\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._colorReg = registerCache.getFreeFragmentConstant();\n\t\tthis._decReg = registerCache.getFreeFragmentConstant();\n\t\tthis._propReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._colorReg.index*4;\n\t\t\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pIsFirstLight = true;\n\t\tthis._lightColorReg = lightColReg;\n\t\treturn super.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\t\n\t\tcode += \"mul \" + temp + \".xyz, \" + this._lightColorReg + \".xyz, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + this._colorReg + \".xyz\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t\n\t\tif (this._targetReg != sharedRegisters.viewDirFragment)\n\t\t\tregisterCache.removeFragmentTempUsage(targetReg);\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._scatterR;\n\t\tdata[index + 1] = this._scatterG;\n\t\tdata[index + 2] = this._scatterB;\n\t\tdata[index + 8] = this._scattering;\n\t\tdata[index + 9] = this._translucency;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._depthPass._iGetDepthMap(renderable));\n\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\n\t\tthis._depthPass._iGetProjection(renderable).copyRawDataTo(shader.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);\n\t}\n\t\n\t/**\n\t * Generates the code for this method\n\t */\n\tprivate scatterLight(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// only scatter first light\n\t\tif (!this._pIsFirstLight)\n\t\t\treturn \"\";\n\n\t\tthis._pIsFirstLight = false;\n\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.viewDirFragment)\n\t\t\tthis._targetReg = sharedRegisters.viewDirFragment;\n\t\telse\n\t\t\tregisterCache.addFragmentTempUsages(this._targetReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._lightProjVarying) +\n\t\t\t// reencode RGBA\n\t\t\t\"dp4 \" + targetReg + \".z, \" + temp + \", \" + this._decReg + \"\\n\";\n\t\t// currentDistanceToLight - closestDistanceToLight\n\t\tcode += \"sub \" + targetReg + \".z, \" + this._lightProjVarying + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t\"sub \" + targetReg + \".z, \" + this._propReg + \".x, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".z, \" + this._propReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t// targetReg.x contains dot(lightDir, normal)\n\t\t\t// modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)\n\t\t\t\"neg \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"mul \" + this._targetReg + \".w, \" + targetReg + \".z, \" + targetReg + \".y\\n\" +\n\t\t\t\n\t\t\t// blend diffuse: d' = (1-s)*d + s*1\n\t\t\t\"sub \" + targetReg + \".y, \" + this._colorReg + \".w, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t\t\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseSubSurfaceMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be \"wrapped around\" the normally dark area, to some extent.\n * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.\n */\nclass DiffuseWrapMethod extends DiffuseBasicMethod\n{\n\tprivate _wrapDataRegister:ShaderRegisterElement;\n\tprivate _wrapFactor:number;\n\n\t/**\n\t * Creates a new DiffuseWrapMethod object.\n\t * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap\n\t */\n\tconstructor(wrapFactor:number = .5)\n\t{\n\t\tsuper();\n\n\t\tthis.wrapFactor = wrapFactor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._wrapDataRegister = null;\n\t}\n\n\t/**\n\t * A factor to indicate the amount by which the light is allowed to wrap.\n\t */\n\tpublic get wrapFactor():number\n\t{\n\t\treturn this._wrapFactor;\n\t}\n\n\tpublic set wrapFactor(value:number)\n\t{\n\t\tthis._wrapFactor = value;\n\t\tthis._wrapFactor = 1/(value + 1);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\t\tthis._wrapDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index*4;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + t + \".y, \" + t + \".x, \" + this._wrapDataRegister + \".x\\n\" +\n\t\t\t\"mul \" + t + \".y, \" + t + \".y, \" + this._wrapDataRegister + \".y\\n\" +\n\t\t\t\"sat \" + t + \".w, \" + t + \".y\\n\" +\n\t\t\t\"mul \" + t + \".xz, \" + t + \".w, \" + lightDirReg + \".wz\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, lightDirReg, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".x, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._wrapFactor;\n\t\tdata[index + 1] = 1/(this._wrapFactor + 1);\n\t}\n}\n\nexport = DiffuseWrapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used\n * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water\n * etc).\n */\nclass EffectAlphaMaskMethod extends EffectMethodBase\n{\n\tprivate _texture:TextureBase;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectAlphaMaskMethod object.\n\t *\n\t * @param texture The texture to use as the alpha mask.\n\t * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.\n\t */\n\tconstructor(texture:TextureBase, useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for\n\t * instance to tile the main texture and normal map while providing untiled alpha, for example to define the\n\t * transparency over a tiled water surface.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture to use as the alpha mask.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \".x\\n\";\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n}\n\nexport = EffectAlphaMaskMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.\n */\nclass EffectColorMatrixMethod extends EffectMethodBase\n{\n\tprivate _matrix:Array<number>;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t *\n\t * @param matrix An array of 20 items for 4 x 5 color transform.\n\t */\n\tconstructor(matrix:Array<number>)\n\t{\n\t\tsuper();\n\n\t\tif (matrix.length != 20)\n\t\t\tthrow new Error(\"Matrix length must be 20!\");\n\n\t\tthis._matrix = matrix;\n\t}\n\n\t/**\n\t * The 4 x 5 matrix to transform the color of the material.\n\t */\n\tpublic get colorMatrix():Array<number>\n\t{\n\t\treturn this._matrix;\n\t}\n\n\tpublic set colorMatrix(value:Array<number>)\n\t{\n\t\tthis._matrix = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\n\t\tvar colorOffsetReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += \"m44 \" + temp + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + temp + \", \" + colorOffsetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar matrix:Array<number> = this._matrix;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\t// r\n\t\tdata[index] = matrix[0];\n\t\tdata[index + 1] = matrix[1];\n\t\tdata[index + 2] = matrix[2];\n\t\tdata[index + 3] = matrix[3];\n\n\t\t// g\n\t\tdata[index + 4] = matrix[5];\n\t\tdata[index + 5] = matrix[6];\n\t\tdata[index + 6] = matrix[7];\n\t\tdata[index + 7] = matrix[8];\n\n\t\t// b\n\t\tdata[index + 8] = matrix[10];\n\t\tdata[index + 9] = matrix[11];\n\t\tdata[index + 10] = matrix[12];\n\t\tdata[index + 11] = matrix[13];\n\n\t\t// a\n\t\tdata[index + 12] = matrix[15];\n\t\tdata[index + 13] = matrix[16];\n\t\tdata[index + 14] = matrix[17];\n\t\tdata[index + 15] = matrix[18];\n\n\t\t// rgba offset\n\t\tdata[index + 16] = matrix[4];\n\t\tdata[index + 17] = matrix[9];\n\t\tdata[index + 18] = matrix[14];\n\t\tdata[index + 19] = matrix[19];\n\t}\n}\n\nexport = EffectColorMatrixMethod;",
    "import ColorTransform\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a\n * ColorTransform object.\n */\nclass EffectColorTransformMethod extends EffectMethodBase\n{\n\tprivate _colorTransform:ColorTransform;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this._colorTransform;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tthis._colorTransform = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar colorOffsReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\t//TODO: AGAL <> GLSL\n\n\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" + \"add \" + targetReg + \", \" + targetReg + \", \" + colorOffsReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar inv:number = 1/0xff;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\tdata[index] = this._colorTransform.redMultiplier;\n\t\tdata[index + 1] = this._colorTransform.greenMultiplier;\n\t\tdata[index + 2] = this._colorTransform.blueMultiplier;\n\t\tdata[index + 3] = this._colorTransform.alphaMultiplier;\n\t\tdata[index + 4] = this._colorTransform.redOffset*inv;\n\t\tdata[index + 5] = this._colorTransform.greenOffset*inv;\n\t\tdata[index + 6] = this._colorTransform.blueOffset*inv;\n\t\tdata[index + 7] = this._colorTransform.alphaOffset*inv;\n\n\t}\n}\n\nexport = EffectColorTransformMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.\n */\nclass EffectEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates an EffectEnvMapMethod object.\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the surface.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (value == this._mask)\n\t\t\treturn;\n\n\t\tif (this._mask)\n\t\t\tthis.iRemoveTexture(this._mask);\n\n\t\tthis._mask = value;\n\n\t\tif (this._mask)\n\t\t\tthis.iAddTexture(this._mask);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tif (this._envMap)\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._envMap);\n\n\t\tif (this._mask) {\n\t\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\t// r = I - 2(I.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + sharedRegisters.normalFragment + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" + // -.5\n\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\tif (this._mask) {\n\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + temp + \", \" + temp2 + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + dataRegister + \".x\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFogMethod provides a method to add distance-based fog to a material.\n */\nclass EffectFogMethod extends EffectMethodBase\n{\n\tprivate _minDistance:number = 0;\n\tprivate _maxDistance:number = 1000;\n\tprivate _fogColor:number /*uint*/;\n\tprivate _fogR:number;\n\tprivate _fogG:number;\n\tprivate _fogB:number;\n\n\t/**\n\t * Creates a new EffectFogMethod object.\n\t * @param minDistance The distance from which the fog starts appearing.\n\t * @param maxDistance The distance at which the fog is densest.\n\t * @param fogColor The colour of the fog.\n\t */\n\tconstructor(minDistance:number, maxDistance:number, fogColor:number /*uint*/ = 0x808080)\n\t{\n\t\tsuper();\n\t\tthis.minDistance = minDistance;\n\t\tthis.maxDistance = maxDistance;\n\t\tthis.fogColor = fogColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 6] = 0;\n\t\tdata[index + 7] = 0;\n\t}\n\n\t/**\n\t * The distance from which the fog starts appearing.\n\t */\n\tpublic get minDistance():number\n\t{\n\t\treturn this._minDistance;\n\t}\n\n\tpublic set minDistance(value:number)\n\t{\n\t\tthis._minDistance = value;\n\t}\n\n\t/**\n\t * The distance at which the fog is densest.\n\t */\n\tpublic get maxDistance():number\n\t{\n\t\treturn this._maxDistance;\n\t}\n\n\tpublic set maxDistance(value:number)\n\t{\n\t\tthis._maxDistance = value;\n\t}\n\n\t/**\n\t * The colour of the fog.\n\t */\n\tpublic get fogColor():number /*uint*/\n\t{\n\t\treturn this._fogColor;\n\t}\n\n\tpublic set fogColor(value:number/*uint*/)\n\t{\n\t\tthis._fogColor = value;\n\t\tthis._fogR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._fogG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._fogB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._fogR;\n\t\tdata[index + 1] = this._fogG;\n\t\tdata[index + 2] = this._fogB;\n\t\tdata[index + 4] = this._minDistance;\n\t\tdata[index + 5] = 1/(this._maxDistance - this._minDistance);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar fogColor:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar fogData:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\t\tmethodVO.fragmentConstantsIndex = fogColor.index*4;\n\n\t\tcode += \"sub \" + temp2 + \".w, \" + sharedRegisters.projectionFragment + \".z, \" + fogData + \".x\\n\" +\n\t\t\t\t\"mul \" + temp2 + \".w, \" + temp2 + \".w, \" + fogData + \".y\\n\" +\n\t\t\t\t\"sat \" + temp2 + \".w, \" + temp2 + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \", \" + fogColor + \", \" + targetReg + \"\\n\" + // (fogColor- col)\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + temp2 + \".w\\n\" + // (fogColor- col)*fogRatio\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\"; // fogRatio*(fogColor- col) + col\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFogMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets\n * stronger as the viewing angle becomes more grazing.\n */\nclass EffectFresnelEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = 0;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates a new <code>EffectFresnelEnvMapMethod</code> object.\n\t *\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the material.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._envMap);\n\n\t\tif (this._mask != null) {\n\t\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (this._mask == value)\n\t\t\treturn;\n\n\t\tif (this._mask)\n\t\t\tthis.iRemoveTexture(this._mask);\n\n\t\tthis._mask = value;\n\n\t\tif (this._mask)\n\t\t\tthis.iAddTexture(this._mask);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._alpha;\n\t\tdata[index + 1] = this._normalReflectance;\n\t\tdata[index + 2] = this._fresnelPower;\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\t// r = V - 2(V.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + normalReg + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + viewDirReg + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\t\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +               \t// -.5\n\t\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\t// calculate fresnel term\n\t\tcode += \"dp3 \" + viewDirReg + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +  // dot(V, H)\n\t\t\t\t\"sub \" + viewDirReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +       // base = 1-dot(V, H)\n\t\t\t\t\"pow \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + dataRegister + \".z\\n\" +       // exp = pow(base, 5)\n\t\t\t\t\"sub \" + normalReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +        // 1 - exp\n\t\t\t\t\"mul \" + normalReg + \".w, \" + dataRegister + \".y, \" + normalReg + \".w\\n\" +         // f0*(1 - exp)\n\t\t\t\t\"add \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + normalReg + \".w\\n\" +          // exp + f0*(1 - exp)\n\n\t\t\t\t// total alpha\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + dataRegister + \".x, \" + viewDirReg + \".w\\n\";\n\n\t\tif (this._mask) {\n\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + temp2 + \".x, \" + viewDirReg + \".w\\n\";\n\t\t}\n\n\t\t// blend\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + viewDirReg + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFresnelEnvMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.\n * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather\n * than the whole pixel colour.\n */\nclass EffectLightMapMethod extends EffectMethodBase\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectLightMapMethod object.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tif (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._lightMap = lightMap;\n\t\tthis._blendMode = blendMode;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureGL = shader.getAbstraction(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see EffectLightMapMethod.ADD\n\t * @see EffectLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tif (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The lightMap containing the light map.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iRemoveTexture(this._lightMap);\n\n\t\tthis._lightMap = value;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase EffectLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase EffectLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n}\n\nexport = EffectLightMapMethod;",
    "import IAsset\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\nimport AbstractMethodError\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,\n * and are in essence post-process effects on the materials.\n */\nclass EffectMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset EffectMethod]\";\n\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn EffectMethodBase.assetType;\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register that will be containing the method's output.\n\t * @private\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n}\n\nexport = EffectMethodBase;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.\n */\nclass EffectRefractionEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\n\tprivate _dispersionR:number = 0;\n\tprivate _dispersionG:number = 0;\n\tprivate _dispersionB:number = 0;\n\tprivate _useDispersion:boolean;\n\tprivate _refractionIndex:number;\n\tprivate _alpha:number = 1;\n\n\t/**\n\t * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015\n\t *\n\t * @param envMap The environment map containing the refracted scene.\n\t * @param refractionIndex The refractive index of the material.\n\t * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tconstructor(envMap:TextureBase, refractionIndex:number = .1, dispersionR:number = 0, dispersionG:number = 0, dispersionB:number = 0)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._dispersionR = dispersionR;\n\t\tthis._dispersionG = dispersionG;\n\t\tthis._dispersionB = dispersionB;\n\t\tthis._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tthis._refractionIndex = refractionIndex;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index + 4] = 1;\n\t\tdata[index + 5] = 0;\n\t\tdata[index + 7] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._envMap);\n\t}\n\n\t/**\n\t * The cube environment map to use for the refraction.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * The refractive index of the material.\n\t */\n\tpublic get refractionIndex():number\n\t{\n\t\treturn this._refractionIndex;\n\t}\n\n\tpublic set refractionIndex(value:number)\n\t{\n\t\tthis._refractionIndex = value;\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionR():number\n\t{\n\t\treturn this._dispersionR;\n\t}\n\n\tpublic set dispersionR(value:number)\n\t{\n\t\tthis._dispersionR = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionG():number\n\t{\n\t\treturn this._dispersionG;\n\t}\n\n\tpublic set dispersionG(value:number)\n\t{\n\t\tthis._dispersionG = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionB():number\n\t{\n\t\treturn this._dispersionB;\n\t}\n\n\tpublic set dispersionB(value:number)\n\t{\n\t\tthis._dispersionB = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual\n\t * material. A value of 1 will make it appear fully transparent.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\tdata[index] = this._dispersionR + this._refractionIndex;\n\n\t\tif (this._useDispersion) {\n\t\t\tdata[index + 1] = this._dispersionG + this._refractionIndex;\n\t\t\tdata[index + 2] = this._dispersionB + this._refractionIndex;\n\t\t}\n\t\tdata[index + 3] = this._alpha;\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: data2.x could use common reg, so only 1 reg is used\n\t\tvar data:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar data2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar refractionDir:ShaderRegisterElement;\n\t\tvar refractionColor:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement;\n\n\t\tmethodVO.fragmentConstantsIndex = data.index*4;\n\n\t\trefractionDir = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionDir, 1);\n\t\trefractionColor = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionColor, 1);\n\t\ttemp = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\"mul \" + temp + \".x, \" + data + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\"mul \" + refractionDir + \", \" + data + \".x, \" + viewDirReg + \"\\n\" +\n\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\tmethodVO.textureGL._iGetFragmentCode(refractionColor, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\"sub \" + refractionColor + \".w, \" + refractionColor + \".w, fc0.x\t\\n\" +\n\t\t\t\"kil \" + refractionColor + \".w\\n\";\n\n\t\tif (this._useDispersion) {\n\t\t\t// GREEN\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".y, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".y, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".y, \" + temp + \".y\\n\";\n\n\t\t\t// BLUE\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".z, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".z, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".z, \" + temp + \".z\\n\";\n\t\t}\n\n\t\tcode += \"sub \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mul \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + data + \".w\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + refractionColor + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(refractionDir);\n\t\tregisterCache.removeFragmentTempUsage(refractionColor);\n\n\t\t// restore\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRefractionEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.\n */\nclass EffectRimLightMethod extends EffectMethodBase\n{\n\tpublic static ADD:string = \"add\";\n\tpublic static MULTIPLY:string = \"multiply\";\n\tpublic static MIX:string = \"mix\";\n\n\tprivate _color:number /*uint*/;\n\tprivate _blendMode:string;\n\tprivate _colorR:number;\n\tprivate _colorG:number;\n\tprivate _colorB:number;\n\tprivate _strength:number;\n\tprivate _power:number;\n\n\t/**\n\t * Creates a new <code>EffectRimLightMethod</code> object.\n\t *\n\t * @param color The colour of the rim light.\n\t * @param strength The strength of the rim light.\n\t * @param power The power of the rim light. Higher values will result in a higher edge fall-off.\n\t * @param blend The blend mode with which to add the light to the object.\n\t */\n\tconstructor(color:number /*uint*/ = 0xffffff, strength:number = .4, power:number = 2, blend:string = \"mix\")\n\t{\n\t\tsuper();\n\n\t\tthis._blendMode = blend;\n\t\tthis._strength = strength;\n\t\tthis._power = power;\n\n\t\tthis.color = color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\n\t/**\n\t * The blend mode with which to add the light to the object.\n\t *\n\t * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.\n\t * EffectRimLightMethod.ADD adds the rim light with the material's colour.\n\t * EffectRimLightMethod.MIX provides normal alpha blending.\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The color of the rim light.\n\t */\n\tpublic get color():number /*uint*/\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number /*uint*/)\n\t{\n\t\tthis._color = value;\n\t\tthis._colorR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * The strength of the rim light.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._strength = value;\n\t}\n\n\t/**\n\t * The power of the rim light. Higher values will result in a higher edge fall-off.\n\t */\n\tpublic get power():number\n\t{\n\t\treturn this._power;\n\t}\n\n\tpublic set power(value:number)\n\t{\n\t\tthis._power = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._colorR;\n\t\tdata[index + 1] = this._colorG;\n\t\tdata[index + 2] = this._colorB;\n\t\tdata[index + 4] = this._strength;\n\t\tdata[index + 5] = this._power;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataRegister2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"sat \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"pow \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + dataRegister + \".w, \" + temp + \".x\\n\";\n\n\t\tif (this._blendMode == EffectRimLightMethod.ADD) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else {\n\t\t\tcode += \"sub \" + temp + \".xyz, \" + dataRegister + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRimLightMethod;",
    "import ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport LightingShader\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * LightingMethodBase provides an abstract base method for shading methods that uses lights.\n * Used for diffuse and specular shaders only.\n */\nclass LightingMethodBase extends ShadingMethodBase\n{\n\t/**\n\t * A method that is exposed to wrappers in case the strength needs to be controlled\n\t */\n\tpublic _iModulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string;\n\n\t/**\n\t * Creates a new LightingMethodBase.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * Get the fragment shader code that will be needed before any per-light code is added.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @private\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param lightDirReg The register containing the light direction vector.\n\t * @param lightColReg The register containing the light colour.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light probe object.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param cubeMapReg The register containing the cube map for the current probe\n\t * @param weightRegister A string representation of the register + component containing the current weight\n\t * @param regCache The register cache providing any necessary registers to the shader\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register containing the final shading output.\n\t * @private\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n}\n\nexport = LightingMethodBase;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalBasicMethod is the default method for standard tangent-space normal mapping.\n */\nclass NormalBasicMethod extends ShadingMethodBase\n{\n\tprivate _texture:TextureBase;\n\n\t/**\n\t * Creates a new NormalBasicMethod object.\n\t */\n\tconstructor(texture:TextureBase = null)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\tif (this._texture && shader.normalDependencies)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iOutputsTangentNormals():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar s:any = method;\n\t\tvar bnm:NormalBasicMethod = <NormalBasicMethod> method;\n\n\t\tif (bnm.texture != null)\n\t\t\tthis.texture = bnm.texture;\n\t}\n\n\t/**\n\t * A texture to modulate the direction of the surface for each texel (normal map). The default normal method expects\n\t * tangent-space normal maps, but others could expect object-space maps.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._texture)\n\t\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._texture)\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\n\t\tcode += \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalBasicMethod;",
    "import Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.\n */\nclass NormalHeightMapMethod extends NormalBasicMethod\n{\n\tprivate _worldXYRatio:number;\n\tprivate _worldXZRatio:number;\n\n\t/**\n\t * Creates a new NormalHeightMapMethod method.\n\t *\n\t * @param heightMap The texture containing the height data. 0 means low, 1 means high.\n\t * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.\n\t * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.\n\t * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.\n\t */\n\tconstructor(heightMap:TextureBase, worldWidth:number, worldHeight:number, worldDepth:number)\n\t{\n\t\tsuper();\n\n\t\tthis.texture = heightMap;\n\t\tthis._worldXYRatio = worldWidth/worldHeight;\n\t\tthis._worldXZRatio = worldDepth/worldHeight;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = 1/(<Single2DTexture> this.texture).image2D.width;\n\t\tdata[index + 1] = 1/(<Single2DTexture> this.texture).image2D.height;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 4] = this._worldXYRatio;\n\t\tdata[index + 5] = this._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get tangentSpace():boolean\n\t{\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tsuper.copyFrom(method);\n\n\t\tthis._worldXYRatio = (<NormalHeightMapMethod> method)._worldXYRatio;\n\t\tthis._worldXZRatio = (<NormalHeightMapMethod> method)._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode+= methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".xzzz\\n\" +\n\n\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".zyzz\\n\" +\n\n\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\n\t\t\t\"sub \" + targetReg + \".z, \" + targetReg + \".z, \" + temp + \".x\\n\" +\n\t\t\t\"mov \" + targetReg + \".y, \" + dataReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".xz, \" + targetReg + \".xz, \" + dataReg2 + \".xy\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalHeightMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\n\n/**\n * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.\n */\nclass NormalSimpleWaterMethod extends NormalBasicMethod\n{\n\tprivate _secondaryNormalMap:TextureBase;\n\tprivate _water1OffsetX:number = 0;\n\tprivate _water1OffsetY:number = 0;\n\tprivate _water2OffsetX:number = 0;\n\tprivate _water2OffsetY:number = 0;\n\n\t/**\n\t * Creates a new NormalSimpleWaterMethod object.\n\t * @param waveMap1 A normal map containing one layer of a wave structure.\n\t * @param waveMap2 A normal map containing a second layer of a wave structure.\n\t */\n\tconstructor(normalMap:TextureBase = null, secondaryNormalMap:TextureBase = null)\n\t{\n\t\tsuper(normalMap);\n\n\t\tthis._secondaryNormalMap = secondaryNormalMap;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iAddTexture(this._secondaryNormalMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = 0;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\t\t\n\t\tif (this._secondaryNormalMap) {\n\t\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._secondaryNormalMap);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the X-axis.\n\t */\n\tpublic get water1OffsetX():number\n\t{\n\t\treturn this._water1OffsetX;\n\t}\n\n\tpublic set water1OffsetX(value:number)\n\t{\n\t\tthis._water1OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the Y-axis.\n\t */\n\tpublic get water1OffsetY():number\n\t{\n\t\treturn this._water1OffsetY;\n\t}\n\n\tpublic set water1OffsetY(value:number)\n\t{\n\t\tthis._water1OffsetY = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the X-axis.\n\t */\n\tpublic get water2OffsetX():number\n\t{\n\t\treturn this._water2OffsetX;\n\t}\n\n\tpublic set water2OffsetX(value:number)\n\t{\n\t\tthis._water2OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the Y-axis.\n\t */\n\tpublic get water2OffsetY():number\n\t{\n\t\treturn this._water2OffsetY;\n\t}\n\n\tpublic set water2OffsetY(value:number)\n\t{\n\t\tthis._water2OffsetY = value;\n\t}\n\n\t/**\n\t * A second normal map that will be combined with the first to create a wave-like animation pattern.\n\t */\n\tpublic get secondaryNormalMap():TextureBase\n\t{\n\t\treturn this._secondaryNormalMap;\n\t}\n\n\tpublic set secondaryNormalMap(value:TextureBase)\n\t{\n\t\tif (this._secondaryNormalMap == value)\n\t\t\treturn;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iRemoveTexture(this._secondaryNormalMap);\n\n\t\tthis._secondaryNormalMap = value;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iAddTexture(this._secondaryNormalMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\tthis._secondaryNormalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\n\t\tdata[index + 4] = this._water1OffsetX;\n\t\tdata[index + 5] = this._water1OffsetY;\n\t\tdata[index + 6] = this._water2OffsetX;\n\t\tdata[index + 7] = this._water2OffsetY;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".xyxy\\n\";\n\n\t\tif (this.texture)\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, temp);\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".zwzw\\n\";\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp);\n\n\t\tcode +=\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\t\t\\n\" +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + dataReg + \".x\t\\n\" +\n\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\t\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\t\t\t\t\t\t\t\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalSimpleWaterMethod;",
    "import AssetBase\t\t\t\t\t= require(\"awayjs-core/lib/library/AssetBase\");\n\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderOwner\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\n\n\n/**\n * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile\n * the final shading program.\n */\nclass ShadingMethodBase extends AssetBase\n{\n\tpublic _textures:Array<TextureBase> = new Array<TextureBase>();\n\n\tpublic _owners:Array<IRenderOwner> = new Array<IRenderOwner>();\n\tpublic _counts:Array<number> = new Array<number>();\n\n\tpublic static assetType:string = \"[asset ShadingMethod]\";\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadingMethodBase.assetType;\n\t}\n\n\t/**\n\t * Create a new ShadingMethodBase object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Initializes the properties for a MethodVO, including register and texture indices.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t}\n\n\t/**\n\t * Initializes unchanging shader constants using the data from a MethodVO.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\n\t}\n\n\t/**\n\t * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iUsesTangentSpace():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Cleans up any resources used by the current object.\n\t */\n\tpublic dispose()\n\t{\n\n\t}\n\n\n\tpublic iAddOwner(owner:IRenderOwner)\n\t{\n\t\t//a method can be used more than once in the same material, so we check for this\n\t\tvar index:number = this._owners.indexOf(owner);\n\n\t\tif (index != -1) {\n\t\t\tthis._counts[index]++;\n\t\t} else {\n\t\t\tthis._owners.push(owner);\n\t\t\tthis._counts.push(1);\n\n\t\t\t//add textures\n\t\t\tvar len:number = this._textures.length;\n\t\t\tfor (var i:number = 0; i< len; i++)\n\t\t\t\towner.addTexture(this._textures[i]);\n\t\t}\n\t}\n\n\tpublic iRemoveOwner(owner:IRenderOwner)\n\t{\n\t\tvar index:number = this._owners.indexOf(owner);\n\n\t\tif (this._counts[index] != 1) {\n\t\t\tthis._counts[index]--;\n\t\t} else {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tthis._counts.splice(index, 1);\n\n\t\t\t//remove textures\n\t\t\tvar len:number = this._textures.length;\n\t\t\tfor (var i:number = 0; i< len; i++)\n\t\t\t\towner.removeTexture(this._textures[i]);\n\t\t}\n\t}\n\n\n\t/**\n\t *\n\t */\n\tpublic iAddTexture(texture:TextureBase)\n\t{\n\t\tthis._textures.push(texture);\n\n\t\tvar len:number = this._owners.length;\n\t\tfor (var i:number = 0; i < len; i++)\n\t\t\tthis._owners[i].addTexture(texture);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic iRemoveTexture(texture:TextureBase)\n\t{\n\t\tthis._textures.splice(this._textures.indexOf(texture), 1);\n\n\t\tvar len:number = this._owners.length;\n\t\tfor (var i:number = 0; i < len; i++)\n\t\t\tthis._owners[i].removeTexture(texture);\n\t}\n\n\t/**\n\t * Resets the compilation state of the method.\n\t *\n\t * @internal\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Resets the method's state for compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t}\n\n\t/**\n\t * Get the vertex shader code for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn null;\n\t}\n\n\t/**\n\t * Sets the render state for this method.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Sets the render state for a single renderable.\n\t *\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param renderable The renderable currently being rendered.\n\t * @param stage The Stage object currently used for rendering.\n\t * @param camera The camera from which the scene is currently rendered.\n\t *\n\t * @internal\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\n\t}\n\n\t/**\n\t * Clears the render state for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Marks the shader program as invalid, so it will be recompiled before the next render.\n\t *\n\t * @internal\n\t */\n\tpublic iInvalidateShaderProgram()\n\t{\n\t\tthis.dispatchEvent(new ShadingMethodEvent(ShadingMethodEvent.SHADER_INVALIDATED));\n\t}\n\n\t/**\n\t * Copies the state from a ShadingMethodBase object into the current object.\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t}\n}\n\nexport = ShadingMethodBase;",
    "import AssetEvent\t\t\t\t\t\t= require(\"awayjs-core/lib/events/AssetEvent\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport CascadeShadowMapper\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/CascadeShadowMapper\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.\n * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.\n *\n * @see away.lights.CascadeShadowMapper\n */\nclass ShadowCascadeMethod extends ShadowMapMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\tprivate _cascadeShadowMapper:CascadeShadowMapper;\n\tprivate _depthMapCoordVaryings:Array<ShaderRegisterElement>;\n\tprivate _cascadeProjections:Array<ShaderRegisterElement>;\n\n\t/**\n\t * Creates a new ShadowCascadeMethod object.\n\t *\n\t * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t */\n\tconstructor(shadowMethodBase:ShadowMethodBase)\n\t{\n\t\tsuper(shadowMethodBase.castingLight);\n\n\t\tthis._baseMethod = shadowMethodBase;\n\t\tif (!(this._pCastingLight instanceof DirectionalLight))\n\t\t\tthrow new Error(\"ShadowCascadeMethod is only compatible with DirectionalLight\");\n\n\t\tthis._cascadeShadowMapper = <CascadeShadowMapper> this._pCastingLight.shadowMapper;\n\n\t\tif (!this._cascadeShadowMapper)\n\t\t\tthrow new Error(\"ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.\");\n\n\t\tthis._cascadeShadowMapper.addEventListener(AssetEvent.INVALIDATE, (event:AssetEvent) => this.onCascadeChange(event));\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\t}\n\n\t/**\n\t * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction\n\t * with a DirectionalShadowMapper.\n\t *\n\t * @see ShadowHardMethod\n\t * @see ShadowSoftMethod\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tvar tempVO:MethodVO = new MethodVO(this._baseMethod, methodVO.pass);\n\t\tthis._baseMethod.iInitVO(shader, tempVO);\n\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = .5;\n\t\tfragmentData[index + 7] = -.5;\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tvertexData[index] = .5;\n\t\tvertexData[index + 1] = -.5;\n\t\tvertexData[index + 2] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._cascadeProjections = null;\n\t\tthis._depthMapCoordVaryings = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeVertexConstant();\n\n\t\tthis.initProjectionsRegs(registerCache);\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + this._cascadeProjections[i] + \"\\n\" +\n\t\t\t\t\"add \" + this._depthMapCoordVaryings[i] + \", \" + temp + \", \" + dataReg + \".zzwz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Creates the registers for the cascades' projection coordinates.\n\t */\n\tprivate initProjectionsRegs(registerCache:ShaderRegisterCache)\n\t{\n\t\tthis._cascadeProjections = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\t\tthis._depthMapCoordVaryings = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tthis._depthMapCoordVaryings[i] = registerCache.getFreeVarying();\n\t\t\tthis._cascadeProjections[i] = registerCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvar decReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistanceReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistances:Array<string> = Array<string>( planeDistanceReg + \".x\", planeDistanceReg + \".y\", planeDistanceReg + \".z\", planeDistanceReg + \".w\" );\n\t\tvar code:string;\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar inQuad:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(inQuad, 1);\n\t\tvar uvCoord:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvCoord, 1);\n\n\t\t// assume lowest partition is selected, will be overwritten later otherwise\n\t\tcode = \"mov \" + uvCoord + \", \" + this._depthMapCoordVaryings[numCascades - 1] + \"\\n\";\n\n\t\tfor (var i:number = numCascades - 2; i >= 0; --i) {\n\t\t\tvar uvProjection:ShaderRegisterElement = this._depthMapCoordVaryings[i];\n\n\t\t\t// calculate if in texturemap (result == 0 or 1, only 1 for a single partition)\n\t\t\tcode += \"slt \" + inQuad + \".z, \" + sharedRegisters.projectionFragment + \".z, \" + planeDistances[i] + \"\\n\"; // z = x > minX, w = y > minY\n\n\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t// linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)\n\t\t\tcode += \"sub \" + temp + \", \" + uvProjection + \", \" + uvCoord + \"\\n\" +\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + inQuad + \".z\\n\" +\n\t\t\t\t\"add \" + uvCoord + \", \" + uvCoord + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(inQuad);\n\n\t\tcode += \"div \" + uvCoord + \", \" + uvCoord + \", \" + uvCoord + \".w\\n\" +\n\t\t\t\"mul \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zw\\n\" +\n\t\t\t\"add \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zz\\n\";\n\n\t\tcode += this._baseMethod._iGetCascadeFragmentCode(shader, methodVO, decReg, uvCoord, targetReg, registerCache, sharedRegisters) +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + dataReg + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(uvCoord);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar vertexIndex:number = methodVO.vertexConstantsIndex;\n\n\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/(this._cascadeShadowMapper.depth*this._pEpsilon);\n\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvertexIndex += 4;\n\t\tfor (var k:number = 0; k < numCascades; ++k) {\n\t\t\tthis._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);\n\t\t\tvertexIndex += 16;\n\t\t}\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar fragmentIndex:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[fragmentIndex + 5] = 1 - this._pAlpha;\n\n\t\tvar nearPlaneDistances:Array<number> = this._cascadeShadowMapper._iNearPlaneDistances;\n\n\t\tfragmentIndex += 8;\n\t\tfor (var i:number = 0; i < numCascades; ++i)\n\t\t\tfragmentData[fragmentIndex + i] = nearPlaneDistances[i];\n\n\t\tthis._baseMethod.iActivateForCascade(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t}\n\n\t/**\n\t * Called when the shadow mappers cascade configuration changes.\n\t */\n\tprivate onCascadeChange(event:AssetEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowCascadeMethod;",
    "import BitmapImage2D\t\t\t\t\t= require(\"awayjs-core/lib/image/BitmapImage2D\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.\n */\nclass ShadowDitheredMethod extends ShadowMethodBase\n{\n\tprivate static _grainTexture:Single2DTexture;\n\tprivate static _grainUsages:number /*int*/;\n\tprivate static _grainBitmapImage2D:BitmapImage2D;\n\tprivate _depthMapSize:number /*int*/;\n\tprivate _range:number;\n\tprivate _numSamples:number /*int*/;\n\n\t/**\n\t * Creates a new ShadowDitheredMethod object.\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 4, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\n\t\t++ShadowDitheredMethod._grainUsages;\n\n\t\tif (!ShadowDitheredMethod._grainTexture)\n\t\t\tthis.initGrainTexture();\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tif (value < 1)\n\t\t\tvalue = 1;\n\t\telse if (value > 24)\n\t\t\tvalue = 24;\n\n\t\tif (this._numSamples == value)\n\t\t\treturn;\n\n\t\tthis._numSamples = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(ShadowDitheredMethod._grainTexture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = 1/this._numSamples;\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range*2;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value/2;\n\t}\n\n\t/**\n\t * Creates a texture containing the dithering noise texture.\n\t */\n\tprivate initGrainTexture()\n\t{\n\t\tShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D(64, 64, false);\n\t\tvar vec:Array<number> /*uint*/ = new Array<number>();\n\t\tvar len:number /*uint*/ = 4096;\n\t\tvar step:number = 1/(this._depthMapSize*this._range);\n\t\tvar r:number, g:number;\n\n\t\tfor (var i:number /*uint*/ = 0; i < len; ++i) {\n\t\t\tr = 2*(Math.random() - .5);\n\t\t\tg = 2*(Math.random() - .5);\n\t\t\tif (r < 0)\n\t\t\t\tr -= step; else\n\t\t\t\tr += step;\n\t\t\tif (g < 0)\n\t\t\t\tg -= step; else\n\t\t\t\tg += step;\n\t\t\tif (r > 1)\n\t\t\t\tr = 1; else if (r < -1)\n\t\t\t\tr = -1;\n\t\t\tif (g > 1)\n\t\t\t\tg = 1; else if (g < -1)\n\t\t\t\tg = -1;\n\t\t\tvec[i] = (Math.floor((r*.5 + .5)*0xff) << 16) | (Math.floor((g*.5 + .5)*0xff) << 8);\n\t\t}\n\n\t\tShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);\n\t\tShadowDitheredMethod._grainTexture = new Single2DTexture(ShadowDitheredMethod._grainBitmapImage2D);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (--ShadowDitheredMethod._grainUsages == 0) {\n\t\t\tShadowDitheredMethod._grainTexture.dispose();\n\t\t\tShadowDitheredMethod._grainBitmapImage2D.dispose();\n\t\t\tShadowDitheredMethod._grainTexture = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 9] = (stage.width - 1)/63;\n\t\tdata[index + 10] = (stage.height - 1)/63;\n\t\tdata[index + 11] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, customDataReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar numSamples:number /*int*/ = this._numSamples;\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar projectionReg:ShaderRegisterElement = sharedRegisters.projectionFragment;\n\n\t\tcode += \"div \" + uvReg + \", \" + projectionReg + \", \" + projectionReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".xy, \" + uvReg + \".xy, \" + customDataReg + \".yz\\n\";\n\n\t\twhile (numSamples > 0) {\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, uvReg);\n\t\t\t} else {\n\t\t\t\tcode += \"mov \" + temp + \", \" + uvReg + \".zwxy \\n\" +\n\t\t\t\t\tmethodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, temp);\n\t\t\t}\n\n\t\t\t// keep grain in uvReg.zw\n\t\t\tcode += \"sub \" + uvReg + \".zw, \" + uvReg + \".xy, fc0.xx\\n\" + // uv-.5\n\t\t\t\t\"mul \" + uvReg + \".zw, \" + uvReg + \".zw, \" + customDataReg + \".w\\n\"; // (tex unpack scale and tex scale in one)\n\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\t// first sample\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".zw, \" + this._pDepthMapCoordReg + \".xy\\n\" +\n\t\t\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t\t\t} else {\n\t\t\t\tcode += this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\t\t\t}\n\n\t\t\tif (numSamples > 4)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 1)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 5)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 2) {\n\t\t\t\tcode += \"neg \" + uvReg + \".w, \" + uvReg + \".w\\n\"; // will be rotated 90 degrees when being accessed as wz\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".wz, \" + this._pDepthMapCoordReg + \".xy\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\t\t\t}\n\n\t\t\tif (numSamples > 6)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 3)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 7)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tnumSamples -= 8;\n\t\t}\n\n\t\tregCache.removeFragmentTempUsage(temp);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\t\tcode += \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + customDataReg + \".x\\n\"; // average\n\t\treturn code;\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uvReg The uv register for the tap.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, uvReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + temp + \".z, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \".z\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = (stage.width - 1)/63;\n\t\tdata[index + 2] = (stage.height - 1)/63;\n\t\tdata[index + 3] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);\n\t}\n}\n\nexport = ShadowDitheredMethod;",
    "import DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison\n * results of neighbouring pixels.\n */\nclass ShadowFilteredMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadow\n\t */\n\tconstructor(castingLight:DirectionalLight)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = .5;\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tfragmentData[index + 9] = size;\n\t\tfragmentData[index + 10] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthCol, 1);\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tcode += \"mov \" + uvReg + \", \" + this._pDepthMapCoordReg + \"\\n\" +\n\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" + \t// (1, 0)\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mov \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".y, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".z\\n\" +\t// (0, 1)\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\t// (1, 1)\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t// recalculate fraction, since we ran out of registers :(\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + uvReg + \".w\\n\";\n\n\t\tregCache.removeFragmentTempUsage(depthCol);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = size;\n\t\tdata[index + 1] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar predicate:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(predicate, 1);\n\n\t\tcode = methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".x, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".z, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".y, \" + depthProjection + \".y, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"sub \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".y, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"mul \" + temp + \".xy, \" + depthProjection + \".xy, \" + dataReg + \".x\\n\" +\n\t\t\t\"frc \" + temp + \".xy, \" + temp + \".xy\\n\" +\n\n\t\t\t// some strange register juggling to prevent agal bugging out\n\t\t\t\"sub \" + depthProjection + \", \" + predicate + \".xyzw, \" + predicate + \".zwxy\\n\" +\n\t\t\t\"mul \" + depthProjection + \", \" + depthProjection + \", \" + temp + \".x\\n\" +\n\n\t\t\t\"add \" + predicate + \".xy, \" + predicate + \".xy, \" + depthProjection + \".zw\\n\" +\n\n\t\t\t\"sub \" + predicate + \".y, \" + predicate + \".y, \" + predicate + \".x\\n\" +\n\t\t\t\"mul \" + predicate + \".y, \" + predicate + \".y, \" + temp + \".y\\n\" +\n\t\t\t\"add \" + targetRegister + \".w, \" + predicate + \".x, \" + predicate + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(predicate);\n\t\treturn code;\n\t}\n}\n\nexport = ShadowFilteredMethod;",
    "import LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.\n */\nclass ShadowHardMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new ShadowHardMethod object.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\"; // 0 if in shadow\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar epsReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar posReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar depthSampleCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthSampleCol, 1);\n\t\tvar lightDir:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(lightDir, 1);\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += \"sub \" + lightDir + \", \" + sharedRegisters.globalPositionVarying + \", \" + posReg + \"\\n\" +\n\t\t\t\"dp3 \" + lightDir + \".w, \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\t\t\t\"mul \" + lightDir + \".w, \" + lightDir + \".w, \" + posReg + \".w\\n\" +\n\t\t\t\"nrm \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthSampleCol, regCache, sharedRegisters, lightDir) +\n\t\t\t\"dp4 \" + depthSampleCol + \".z, \" + depthSampleCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + lightDir + \".w, \" + epsReg + \".x\\n\" +    // offset by epsilon\n\n\t\t\t\"slt \" + targetReg + \".w, \" + targetReg + \".w, \" + depthSampleCol + \".z\\n\"; // 0 if in shadow\n\n\t\tregCache.removeFragmentTempUsage(lightDir);\n\t\tregCache.removeFragmentTempUsage(depthSampleCol);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + targetRegister + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t}\n}\n\nexport = ShadowHardMethod;",
    "import IAsset\t\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\n\nimport LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport ShadowMapperBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase\");\n\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * ShadowMapMethodBase provides an abstract base method for shadow map methods.\n */\nclass ShadowMapMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset ShadowMapMethod]\";\n\n\tpublic _pCastingLight:LightBase;\n\tpublic _pShadowMapper:ShadowMapperBase;\n\n\tpublic _pEpsilon:number = .02;\n\tpublic _pAlpha:number = 1;\n\n\t/**\n\t * Creates a new ShadowMapMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper();\n\t\tthis._pCastingLight = castingLight;\n\t\tcastingLight.castsShadows = true;\n\t\tthis._pShadowMapper = castingLight.shadowMapper;\n\n\t\tthis.iAddTexture(castingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadowMapMethodBase.assetType;\n\t}\n\n\t/**\n\t * The \"transparency\" of the shadows. This allows making shadows less strong.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._pAlpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._pAlpha = value;\n\t}\n\n\t/**\n\t * The light casting the shadows.\n\t */\n\tpublic get castingLight():LightBase\n\t{\n\t\treturn this._pCastingLight;\n\t}\n\n\t/**\n\t * A small value to counter floating point precision errors when comparing values in the shadow map with the\n\t * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._pEpsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._pEpsilon = value;\n\t}\n}\n\nexport = ShadowMapMethodBase;",
    "import Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport PointLight\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/PointLight\");\nimport DirectionalShadowMapper\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\n\n/**\n * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.\n */\nclass ShadowMethodBase extends ShadowMapMethodBase\n{\n\tpublic _pDepthMapCoordReg:ShaderRegisterElement;\n\tpublic _pUsePoint:boolean;\n\n\t/**\n\t * Creates a new ShadowMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tthis._pUsePoint = (castingLight instanceof PointLight);\n\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsView = true;\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsGlobalFragmentPos = this._pUsePoint;\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = 0;\n\t\tfragmentData[index + 7] = 1;\n\n\t\tif (this._pUsePoint) {\n\t\t\tfragmentData[index + 8] = 0;\n\t\t\tfragmentData[index + 9] = 0;\n\t\t\tfragmentData[index + 10] = 0;\n\t\t\tfragmentData[index + 11] = 1;\n\t\t}\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tif (index != -1) {\n\t\t\tvertexData[index] = .5;\n\t\t\tvertexData[index + 1] = .5;\n\t\t\tvertexData[index + 2] = 0.0;\n\t\t\tvertexData[index + 3] = 1.0;\n\t\t}\n\t}\n\n\t/**\n\t * Wrappers that override the vertex shader need to set this explicitly\n\t */\n\tpublic get _iDepthMapCoordReg():ShaderRegisterElement\n\t{\n\t\treturn this._pDepthMapCoordReg;\n\t}\n\n\tpublic set _iDepthMapCoordReg(value:ShaderRegisterElement)\n\t{\n\t\tthis._pDepthMapCoordReg = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pDepthMapCoordReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._pUsePoint? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters):this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a point light.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic _pGetPointVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tmethodVO.vertexConstantsIndex = -1;\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic pGetPlanarVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeVertexVectorTemp();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tvar depthMapProj:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tthis._pDepthMapCoordReg = regCache.getFreeVarying();\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\t// todo: can epsilon be applied here instead of fragment shader?\n\n\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + depthMapProj + \"\\n\" +\n\t\t\t\"div \" + temp + \", \" + temp + \", \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + dataReg + \".xy\\n\" +\n\t\t\t\"add \" + this._pDepthMapCoordReg + \", \" + temp + \", \" + dataReg + \".xxwz\\n\";\n\t\t//\"sub \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._pUsePoint? this._pGetPointFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tcode += \"add \" + targetReg + \".w, \" + targetReg + \".w, fc\" + (methodVO.fragmentConstantsIndex/4 + 1) + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a planar shadow map.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a point light.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (!this._pUsePoint)\n\t\t\t(<DirectionalShadowMapper> this._pShadowMapper).iDepthProjection.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);\n\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Gets the fragment code for combining this method with a cascaded shadow map method.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param decodeRegister The register containing the data to decode the shadow map depth value.\n\t * @param depthTexture The texture containing the shadow map.\n\t * @param depthProjection The projection of the fragment relative to the light.\n\t * @param targetRegister The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\n\t\tif (this._pUsePoint)\n\t\t\tfragmentData[index + 4] = -Math.pow(1/((<PointLight> this._pCastingLight).fallOff*this._pEpsilon), 2);\n\t\telse\n\t\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/((<DirectionalShadowMapper> this._pShadowMapper).depth*this._pEpsilon);\n\n\t\tfragmentData[index + 5] = 1 - this._pAlpha;\n\n\t\tif (this._pUsePoint) {\n\t\t\tvar pos:Vector3D = this._pCastingLight.scenePosition;\n\t\t\tfragmentData[index + 8] = pos.x;\n\t\t\tfragmentData[index + 9] = pos.y;\n\t\t\tfragmentData[index + 10] = pos.z;\n\t\t\t// used to decompress distance\n\t\t\tvar f:number = (<PointLight> this._pCastingLight).fallOff;\n\t\t\tfragmentData[index + 11] = 1/(2*f*f);\n\t\t}\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * Sets the method state for cascade shadow mapping.\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n}\n\nexport = ShadowMethodBase;",
    "import NearDirectionalShadowMapper\t\t= require(\"awayjs-display/lib/materials/shadowmappers/NearDirectionalShadowMapper\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work\n/**\n * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize\n * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.\n *\n * @see away.lights.NearDirectionalShadowMapper\n */\nclass ShadowNearMethod extends ShadowMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\n\tprivate _fadeRatio:number;\n\tprivate _nearShadowMapper:NearDirectionalShadowMapper;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new ShadowNearMethod object.\n\t * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tconstructor(baseMethod:ShadowMethodBase, fadeRatio:number = .1)\n\t{\n\t\tsuper(baseMethod.castingLight);\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod;\n\t\tthis._fadeRatio = fadeRatio;\n\t\tthis._nearShadowMapper = <NearDirectionalShadowMapper> this._pCastingLight.shadowMapper;\n\t\tif (!this._nearShadowMapper)\n\t\t\tthrow new Error(\"ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.\");\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base shadow map method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index + 2] = 0;\n\t\tfragmentData[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._baseMethod.alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._baseMethod.alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._baseMethod.epsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._baseMethod.epsilon = value;\n\t}\n\n\t/**\n\t * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tpublic get fadeRatio():number\n\t{\n\t\treturn this._fadeRatio;\n\t}\n\n\tpublic set fadeRatio(value:number)\n\t{\n\t\tthis._fadeRatio = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._baseMethod.iGetFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentSingleTemp();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"abs \" + temp + \", \" + sharedRegisters.projectionFragment + \".w\\n\" +\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + dataReg + \".x\\n\" +\n\t\t\t\"mul \" + temp + \", \" + temp + \", \" + dataReg + \".y\\n\" +\n\t\t\t\"sat \" + temp + \", \" + temp + \"\\n\" +\n\t\t\t\"sub \" + temp + \", \" + dataReg + \".w,\" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\t// todo: move this to activate (needs camera)\n\t\tvar near:number = camera.projection.near;\n\t\tvar d:number = camera.projection.far - near;\n\t\tvar maxDistance:number = this._nearShadowMapper.coverageRatio;\n\t\tvar minDistance:number = maxDistance*(1 - this._fadeRatio);\n\n\t\tmaxDistance = near + maxDistance*d;\n\t\tminDistance = near + minDistance*d;\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = minDistance;\n\t\tfragmentData[index + 1] = 1/(maxDistance - minDistance);\n\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowNearMethod;",
    "import PoissonLookup\t\t\t\t\t= require(\"awayjs-core/lib/geom/PoissonLookup\");\n\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.\n */\nclass ShadowSoftMethod extends ShadowMethodBase\n{\n\tprivate _range:number = 1;\n\tprivate _numSamples:number /*int*/;\n\tprivate _offsets:Array<number>;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 5, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tthis._numSamples = value;\n\t\t\n\t\tif (this._numSamples < 1)\n\t\t\tthis._numSamples = 1;\n\t\telse if (this._numSamples > 32)\n\t\t\tthis._numSamples = 32;\n\n\t\tthis._offsets = PoissonLookup.getDistribution(this._numSamples);\n\t\t\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1/this._numSamples;\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = .5*this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex + 10;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: move some things to super\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decReg, targetReg, regCache, sharedRegisters, dataReg);\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uv The uv register for the tap.\n\t * @param texture The texture register containing the depth map.\n\t * @param decode The register containing the depth map decoding data.\n\t * @param target The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData, uvReg:ShaderRegisterElement):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetRegister + \".w, \" + targetRegister + \".w, \" + uvReg + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = 0;\n\t\tindex += 2;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\n\t\tif (len%4 == 0) {\n\t\t\tdata[index + len] = 0;\n\t\t\tdata[index + len + 1] = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthTexture The texture register containing the depth map.\n\t * @param decodeRegister The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t * @param dataReg The register containing additional data.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData, dataReg:ShaderRegisterElement):string\n\t{\n\t\tvar code:string;\n\t\tvar uvReg:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tvar offsets:Array<string> = new Array<string>(dataReg + \".zw\");\n\t\tvar numRegs:number /*int*/ = this._numSamples >> 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < numRegs; ++i) {\n\t\t\tvar reg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\toffsets.push(reg + \".xy\");\n\t\t\toffsets.push(reg + \".zw\");\n\t\t}\n\n\t\tfor (i = 0; i < this._numSamples; ++i) {\n\t\t\tif (i == 0) {\n\t\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t\tcode = \"add \" + uvReg + \", \" + this._pDepthMapCoordReg + \", \" + dataReg + \".zwyy\\n\" +\n\t\t\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetRegister + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow;\n\t\t\t} else {\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + offsets[i] + \"\\n\" +\n\t\t\t\t\tthis.addSample(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg);\n\t\t\t}\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(uvReg);\n\n\t\tcode += \"mul \" + targetRegister + \".w, \" + targetRegister + \".w, \" + dataReg + \".x\\n\"; // average\n\n\t\treturn code;\n\t}\n}\n\nexport = ShadowSoftMethod;",
    "import LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for\n * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.\n * The tangent vectors are used as the surface groove directions.\n */\nclass SpecularAnisotropicMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularAnisotropicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsTangents = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\t// (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k\n\n\t\tcode += \"nrm \" + t + \".xyz, \" + sharedRegisters.tangentVarying + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".w, \" + t + \".xyz, \" + lightDirReg + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".z, \" + t + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\";\n\n\t\t// (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k\n\t\tcode += \"sin \" + t + \".x, \" + t + \".w\\n\" +\n\t\t\t\"sin \" + t + \".y, \" + t + \".z\\n\" +\n\t\t\t// (t.x * t.y - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"mul \" + t + \".x, \" + t + \".x, \" + t + \".y\\n\" +\n\t\t\t// (t.x - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"cos \" + t + \".z, \" + t + \".z\\n\" +\n\t\t\t\"cos \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t// (t.x - t.w*t.z) ^ k\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + t + \".z\\n\" +\n\t\t\t// (t.x - t.w) ^ k\n\t\t\t\"sub \" + t + \".w, \" + t + \".x, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularAnisotropicMethod;",
    "import AssetEvent\t\t\t\t\t\t= require(\"awayjs-core/lib/events/AssetEvent\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated\n * version of Phong specularity).\n */\nclass SpecularBasicMethod extends LightingMethodBase\n{\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\tpublic _pSpecularTexData:ShaderRegisterElement;\n\tpublic _pSpecularDataRegister:ShaderRegisterElement;\n\n\tprivate _texture:TextureBase;\n\n\tprivate _gloss:number = 50;\n\tprivate _strength:number = 1;\n\tprivate _color:number = 0xffffff;\n\tpublic _iSpecularR:number = 1;\n\tpublic _iSpecularG:number = 1;\n\tpublic _iSpecularB:number = 1;\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new SpecularBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\t\tmethodVO.needsView = shader.numLights > 0;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, null));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\n\t/**\n\t * The glossiness of the material (sharpness of the specular highlight).\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._gloss = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular highlights.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tif (value == this._strength)\n\t\t\treturn;\n\n\t\tthis._strength = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The colour of the specular reflection of the surface.\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number)\n\t{\n\t\tif (this._color == value)\n\t\t\treturn;\n\n\t\t// specular is now either enabled or disabled\n\t\tif (this._color == 0 || value == 0)\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._color = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * A texture that defines the strength of specular reflections for each texel in the red channel,\n\t * and the gloss factor (sharpness) in the green channel. You can use Specular2DTexture if you want to easily set\n\t * specular and gloss maps from grayscale images, but correctly authored images are preferred.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\n\t\tvar m:any = method;\n\t\tvar bsm:SpecularBasicMethod = <SpecularBasicMethod> method;\n\n\t\tvar spec:SpecularBasicMethod = bsm;//SpecularBasicMethod(method);\n\t\tthis.texture = spec.texture;\n\t\tthis.strength = spec.strength;\n\t\tthis.color = spec.color;\n\t\tthis.gloss = spec.gloss;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._pTotalLightColorReg = null;\n\t\tthis._pSpecularTexData = null;\n\t\tthis._pSpecularDataRegister = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tthis._pSpecularDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index*4;\n\n\t\tif (this._texture) {\n\n\t\t\tthis._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(this._pSpecularTexData, 1);\n\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(this._pSpecularTexData, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\t\t}\n\n\t\tthis._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\t// blinn-phong half vector model\n\t\tcode += \"add \" + t + \", \" + lightDirReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"nrm \" + t + \".xyz, \" + t + \"\\n\" +\n\t\t\t\t\"dp3 \" + t + \".w, \" + normalReg + \", \" + t + \"\\n\" +\n\t\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else {\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\t\t}\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \", \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\n\t\tcode += \"dp3 \" + t + \".w, \" + normalReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t\t\"mul \" + t + \", \" + t + \".w, \" + normalReg + \"\\n\" +\n\t\t\t\t\"sub \" + t + \", \" + t + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"tex \" + t + \", \" + t + \", \" + cubeMapReg + \" <cube,\" + \"linear\" + \",miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply strength modulation from texture\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularTexData + \".x\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pSpecularTexData);\n\t\t}\n\n\t\t// apply material's specular reflection\n\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularDataRegister + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\";\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._iSpecularR;\n\t\tdata[index + 1] = this._iSpecularG;\n\t\tdata[index + 2] = this._iSpecularB;\n\t\tdata[index + 3] = this._gloss;\n\t}\n\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the specular color data used by the render state.\n\t */\n\tprivate updateSpecular()\n\t{\n\t\tthis._iSpecularR = (( this._color >> 16) & 0xff)/0xff*this._strength;\n\t\tthis._iSpecularG = (( this._color >> 8) & 0xff)/0xff*this._strength;\n\t\tthis._iSpecularB = ( this._color & 0xff)/0xff*this._strength;\n\t}\n}\n\nexport = SpecularBasicMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.\n */\nclass SpecularCelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\tprivate _specularCutOff:number = .1;\n\n\t/**\n\t * Creates a new SpecularCelMethod object.\n\t * @param specularCutOff The threshold at which the specular highlight should be shown.\n\t * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.\n\t */\n\tconstructor(specularCutOff:number = .5, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._specularCutOff = specularCutOff;\n\t}\n\n\t/**\n\t * The smoothness of the highlight edge.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * The threshold at which the specular highlight should be shown.\n\t */\n\tpublic get specularCutOff():number\n\t{\n\t\treturn this._specularCutOff;\n\t}\n\n\tpublic set specularCutOff(value:number)\n\t{\n\t\tthis._specularCutOff = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._smoothness;\n\t\tdata[index + 1] = this._specularCutOff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the specular strength in the \"w\" component, and either the half-vector or the reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" + // x - cutoff\n\t\t\t\"div \" + targetReg + \".y, \" + targetReg + \".y, \" + this._dataReg + \".x\\n\" + // (x - cutoff)/epsilon\n\t\t\t\"sat \" + targetReg + \".y, \" + targetReg + \".y\\n\" +\n\t\t\t\"sge \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n}\n\nexport = SpecularCelMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the\n * calculated specular reflection strength.\n */\nclass SpecularCompositeMethod extends SpecularBasicMethod\n{\n\tprivate _baseMethod:SpecularBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new <code>SpecularCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.\n\t * @param baseMethod The base specular method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod || new SpecularBasicMethod();\n\t\tthis._baseMethod._iModulateMethod = modulateMethod;\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\n\tpublic iAddOwner(owner:IRenderOwner)\n\t{\n\t\tsuper.iAddOwner(owner);\n\n\t\tthis._baseMethod.iAddOwner(owner);\n\t}\n\n\tpublic iRemoveOwner(owner:IRenderOwner)\n\t{\n\t\tsuper.iRemoveOwner(owner);\n\n\t\tthis._baseMethod.iRemoveOwner(owner);\n\t}\n\n\t/**\n\t * The base specular method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():SpecularBasicMethod\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._baseMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._baseMethod.gloss = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._baseMethod.strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._baseMethod.strength = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this._baseMethod.color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set color(value:number)\n\t{\n\t\tthis._baseMethod.color = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis._baseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._baseMethod.texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis._baseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @return\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = SpecularCompositeMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.\n */\nclass SpecularFresnelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _incidentLight:boolean;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = .028; // default value for skin\n\n\t/**\n\t * Creates a new SpecularFresnelMethod object.\n\t * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.\n\t */\n\tconstructor(basedOnSurface:boolean = true, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\t// may want to offer diff speculars\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.modulateSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._incidentLight = !basedOnSurface;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tshader.fragmentConstantData[index + 2] = 1;\n\t\tshader.fragmentConstantData[index + 3] = 0;\n\t}\n\n\t/**\n\t * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t */\n\tpublic get basedOnSurface():boolean\n\t{\n\t\treturn !this._incidentLight;\n\t}\n\n\tpublic set basedOnSurface(value:boolean)\n\t{\n\t\tif (this._incidentLight != value)\n\t\t\treturn;\n\n\t\tthis._incidentLight = !value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = this._normalReflectance;\n\t\tfragmentData[index + 1] = this._fresnelPower;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Applies the fresnel effect to the specular strength.\n\t *\n\t * @param vo The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param target The register containing the specular strength in the \"w\" component, and the half-vector/reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared registers created by the compiler.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate modulateSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\n\t\tcode = \"dp3 \" + targetReg + \".y, \" + sharedRegisters.viewDirFragment + \".xyz, \" + (this._incidentLight? targetReg : sharedRegisters.normalFragment) + \".xyz\\n\" +   // dot(V, H)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // base = 1-dot(V, H)\n\t\t\t\"pow \" + targetReg + \".x, \" + targetReg + \".y, \" + this._dataReg + \".y\\n\" +             // exp = pow(base, 5)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // 1 - exp\n\t\t\t\"mul \" + targetReg + \".y, \" + this._dataReg + \".x, \" + targetReg + \".y\\n\" +             // f0*(1 - exp)\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".x, \" + targetReg + \".y\\n\" +          // exp + f0*(1 - exp)\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\n\t\treturn code;\n\t}\n\n}\n\nexport = SpecularFresnelMethod;",
    "import LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularPhongMethod provides a specular method that provides Phong highlights.\n */\nclass SpecularPhongMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularPhongMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement =sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement =sharedRegisters.normalFragment;\n\n\t\t// phong model\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \", \" + normalReg + \"\\n\" + // sca1 = light.normal\n\n\t\t\t//find the reflected light vector R\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" + // sca1 = sca1*2\n\t\t\t\"mul \" + t + \".xyz, \" + normalReg + \", \" + t + \".w\\n\" + // vec1 = normal*sca1\n\t\t\t\"sub \" + t + \".xyz, \" + t + \", \" + lightDirReg + \"\\n\" + // vec1 = vec1 - light (light vector is negative)\n\n\t\t\t//smooth the edge as incidence angle approaches 90\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" +sharedRegisters.commons + \".w\\n\" + // sca1 = sca1 + smoothtep;\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\" + // sca1 range 0 - 1\n\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + t + \".w\\n\" + // vec1 = vec1*sca1\n\n\t\t\t//find the dot product between R and V\n\t\t\t\"dp3 \" + t + \".w, \" + t + \", \" + viewDirReg + \"\\n\" + // sca1 = vec1.view\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularPhongMethod;",
    "import BlendMode\t\t\t\t\t\t= require(\"awayjs-core/lib/image/BlendMode\");\nimport ColorTransform\t\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Matrix\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport Matrix3DUtils\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3DUtils\");\nimport Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\nimport AssetEvent\t\t\t\t\t\t= require(\"awayjs-core/lib/events/AssetEvent\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport StaticLightPicker\t\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\n\nimport ContextGLCompareMode\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport IElementsClassGL\t\t\t\t\t= require(\"awayjs-renderergl/lib/elements/IElementsClassGL\");\nimport RenderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderBase\");\nimport RenderPool\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderPool\");\n\nimport MethodMaterial\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterial\");\nimport MethodMaterialMode\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\nimport MethodPassMode\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPassMode\");\nimport MethodPass\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPass\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectColorTransformMethod\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass MethodMaterialRender extends RenderBase\n{\n\tprivate _material:MethodMaterial;\n\tprivate _pass:MethodPass;\n\tprivate _casterLightPass:MethodPass;\n\tprivate _nonCasterLightPasses:Array<MethodPass>;\n\t\n\t/**\n\t * The maximum total number of lights provided by the light picker.\n\t */\n\tprivate get numLights():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights + this._material.lightPicker.numCastingDirectionalLights + this._material.lightPicker.numCastingPointLights : 0;\n\t}\n\n\t/**\n\t * The amount of lights that don't cast shadows.\n\t */\n\tprivate get numNonCasters():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights : 0;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(material:MethodMaterial, elementsClass:IElementsClassGL, pool:RenderPool)\n\t{\n\t\tsuper(material, elementsClass, pool);\n\n\t\tthis._material = material;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pUpdateRender()\n\t{\n\t\tsuper._pUpdateRender();\n\n\t\tthis.initPasses();\n\n\t\tthis.setBlendAndCompareModes();\n\n\t\tthis._pClearPasses();\n\n\t\tif (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this._casterLightPass)\n\t\t\t\tthis._pAddPass(this._casterLightPass);\n\n\t\t\tif (this._nonCasterLightPasses)\n\t\t\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\t\t\tthis._pAddPass(this._nonCasterLightPasses[i]);\n\t\t}\n\n\t\tif (this._pass)\n\t\t\tthis._pAddPass(this._pass);\n\t}\n\n\t/**\n\t * Initializes all the passes and their dependent passes.\n\t */\n\tprivate initPasses()\n\t{\n\t\t// let the effects pass handle everything if there are no lights, when there are effect methods applied\n\t\t// after shading, or when the material mode is single pass.\n\t\tif (this.numLights == 0 || this._material.numEffectMethods > 0 || this._material.mode == MethodMaterialMode.SINGLE_PASS)\n\t\t\tthis.initEffectPass();\n\t\telse if (this._pass)\n\t\t\tthis.removeEffectPass();\n\n\t\t// only use a caster light pass if shadows need to be rendered\n\t\tif (this._material.shadowMethod && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initCasterLightPass();\n\t\telse if (this._casterLightPass)\n\t\t\tthis.removeCasterLightPass();\n\n\t\t// only use non caster light passes if there are lights that don't cast\n\t\tif (this.numNonCasters > 0 && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initNonCasterLightPasses();\n\t\telse if (this._nonCasterLightPasses)\n\t\t\tthis.removeNonCasterLightPasses();\n\t}\n\n\t/**\n\t * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.\n\t */\n\tprivate setBlendAndCompareModes()\n\t{\n\t\tvar forceSeparateMVP:boolean = Boolean(this._casterLightPass || this._pass);\n\n\t\t// caster light pass is always first if it exists, hence it uses normal blending\n\t\tif (this._casterLightPass) {\n\t\t\tthis._casterLightPass.forceSeparateMVP = forceSeparateMVP;\n\t\t\tthis._casterLightPass.shader.setBlendMode(BlendMode.NORMAL);\n\t\t\tthis._casterLightPass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\n\t\tif (this._nonCasterLightPasses) {\n\t\t\tvar firstAdditiveIndex:number = 0;\n\n\t\t\t// if there's no caster light pass, the first non caster light pass will be the first\n\t\t\t// and should use normal blending\n\t\t\tif (!this._casterLightPass) {\n\t\t\t\tthis._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[0].shader.setBlendMode(BlendMode.NORMAL);\n\t\t\t\tthis._nonCasterLightPasses[0].shader.depthCompareMode = this._material.depthCompareMode;\n\t\t\t\tfirstAdditiveIndex = 1;\n\t\t\t}\n\n\t\t\t// all lighting passes following the first light pass should use additive blending\n\t\t\tfor (var i:number = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {\n\t\t\t\tthis._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[i].shader.setBlendMode(BlendMode.ADD);\n\t\t\t\tthis._nonCasterLightPasses[i].shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t}\n\t\t}\n\n\t\tif (this._casterLightPass || this._nonCasterLightPasses) {\n\t\t\t//cannot be blended by blendmode property if multipass enabled\n\t\t\tthis._pRequiresBlending = false;\n\n\t\t\t// there are light passes, so this should be blended in\n\t\t\tif (this._pass) {\n\t\t\t\tthis._pass.mode = MethodPassMode.EFFECTS;\n\t\t\t\tthis._pass.forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._pass.shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t\tthis._pass.shader.setBlendMode(BlendMode.LAYER);\n\t\t\t}\n\n\t\t} else if (this._pass) {\n\t\t\tthis._pRequiresBlending = (this._material.blendMode != BlendMode.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));\n\t\t\t// effects pass is the only pass, so it should just blend normally\n\t\t\tthis._pass.mode = MethodPassMode.SUPER_SHADER;\n\t\t\tthis._pass.preserveAlpha = this._pRequiresBlending;\n\t\t\tthis._pass.forceSeparateMVP = false;\n\t\t\tthis._pass.colorTransform = this._material.colorTransform;\n\t\t\tthis._pass.shader.setBlendMode((this._material.blendMode == BlendMode.NORMAL && this._pRequiresBlending)? BlendMode.LAYER : this._material.blendMode);\n\t\t\tthis._pass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\t}\n\n\tprivate initCasterLightPass()\n\t{\n\n\t\tif (this._casterLightPass == null)\n\t\t\tthis._casterLightPass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._elementsClass, this._stage);\n\n\t\tthis._casterLightPass.lightPicker = new StaticLightPicker([this._material.shadowMethod.castingLight]);\n\t\tthis._casterLightPass.shadowMethod = this._material.shadowMethod;\n\t\tthis._casterLightPass.diffuseMethod = this._material.diffuseMethod;\n\t\tthis._casterLightPass.ambientMethod = this._material.ambientMethod;\n\t\tthis._casterLightPass.normalMethod = this._material.normalMethod;\n\t\tthis._casterLightPass.specularMethod = this._material.specularMethod;\n\t}\n\n\tprivate removeCasterLightPass()\n\t{\n\t\tthis._casterLightPass.dispose();\n\t\tthis._pRemovePass(this._casterLightPass);\n\t\tthis._casterLightPass = null;\n\t}\n\n\tprivate initNonCasterLightPasses()\n\t{\n\t\tthis.removeNonCasterLightPasses();\n\t\tvar pass:MethodPass;\n\t\tvar numDirLights:number = this._material.lightPicker.numDirectionalLights;\n\t\tvar numPointLights:number = this._material.lightPicker.numPointLights;\n\t\tvar numLightProbes:number = this._material.lightPicker.numLightProbes;\n\t\tvar dirLightOffset:number = 0;\n\t\tvar pointLightOffset:number = 0;\n\t\tvar probeOffset:number = 0;\n\n\t\tif (!this._casterLightPass) {\n\t\t\tnumDirLights += this._material.lightPicker.numCastingDirectionalLights;\n\t\t\tnumPointLights += this._material.lightPicker.numCastingPointLights;\n\t\t}\n\n\t\tthis._nonCasterLightPasses = new Array<MethodPass>();\n\n\t\twhile (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {\n\t\t\tpass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._elementsClass, this._stage);\n\t\t\tpass.includeCasters = this._material.shadowMethod == null;\n\t\t\tpass.directionalLightsOffset = dirLightOffset;\n\t\t\tpass.pointLightsOffset = pointLightOffset;\n\t\t\tpass.lightProbesOffset = probeOffset;\n\t\t\tpass.lightPicker = this._material.lightPicker;\n\t\t\tpass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tpass.ambientMethod = this._material.ambientMethod;\n\t\t\tpass.normalMethod = this._material.normalMethod;\n\t\t\tpass.specularMethod = this._material.specularMethod;\n\t\t\tthis._nonCasterLightPasses.push(pass);\n\n\t\t\tdirLightOffset += pass.numDirectionalLights;\n\t\t\tpointLightOffset += pass.numPointLights;\n\t\t\tprobeOffset += pass.numLightProbes;\n\t\t}\n\t}\n\n\tprivate removeNonCasterLightPasses()\n\t{\n\t\tif (!this._nonCasterLightPasses)\n\t\t\treturn;\n\n\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\tthis._pRemovePass(this._nonCasterLightPasses[i]);\n\n\t\tthis._nonCasterLightPasses = null;\n\t}\n\n\tprivate removeEffectPass()\n\t{\n\t\tif (this._pass.ambientMethod != this._material.ambientMethod)\n\t\t\tthis._pass.ambientMethod.dispose();\n\n\t\tif (this._pass.diffuseMethod != this._material.diffuseMethod)\n\t\t\tthis._pass.diffuseMethod.dispose();\n\n\t\tif (this._pass.specularMethod != this._material.specularMethod)\n\t\t\tthis._pass.specularMethod.dispose();\n\n\t\tif (this._pass.normalMethod != this._material.normalMethod)\n\t\t\tthis._pass.normalMethod.dispose();\n\n\t\tthis._pRemovePass(this._pass);\n\t\tthis._pass = null;\n\t}\n\n\tprivate initEffectPass()\n\t{\n\t\tif (this._pass == null)\n\t\t\tthis._pass = new MethodPass(MethodPassMode.SUPER_SHADER, this, this._material, this._elementsClass, this._stage);\n\n\t\tif (this._material.mode == MethodMaterialMode.SINGLE_PASS) {\n\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\tthis._pass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tthis._pass.specularMethod = this._material.specularMethod;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t\tthis._pass.shadowMethod = this._material.shadowMethod;\n\t\t} else if (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this.numLights == 0) {\n\t\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\t} else {\n\t\t\t\tthis._pass.ambientMethod = null;\n\t\t\t}\n\n\t\t\tthis._pass.preserveAlpha = false;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t}\n\n\t\t//update effect methods\n\t\tvar i:number = 0;\n\t\tvar effectMethod:EffectMethodBase;\n\t\tvar len:number = Math.max(this._material.numEffectMethods, this._pass.numEffectMethods);\n\n\t\twhile (i < len) {\n\t\t\teffectMethod = this._material.getEffectMethodAt(i);\n\t\t\tif (effectMethod != this._pass.getEffectMethodAt(i)) {\n\t\t\t\tthis._pass.removeEffectMethodAt(i);\n\n\t\t\t\tif (effectMethod != null) {\n\t\t\t\t\tif (i < this._pass.numEffectMethods)\n\t\t\t\t\t\tthis._pass.addEffectMethodAt(effectMethod, i);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis._pass.addEffectMethod(effectMethod);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic onClear(event:AssetEvent)\n\t{\n\t\tsuper.onClear(event);\n\n\t\t//TODO\n\t}\n}\n\nexport = MethodMaterialRender;",
    "class PassMode\n{\n\t/**\n\t *\n\t */\n\tpublic static EFFECTS:number = 0x01;\n\n\t/**\n\t *\n\t */\n\tpublic static LIGHTING:number = 0x02;\n\n\t/**\n\t *\n\t */\n\tpublic static SUPER_SHADER:number = 0x03;\n}\n\nexport = PassMode;",
    "import ColorTransform\t\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Matrix\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport Matrix3DUtils\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3DUtils\");\nimport Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\nimport AssetEvent\t\t\t\t\t\t= require(\"awayjs-core/lib/events/AssetEvent\");\nimport MaterialBase\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport LightPickerBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/LightPickerBase\");\nimport LightSources\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/LightSources\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport LightingShader\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterElement\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport PassBase\t\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/PassBase\");\nimport ILightingPass\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/ILightingPass\");\nimport IElementsClassGL\t\t\t\t\t= require(\"awayjs-renderergl/lib/elements/IElementsClassGL\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectColorTransformMethod\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport MethodPassMode\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/passes/MethodPassMode\");\nimport MethodMaterialRender\t\t\t\t= require(\"awayjs-methodmaterials/lib/render/MethodMaterialRender\");\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass MethodPass extends PassBase implements ILightingPass\n{\n\tprivate _maxLights:number = 3;\n\n\tprivate _mode:number = 0x03;\n\tprivate _material:MaterialBase;\n\tprivate _lightPicker:LightPickerBase;\n\n\tprivate _includeCasters:boolean = true;\n\n\tpublic _iColorTransformMethodVO:MethodVO;\n\tpublic _iNormalMethodVO:MethodVO;\n\tpublic _iAmbientMethodVO:MethodVO;\n\tpublic _iShadowMethodVO:MethodVO;\n\tpublic _iDiffuseMethodVO:MethodVO;\n\tpublic _iSpecularMethodVO:MethodVO;\n\tpublic _iMethodVOs:Array<MethodVO> = new Array<MethodVO>();\n\n\tpublic _numEffectDependencies:number = 0;\n\n\tprivate _onLightsChangeDelegate:(event:AssetEvent) => void;\n\tprivate _onMethodInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\tpublic numDirectionalLights:number = 0;\n\n\tpublic numPointLights:number = 0;\n\n\tpublic numLightProbes:number = 0;\n\n\tpublic pointLightsOffset:number = 0;\n\t\n\tpublic directionalLightsOffset:number= 0;\n\t\n\tpublic lightProbesOffset:number = 0;\n\t\n\t/**\n\t *\n\t */\n\tpublic get mode():number\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:number)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\t\t\n\t\tthis._mode = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * Indicates whether or not shadow casting lights need to be included.\n\t */\n\tpublic get includeCasters():boolean\n\t{\n\t\treturn this._includeCasters;\n\t}\n\n\tpublic set includeCasters(value:boolean)\n\t{\n\t\tif (this._includeCasters == value)\n\t\t\treturn;\n\n\t\tthis._includeCasters = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * \n\t * @returns {LightPickerBase}\n\t */\n\tpublic get lightPicker():LightPickerBase\n\t{\n\t\treturn this._lightPicker;\n\t}\n\n\tpublic set lightPicker(value:LightPickerBase)\n\t{\n\t\t//if (this._lightPicker == value)\n\t\t//\treturn;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\tthis._lightPicker = value;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.addEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\tthis._updateLights();\n\t}\n\t\n\t/**\n\t * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and\n\t * compatibility for constrained mode.\n\t */\n\tpublic get enableLightFallOff():boolean\n\t{\n\t\treturn this._material.enableLightFallOff;\n\t}\n\n\t/**\n\t * Define which light source types to use for diffuse reflections. This allows choosing between regular lights\n\t * and/or light probes for diffuse reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get diffuseLightSources():number\n\t{\n\t\treturn this._material.diffuseLightSources;\n\t}\n\n\t/**\n\t * Define which light source types to use for specular reflections. This allows choosing between regular lights\n\t * and/or light probes for specular reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get specularLightSources():number\n\t{\n\t\treturn this._material.specularLightSources;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(mode:number, render:MethodMaterialRender, renderOwner:MaterialBase, elementsClass:IElementsClassGL, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, elementsClass, stage);\n\n\t\tthis._mode = mode;\n\n\t\tthis._material = renderOwner;\n\n\t\tthis._onLightsChangeDelegate = (event:AssetEvent) => this.onLightsChange(event);\n\t\t\n\t\tthis._onMethodInvalidatedDelegate = (event:ShadingMethodEvent) => this.onMethodInvalidated(event);\n\n\t\tthis.lightPicker = renderOwner.lightPicker;\n\n\t\tif (this._shader == null)\n\t\t\tthis._updateShader();\n\t}\n\n\tprivate _updateShader()\n\t{\n\t\tif ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof LightingShader)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new LightingShader(this._elementsClass, this, this._stage);\n\t\t} else if (!(this._shader instanceof ShaderBase)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new ShaderBase(this._elementsClass, this, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the unchanging constant data for this material.\n\t */\n\tpublic _iInitConstantData(shader:ShaderBase)\n\t{\n\t\tsuper._iInitConstantData(shader);\n\n\t\t//Updates method constants if they have changed.\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tthis._iMethodVOs[i].method.iInitConstants(shader, this._iMethodVOs[i]);\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this.colorTransformMethod? this.colorTransformMethod.colorTransform : null;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tif (value) {\n\t\t\tif (this.colorTransformMethod == null)\n\t\t\t\tthis.colorTransformMethod = new EffectColorTransformMethod();\n\n\t\t\tthis.colorTransformMethod.colorTransform = value;\n\n\t\t} else if (!value) {\n\t\t\tif (this.colorTransformMethod)\n\t\t\t\tthis.colorTransformMethod = null;\n\t\t}\n\t}\n\n\t/**\n\t * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransformMethod():EffectColorTransformMethod\n\t{\n\t\treturn this._iColorTransformMethodVO? <EffectColorTransformMethod> this._iColorTransformMethodVO.method : null;\n\t}\n\n\tpublic set colorTransformMethod(value:EffectColorTransformMethod)\n\t{\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iColorTransformMethodVO) {\n\t\t\tthis._removeDependency(this._iColorTransformMethodVO);\n\t\t\tthis._iColorTransformMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iColorTransformMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iColorTransformMethodVO);\n\t\t}\n\t}\n\n\tprivate _removeDependency(methodVO:MethodVO, effectsDependency:boolean = false)\n\t{\n\t\tvar index:number = this._iMethodVOs.indexOf(methodVO);\n\n\t\tif (!effectsDependency)\n\t\t\tthis._numEffectDependencies--;\n\n\t\tmethodVO.method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\t\tthis._iMethodVOs.splice(index, 1);\n\n\t\tthis.invalidate();\n\t}\n\n\tprivate _addDependency(methodVO:MethodVO, effectsDependency:boolean = false, index:number = -1)\n\t{\n\t\tmethodVO.method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\n\t\tif (effectsDependency) {\n\t\t\tif (index != -1)\n\t\t\t\tthis._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t\telse\n\t\t\t\tthis._iMethodVOs.push(methodVO);\n\t\t\tthis._numEffectDependencies++;\n\t\t} else {\n\t\t\tthis._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t}\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._addDependency(new MethodVO(method, this), true);\n\t}\n\n\t/**\n\t * The number of \"effect\" methods added to the material.\n\t */\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._numEffectDependencies;\n\t}\n\n\t/**\n\t * Queries whether a given effects method was added to the material.\n\t *\n\t * @param method The method to be queried.\n\t * @return true if the method was added to the material, false otherwise.\n\t */\n\tpublic hasEffectMethod(method:EffectMethodBase):boolean\n\t{\n\t\treturn this.getDependencyForMethod(method) != null;\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn null;\n\n\t\treturn <EffectMethodBase> this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tthis._addDependency(new MethodVO(method, this), true, index);\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tvar methodVO:MethodVO = this.getDependencyForMethod(method);\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\t/**\n\t * remove an effect method at the specified index from the material.\n\t */\n\tpublic removeEffectMethodAt(index:number)\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn;\n\n\t\tvar methodVO:MethodVO = this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies];\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\tprivate getDependencyForMethod(method:EffectMethodBase):MethodVO\n\t{\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tif (this._iMethodVOs[i].method == method)\n\t\t\t\treturn this._iMethodVOs[i];\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._iNormalMethodVO? <NormalBasicMethod> this._iNormalMethodVO.method : null;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._iNormalMethodVO && this._iNormalMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iNormalMethodVO) {\n\t\t\tthis._removeDependency(this._iNormalMethodVO);\n\t\t\tthis._iNormalMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iNormalMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iNormalMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._iAmbientMethodVO? <AmbientBasicMethod> this._iAmbientMethodVO.method : null;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iAmbientMethodVO) {\n\t\t\tthis._removeDependency(this._iAmbientMethodVO);\n\t\t\tthis._iAmbientMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iAmbientMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iAmbientMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._iShadowMethodVO? <ShadowMapMethodBase> this._iShadowMethodVO.method : null;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._iShadowMethodVO && this._iShadowMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iShadowMethodVO) {\n\t\t\tthis._removeDependency(this._iShadowMethodVO);\n\t\t\tthis._iShadowMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iShadowMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iShadowMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._iDiffuseMethodVO? <DiffuseBasicMethod> this._iDiffuseMethodVO.method : null;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iDiffuseMethodVO) {\n\t\t\tthis._removeDependency(this._iDiffuseMethodVO);\n\t\t\tthis._iDiffuseMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iDiffuseMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iDiffuseMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._iSpecularMethodVO? <SpecularBasicMethod> this._iSpecularMethodVO.method : null;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iSpecularMethodVO) {\n\t\t\tthis._removeDependency(this._iSpecularMethodVO);\n\t\t\tthis._iSpecularMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iSpecularMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iSpecularMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\twhile (this._iMethodVOs.length)\n\t\t\tthis._removeDependency(this._iMethodVOs[0]);\n\n\t\tsuper.dispose();\n\n\t\tthis._iMethodVOs = null;\n\t}\n\n\t/**\n\t * Called when any method's shader code is invalidated.\n\t */\n\tprivate onMethodInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.invalidate();\n\t}\n\n\t// RENDER LOOP\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tsuper._iActivate(camera);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iActivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param renderable\n\t * @param stage\n\t * @param camera\n\t */\n\tpublic _iRender(renderable:RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tsuper._iRender(renderable, camera, viewProjection);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iSetRenderState(this._shader, methodVO, renderable, this._stage, camera);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iDeactivate()\n\t{\n\t\tsuper._iDeactivate();\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iDeactivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\tpublic _iIncludeDependencies(shader:LightingShader)\n\t{\n\t\tsuper._iIncludeDependencies(shader);\n\n\t\t//TODO: fragment animtion should be compatible with lighting pass\n\t\tshader.usesFragmentAnimation = Boolean(this._mode == MethodPassMode.SUPER_SHADER);\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending)\n\t\t\tshader.usesCommonData = true;\n\n\t\tvar i:number;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tthis.setupAndCountDependencies(shader, this._iMethodVOs[i]);\n\n\t\tvar usesTangentSpace:boolean = true;\n\n\t\tvar methodVO:MethodVO;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif ((methodVO.useMethod = methodVO.method.iIsUsed(shader)) && !methodVO.method.iUsesTangentSpace())\n\t\t\t\tusesTangentSpace = false;\n\t\t}\n\n\t\tshader.outputsNormals = this._iNormalMethodVO && this._iNormalMethodVO.useMethod;\n\t\tshader.outputsTangentNormals = shader.outputsNormals && (<NormalBasicMethod> this._iNormalMethodVO.method).iOutputsTangentNormals();\n\t\tshader.usesTangentSpace = shader.outputsTangentNormals && !shader.usesProbes && usesTangentSpace;\n\n\t\tif (!shader.usesTangentSpace) {\n\t\t\tif (shader.viewDirDependencies > 0) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t} else if (this.numPointLights > 0 && shader.usesLights) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t\tif (Boolean(this._mode & MethodPassMode.EFFECTS))\n\t\t\t\t\tshader.usesGlobalPosFragment = true;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Counts the dependencies for a given method.\n\t * @param method The method to count the dependencies for.\n\t * @param methodVO The method's data for this material.\n\t */\n\tprivate setupAndCountDependencies(shader:ShaderBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.reset();\n\n\t\tmethodVO.method.iInitVO(shader, methodVO);\n\n\t\tif (methodVO.needsProjection)\n\t\t\tshader.projectionDependencies++;\n\n\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos) {\n\n\t\t\tshader.globalPosDependencies++;\n\n\t\t\tif (methodVO.needsGlobalFragmentPos)\n\t\t\t\tshader.usesGlobalPosFragment = true;\n\n\t\t}\n\n\t\tif (methodVO.needsNormals)\n\t\t\tshader.normalDependencies++;\n\n\t\tif (methodVO.needsTangents)\n\t\t\tshader.tangentDependencies++;\n\n\t\tif (methodVO.needsView)\n\t\t\tshader.viewDirDependencies++;\n\t}\n\n\tpublic _iGetPreLightingVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)\n\t\t\tcode += this._iAmbientMethodVO.method.iGetVertexCode(shader, this._iAmbientMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += this._iDiffuseMethodVO.method.iGetVertexCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += this._iSpecularMethodVO.method.iGetVertexCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPreLightingFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {\n\t\t\tcode += this._iAmbientMethodVO.method.iGetFragmentCode(shader, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\tif (this._iAmbientMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iAmbientMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPerLightDiffuseFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, diffuseColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerLight(shader, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerLightSpecularFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, specularColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerLight(shader, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeDiffuseFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerProbe(shader, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeSpecularFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerProbe(shader, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPostLightingVertexCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetVertexCode(shader, this._iShadowMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPostLightingFragmentCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending) {\n\t\t\tcode += \"add \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"div \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \", \" + sharedRegisters.shadedTarget + \".w\\n\" +\n\t\t\t\"sub \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"sat \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \"\\n\";\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetFragmentCode(shader, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPostLightingCode(shader, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\t// resolve other dependencies as well?\n\t\t\tif (this._iDiffuseMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iDiffuseMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPostLightingCode(shader, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\t\t\tif (this._iSpecularMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\t\t\tif (this._iSpecularMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);\n\n\t\treturn code;\n\t}\n\n\n\tpublic _iGetNormalVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._iNormalMethodVO.method.iGetVertexCode(shader, this._iNormalMethodVO, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetNormalFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._iNormalMethodVO.method.iGetFragmentCode(shader, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);\n\n\t\tif (this._iNormalMethodVO.needsView)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\n\t\tif (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)\n\t\t\tregisterCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetVertexCode(shader, methodVO, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)\n\t\t\t\t\tregCache.removeVertexTempUsage(sharedReg.globalPositionVertex);\n\t\t\t}\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetVertexCode(shader, this._iColorTransformMethodVO, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar alphaReg:ShaderRegisterElement;\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\talphaReg = regCache.getFreeFragmentSingleTemp();\n\t\t\tregCache.addFragmentTempUsages(alphaReg, 1);\n\t\t\tcode += \"mov \" + alphaReg + \", \" + sharedReg.shadedTarget + \".w\\n\";\n\t\t}\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetFragmentCode(shader, methodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsNormals)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.normalFragment);\n\n\t\t\t\tif (methodVO.needsView)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.viewDirFragment);\n\n\t\t\t}\n\t\t}\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\tcode += \"mov \" + sharedReg.shadedTarget + \".w, \" + alphaReg + \"\\n\";\n\t\t\tregCache.removeFragmentTempUsage(alphaReg);\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetFragmentCode(shader, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\t/**\n\t * Indicates whether the shader uses any shadows.\n\t */\n\tpublic _iUsesShadows(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iShadowMethodVO && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesSpecular(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iSpecularMethodVO);\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesDiffuse(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iDiffuseMethodVO);\n\t}\n\n\n\tprivate onLightsChange(event:AssetEvent)\n\t{\n\t\tthis._updateLights();\n\t}\n\n\tprivate _updateLights()\n\t{\n\t\tvar numDirectionalLightsOld:number = this.numDirectionalLights;\n\t\tvar numPointLightsOld:number = this.numPointLights;\n\t\tvar numLightProbesOld:number = this.numLightProbes;\n\n\t\tif (this._lightPicker && (this._mode & MethodPassMode.LIGHTING)) {\n\t\t\tthis.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);\n\t\t\tthis.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);\n\t\t\tthis.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);\n\n\t\t\tif (this._includeCasters) {\n\t\t\t\tthis.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;\n\t\t\t\tthis.numPointLights += this._lightPicker.numCastingPointLights;\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis.numDirectionalLights = 0;\n\t\t\tthis.numPointLights = 0;\n\t\t\tthis.numLightProbes = 0;\n\t\t}\n\n\t\tif (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {\n\t\t\tthis._updateShader();\n\n\t\t\tthis.invalidate();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the amount of directional lights this material will support.\n\t * @param numDirectionalLights The maximum amount of directional lights to support.\n\t * @return The amount of directional lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumDirectionalLights(numDirectionalLights:number):number\n\t{\n\t\treturn Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);\n\t}\n\n\t/**\n\t * Calculates the amount of point lights this material will support.\n\t * @param numDirectionalLights The maximum amount of point lights to support.\n\t * @return The amount of point lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumPointLights(numPointLights:number):number\n\t{\n\t\tvar numFree:number = this._maxLights - this.numDirectionalLights;\n\t\treturn Math.min(numPointLights - this.pointLightsOffset, numFree);\n\t}\n\n\t/**\n\t * Calculates the amount of light probes this material will support.\n\t * @param numDirectionalLights The maximum amount of light probes to support.\n\t * @return The amount of light probes this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumProbes(numLightProbes:number):number\n\t{\n\t\tvar numChannels:number = 0;\n\n\t\tif ((this.specularLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\tif ((this.diffuseLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\t// 4 channels available\n\t\treturn Math.min(numLightProbes - this.lightProbesOffset, (4/numChannels) | 0);\n\t}\n}\n\nexport = MethodPass;",
    "import Image2D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/image/Image2D\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\n\nimport LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport MaterialBase\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\nimport IRenderOwner\t\t\t\t\t\t= require(\"awayjs-display/lib/base/IRenderOwner\");\nimport Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\nimport TriangleElements\t\t\t\t\t= require(\"awayjs-display/lib/graphics/TriangleElements\");\n\nimport ContextGLDrawMode\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLDrawMode\");\nimport ContextGLProgramType\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLProgramType\");\nimport IContextGL\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/IContextGL\");\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport ShaderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/shaders/ShaderRegisterData\");\nimport PassBase\t\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/passes/PassBase\");\nimport IElementsClassGL\t\t\t\t\t= require(\"awayjs-renderergl/lib/elements/IElementsClassGL\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/renderables/RenderableBase\");\nimport RenderBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/render/RenderBase\");\nimport GL_ElementsBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/elements/GL_ElementsBase\");\n\n/**\n * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point\n * of view from a light.\n */\nclass SingleObjectDepthPass extends PassBase\n{\n\tprivate _textures:Object;\n\tprivate _projections:Object;\n\tprivate _textureSize:number /*uint*/ = 512;\n\tprivate _polyOffset:Float32Array = new Float32Array([15, 0, 0, 0]);\n\tprivate _enc:Float32Array;\n\tprivate _projectionTexturesInvalid:Boolean = true;\n\n\t/**\n\t * The size of the depth map texture to render to.\n\t */\n\tpublic get textureSize():number\n\t{\n\t\treturn this._textureSize;\n\t}\n\n\tpublic set textureSize(value:number)\n\t{\n\t\tthis._textureSize = value;\n\t}\n\n\t/**\n\t * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t */\n\tpublic get polyOffset():number\n\t{\n\t\treturn this._polyOffset[0];\n\t}\n\n\tpublic set polyOffset(value:number)\n\t{\n\t\tthis._polyOffset[0] = value;\n\t}\n\n\t/**\n\t * Creates a new SingleObjectDepthPass object.\n\t */\n\tconstructor(render:RenderBase, renderOwner:IRenderOwner, elementsClass:IElementsClassGL, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, elementsClass, stage);\n\n\t\t//this._pNumUsedStreams = 2;\n\t\t//this._pNumUsedVertexConstants = 7;\n\t\t//this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n\t\t//\n\t\t//this._pAnimatableAttributes = Array<string>(\"va0\", \"va1\");\n\t\t//this._pAnimationTargetRegisters = Array<string>(\"vt0\", \"vt1\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t\tthis._textures = null;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the projection textures used to contain the depth renders.\n\t */\n\tprivate updateProjectionTextures()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t}\n\n\t\tthis._textures = new Object();\n\t\tthis._projections = new Object();\n\t\tthis._projectionTexturesInvalid = false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode():string\n\t{\n\t\tvar code:string;\n\t\t// offset\n\t\tcode = \"mul vt7, vt1, vc4.x\t\\n\" +\n\t\t\t\t\"add vt7, vt7, vt0\\n\" +\n\t\t\t\t\"mov vt7.w, vt0.w\\n\";\n\t\t// project\n\t\tcode += \"m44 vt2, vt7, vc0\\n\" +\n\t\t\t\t\"mov op, vt2\\n\";\n\n\t\t// perspective divide\n\t\tcode += \"div v0, vt2, vt2.w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\t// encode float -> rgba\n\t\tcode += \"mul ft0, fc0, v0.z\\n\" +\n\t\t\t\t\"frc ft0, ft0\\n\" +\n\t\t\t\t\"mul ft1, ft0.yzww, fc1\\n\" +\n\t\t\t\t\"sub ft0, ft0, ft1\\n\" +\n\t\t\t\t\"mov oc, ft0\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the depth maps rendered for this object from all lights.\n\t * @param renderable The renderable for which to retrieve the depth maps.\n\t * @param stage3DProxy The Stage3DProxy object currently used for rendering.\n\t * @return A list of depth map textures for all supported lights.\n\t */\n\tpublic _iGetDepthMap(renderable:RenderableBase):TextureBase\n\t{\n\t\treturn this._textures[renderable.renderableOwner.id];\n\t}\n\n\t/**\n\t * Retrieves the depth map projection maps for all lights.\n\t * @param renderable The renderable for which to retrieve the projection maps.\n\t * @return A list of projection maps for all supported lights.\n\t */\n\tpublic _iGetProjection(renderable:RenderableBase):Matrix3D\n\t{\n\t\treturn this._projections[renderable.renderableOwner.id];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iRender(renderable:RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tvar matrix:Matrix3D;\n\t\tvar context:IContextGL = this._stage.context;\n\t\tvar len:number /*uint*/;\n\t\tvar light:LightBase;\n\t\tvar lights:Array<LightBase> = this._renderOwner.lightPicker.allPickedLights;\n\t\tvar rId:number = renderable.renderableOwner.id;\n\n\t\tif (!this._textures[rId])\n\t\t\tthis._textures[rId] = new Single2DTexture(new Image2D(this._textureSize, this._textureSize));\n\n\t\tif (!this._projections[rId])\n\t\t\tthis._projections[rId] = new Matrix3D();\n\n\t\tlen = lights.length;\n\n\t\t// local position = enough\n\t\tlight = lights[0];\n\n\t\tmatrix = light.iGetObjectProjectionMatrix(renderable.sourceEntity, camera, this._projections[rId]);\n\n\t\tthis._stage.setRenderTarget(this._textures[rId], true);\n\t\tcontext.clear(1.0, 1.0, 1.0);\n\t\tcontext.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, matrix, true);\n\t\tcontext.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, this._enc, 2);\n\n\t\tvar elements:TriangleElements = <TriangleElements> renderable.elements;\n\t\tvar elementsGL:GL_ElementsBase = this._shader._elementsPool.getAbstraction(elements);\n\n\t\telementsGL.activateVertexBufferVO(0, elements.positions);\n\t\telementsGL.activateVertexBufferVO(1, elements.normals);\n\t\telementsGL.getIndexBufferVO().draw(ContextGLDrawMode.TRIANGLES, 0, elements.numElements);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tif (this._projectionTexturesInvalid)\n\t\t\tthis.updateProjectionTextures();\n\n\t\t// never scale\n\t\tsuper._iActivate(camera);\n\n\t\tthis._stage.context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);\n\t}\n}\n\nexport = SingleObjectDepthPass;"
  ],
  "sourceRoot": ""
}