{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "awayjs-methodmaterials/lib/MethodMaterialMode.ts",
    "awayjs-methodmaterials.js",
    "awayjs-methodmaterials/lib/MethodMaterial.ts",
    "awayjs-methodmaterials/lib/compilation/RenderMethodMaterialObject.ts",
    "awayjs-methodmaterials/lib/data/MethodVO.ts",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod.ts",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod.ts",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod.ts",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase.ts",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod.ts",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod.ts",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod.ts",
    "awayjs-methodmaterials/lib/passes/MethodPassMode.ts",
    "awayjs-methodmaterials/lib/passes/MethodPass.ts",
    "awayjs-methodmaterials/lib/passes/SingleObjectDepthPass.ts"
  ],
  "names": [
    "require",
    "e",
    "t",
    "n",
    "r",
    "s",
    "o",
    "u",
    "a",
    "i",
    "f",
    "Error",
    "code",
    "l",
    "exports",
    "call",
    "length",
    "awayjs-methodmaterials/lib/MethodMaterialMode",
    "module",
    "MethodMaterialMode",
    "SINGLE_PASS",
    "MULTI_PASS",
    "awayjs-methodmaterials/lib/MethodMaterial",
    "__extends",
    "this",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "__",
    "constructor",
    "prototype",
    "Image2D",
    "MaterialBase",
    "Single2DTexture",
    "TextureBase",
    "ContextGLCompareMode",
    "RenderObjectPool",
    "RenderMethodMaterialObject",
    "AmbientBasicMethod",
    "DiffuseBasicMethod",
    "NormalBasicMethod",
    "SpecularBasicMethod",
    "MethodMaterial",
    "_super",
    "textureColor",
    "smoothAlpha",
    "repeat",
    "mipmap",
    "_effectMethods",
    "Array",
    "_ambientMethod",
    "_diffuseMethod",
    "_normalMethod",
    "_specularMethod",
    "_depthCompareMode",
    "LESS_EQUAL",
    "_mode",
    "texture",
    "smooth",
    "color",
    "Number",
    "alpha",
    "addRenderable",
    "registerClass",
    "Object",
    "defineProperty",
    "get",
    "assetType",
    "enumerable",
    "configurable",
    "set",
    "value",
    "_pInvalidateRenderObject",
    "copyFrom",
    "_shadowMethod",
    "addEffectMethod",
    "method",
    "push",
    "getEffectMethodAt",
    "index",
    "addEffectMethodAt",
    "splice",
    "removeEffectMethod",
    "indexOf",
    "normalMap",
    "gloss",
    "ambient",
    "specular",
    "ambientColor",
    "diffuseColor",
    "specularColor",
    "register",
    "awayjs-core/lib/data/Image2D",
    "undefined",
    "awayjs-display/lib/materials/MaterialBase",
    "awayjs-display/lib/textures/Single2DTexture",
    "awayjs-display/lib/textures/TextureBase",
    "awayjs-methodmaterials/lib/compilation/RenderMethodMaterialObject",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod",
    "awayjs-renderergl/lib/compilation/RenderObjectPool",
    "awayjs-stagegl/lib/base/ContextGLCompareMode",
    "BlendMode",
    "StaticLightPicker",
    "RenderObjectBase",
    "MethodPassMode",
    "MethodPass",
    "pool",
    "material",
    "renderableClass",
    "stage",
    "_material",
    "lightPicker",
    "numLightProbes",
    "numDirectionalLights",
    "numPointLights",
    "numCastingDirectionalLights",
    "numCastingPointLights",
    "_pUpdateRenderObject",
    "initPasses",
    "setBlendAndCompareModes",
    "_pClearScreenPasses",
    "mode",
    "_casterLightPass",
    "_pAddScreenPass",
    "_nonCasterLightPasses",
    "_screenPass",
    "numLights",
    "numEffectMethods",
    "initEffectPass",
    "removeEffectPass",
    "shadowMethod",
    "initCasterLightPass",
    "removeCasterLightPass",
    "numNonCasters",
    "initNonCasterLightPasses",
    "removeNonCasterLightPasses",
    "forceSeparateMVP",
    "Boolean",
    "setBlendMode",
    "NORMAL",
    "depthCompareMode",
    "firstAdditiveIndex",
    "ADD",
    "_pRequiresBlending",
    "EFFECTS",
    "LAYER",
    "blendMode",
    "alphaBlending",
    "colorTransform",
    "alphaMultiplier",
    "SUPER_SHADER",
    "preserveAlpha",
    "LIGHTING",
    "_renderableClass",
    "_stage",
    "castingLight",
    "diffuseMethod",
    "ambientMethod",
    "normalMethod",
    "specularMethod",
    "dispose",
    "_pRemoveScreenPass",
    "pass",
    "numDirLights",
    "dirLightOffset",
    "pointLightOffset",
    "probeOffset",
    "includeCasters",
    "directionalLightsOffset",
    "pointLightsOffset",
    "lightProbesOffset",
    "effectMethod",
    "len",
    "Math",
    "max",
    "removeEffectMethodAt",
    "awayjs-core/lib/data/BlendMode",
    "awayjs-display/lib/materials/lightpickers/StaticLightPicker",
    "awayjs-methodmaterials/lib/passes/MethodPass",
    "awayjs-methodmaterials/lib/passes/MethodPassMode",
    "awayjs-renderergl/lib/compilation/RenderObjectBase",
    "awayjs-methodmaterials/lib/data/MethodVO",
    "MethodVO",
    "useMethod",
    "reset",
    "iReset",
    "vertexConstantsIndex",
    "secondaryVertexConstantsIndex",
    "fragmentConstantsIndex",
    "secondaryFragmentConstantsIndex",
    "needsProjection",
    "needsView",
    "needsNormals",
    "needsTangents",
    "needsGlobalVertexPos",
    "needsGlobalFragmentPos",
    "ShadingMethodBase",
    "_color",
    "_alpha",
    "_colorR",
    "_colorG",
    "_colorB",
    "_ambient",
    "iInitVO",
    "shaderObject",
    "methodVO",
    "uvDependencies",
    "iInitConstants",
    "updateColor",
    "m",
    "iGetFragmentCode",
    "targetReg",
    "registerCache",
    "sharedRegisters",
    "_iInitRegisters",
    "_iGetFragmentCode",
    "uvVarying",
    "alphaThreshold",
    "cutOffReg",
    "getFreeFragmentConstant",
    "ambientInputRegister",
    "iActivate",
    "activate",
    "fragmentConstantData",
    "data",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod",
    "AmbientEnvMapMethod",
    "regCache",
    "normalFragment",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod",
    "CurveBasicMethod",
    "LightingMethodBase",
    "_multiply",
    "_diffuseColor",
    "_ambientColor",
    "_diffuseR",
    "_diffuseG",
    "_diffuseB",
    "_ambientR",
    "_ambientG",
    "_ambientB",
    "iIsUsed",
    "iInvalidateShaderProgram",
    "_texture",
    "textureObject",
    "getTextureObject",
    "updateDiffuse",
    "updateAmbient",
    "diff",
    "multiply",
    "iCleanCompilationData",
    "_pTotalLightColorReg",
    "iGetFragmentPreLightingCode",
    "_pIsFirstLight",
    "addFragmentTempUsages",
    "getFreeFragmentVectorTemp",
    "iGetFragmentCodePerLight",
    "lightDirReg",
    "lightColReg",
    "commons",
    "usesLightFallOff",
    "_iModulateMethod",
    "removeFragmentTempUsage",
    "iGetFragmentCodePerProbe",
    "cubeMapReg",
    "weightRegister",
    "iGetFragmentPostLightingCode",
    "albedo",
    "shadowTarget",
    "pApplyShadow",
    "ambientColorRegister",
    "diffuseInputRegister",
    "iSetRenderState",
    "renderable",
    "camera",
    "ambientR",
    "ambientG",
    "ambientB",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod",
    "DiffuseCompositeMethod",
    "DiffuseCelMethod",
    "levels",
    "baseMethod",
    "_this",
    "_smoothness",
    "clampDiffuse",
    "_levels",
    "_dataReg",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod",
    "ShadingMethodEvent",
    "modulateMethod",
    "_onShaderInvalidatedDelegate",
    "event",
    "onShaderInvalidated",
    "pBaseMethod",
    "addEventListener",
    "SHADER_INVALIDATED",
    "removeEventListener",
    "iDeactivate",
    "iGetVertexCode",
    "awayjs-renderergl/lib/events/ShadingMethodEvent",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod",
    "DiffuseDepthMethod",
    "temp",
    "decReg",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod",
    "DiffuseGradientMethod",
    "gradient",
    "_gradient",
    "secondaryTextureObject",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod",
    "DiffuseLightMapMethod",
    "lightMap",
    "useSecondaryUV",
    "_useSecondaryUV",
    "_lightMap",
    "secondaryUVDependencies",
    "_blendMode",
    "MULTIPLY",
    "secondaryUVVarying",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod",
    "DiffuseSubSurfaceMethod",
    "depthMapSize",
    "depthMapOffset",
    "_translucency",
    "_scatterColor",
    "_scatterR",
    "_scatterG",
    "_scatterB",
    "scatterLight",
    "_scattering",
    "vertexConstantData",
    "_lightProjVarying",
    "_propReg",
    "_lightColorReg",
    "_colorReg",
    "_decReg",
    "_targetReg",
    "scatterColor",
    "lightProjection",
    "toTexRegister",
    "getFreeVertexVectorTemp",
    "getFreeVertexConstant",
    "getFreeVarying",
    "viewDirFragment",
    "_depthPass",
    "_iGetDepthMap",
    "_iGetProjection",
    "copyRawDataTo",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod",
    "DiffuseWrapMethod",
    "wrapFactor",
    "_wrapDataRegister",
    "_wrapFactor",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod",
    "EffectMethodBase",
    "EffectAlphaMaskMethod",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod",
    "EffectColorMatrixMethod",
    "matrix",
    "_matrix",
    "colorMultReg",
    "colorOffsetReg",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod",
    "EffectColorTransformMethod",
    "_colorTransform",
    "colorOffsReg",
    "inv",
    "redMultiplier",
    "greenMultiplier",
    "blueMultiplier",
    "redOffset",
    "greenOffset",
    "blueOffset",
    "alphaOffset",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod",
    "EffectEnvMapMethod",
    "envMap",
    "_envMap",
    "_mask",
    "dataRegister",
    "temp2",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod",
    "EffectFogMethod",
    "minDistance",
    "maxDistance",
    "fogColor",
    "_minDistance",
    "_maxDistance",
    "_fogColor",
    "_fogR",
    "_fogG",
    "_fogB",
    "fogData",
    "projectionFragment",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod",
    "EffectFresnelEnvMapMethod",
    "_fresnelPower",
    "_normalReflectance",
    "viewDirReg",
    "normalReg",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod",
    "EffectLightMapMethod",
    "AbstractMethodError",
    "awayjs-core/lib/errors/AbstractMethodError",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod",
    "EffectRefractionEnvMapMethod",
    "refractionIndex",
    "dispersionR",
    "dispersionG",
    "dispersionB",
    "_dispersionR",
    "_dispersionG",
    "_dispersionB",
    "_useDispersion",
    "_refractionIndex",
    "useDispersion",
    "data2",
    "refractionDir",
    "refractionColor",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod",
    "EffectRimLightMethod",
    "strength",
    "power",
    "blend",
    "_strength",
    "_power",
    "dataRegister2",
    "MIX",
    "_normalMap",
    "normalDependencies",
    "iOutputsTangentNormals",
    "bnm",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod",
    "NormalHeightMapMethod",
    "heightMap",
    "worldWidth",
    "worldHeight",
    "worldDepth",
    "_worldXYRatio",
    "_worldXZRatio",
    "width",
    "height",
    "dataReg",
    "dataReg2",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod",
    "NormalSimpleWaterMethod",
    "secondaryNormalMap",
    "_water1OffsetX",
    "_water1OffsetY",
    "_water2OffsetX",
    "_water2OffsetY",
    "_secondaryNormalMap",
    "AssetBase",
    "iUsesTangentSpace",
    "dispatchEvent",
    "awayjs-core/lib/library/AssetBase",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod",
    "Event",
    "DirectionalLight",
    "ShadowMapMethodBase",
    "ShadowCascadeMethod",
    "shadowMethodBase",
    "_baseMethod",
    "_pCastingLight",
    "_cascadeShadowMapper",
    "shadowMapper",
    "CHANGE",
    "onCascadeChange",
    "tempVO",
    "depthMap",
    "fragmentData",
    "vertexData",
    "_cascadeProjections",
    "_depthMapCoordVaryings",
    "initProjectionsRegs",
    "numCascades",
    "globalPositionVertex",
    "planeDistanceReg",
    "planeDistances",
    "inQuad",
    "uvCoord",
    "uvProjection",
    "_iGetCascadeFragmentCode",
    "vertexIndex",
    "depth",
    "_pEpsilon",
    "k",
    "getDepthProjections",
    "fragmentIndex",
    "_pAlpha",
    "nearPlaneDistances",
    "_iNearPlaneDistances",
    "iActivateForCascade",
    "awayjs-core/lib/events/Event",
    "awayjs-display/lib/entities/DirectionalLight",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod",
    "BitmapImage2D",
    "ShadowMethodBase",
    "ShadowDitheredMethod",
    "numSamples",
    "range",
    "_depthMapSize",
    "_grainUsages",
    "_grainTexture",
    "initGrainTexture",
    "_numSamples",
    "_range",
    "_grainBitmapImage2D",
    "vec",
    "step",
    "g",
    "random",
    "floor",
    "setArray",
    "rect",
    "_pGetPlanarFragmentCode",
    "customDataReg",
    "getSampleCode",
    "uvReg",
    "projectionReg",
    "_pDepthMapCoordReg",
    "addSample",
    "decodeRegister",
    "depthProjection",
    "targetRegister",
    "awayjs-core/lib/data/BitmapImage2D",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod",
    "ShadowFilteredMethod",
    "size",
    "depthCol",
    "predicate",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod",
    "ShadowHardMethod",
    "_pGetPointFragmentCode",
    "epsReg",
    "posReg",
    "depthSampleCol",
    "lightDir",
    "globalPositionVarying",
    "castsShadows",
    "_pShadowMapper",
    "PointLight",
    "_pUsePoint",
    "_pGetPointVertexCode",
    "pGetPlanarVertexCode",
    "depthMapProj",
    "iDepthProjection",
    "pow",
    "fallOff",
    "pos",
    "scenePosition",
    "x",
    "y",
    "z",
    "awayjs-display/lib/entities/PointLight",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod",
    "ShadowNearMethod",
    "fadeRatio",
    "_fadeRatio",
    "_nearShadowMapper",
    "epsilon",
    "getFreeFragmentSingleTemp",
    "near",
    "projection",
    "far",
    "coverageRatio",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod",
    "PoissonLookup",
    "ShadowSoftMethod",
    "_offsets",
    "getDistribution",
    "texRange",
    "offsets",
    "numRegs",
    "reg",
    "awayjs-core/lib/geom/PoissonLookup",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod",
    "SpecularAnisotropicMethod",
    "tangentVarying",
    "_pSpecularTexData",
    "_pSpecularDataRegister",
    "_gloss",
    "_specular",
    "_specularColor",
    "_iSpecularR",
    "_iSpecularG",
    "_iSpecularB",
    "updateSpecular",
    "bsm",
    "spec",
    "useSmoothTextures",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod",
    "SpecularCompositeMethod",
    "SpecularCelMethod",
    "specularCutOff",
    "_specularCutOff",
    "clampSpecular",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod",
    "SpecularFresnelMethod",
    "basedOnSurface",
    "modulateSpecular",
    "_incidentLight",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod",
    "SpecularPhongMethod",
    "PassMode",
    "LightSources",
    "ShaderLightingObject",
    "ShaderObjectBase",
    "RenderPassBase",
    "renderObject",
    "renderObjectOwner",
    "_maxLights",
    "_includeCasters",
    "_iMethodVOs",
    "_numEffectDependencies",
    "_onLightsChangeDelegate",
    "onLightsChange",
    "_onMethodInvalidatedDelegate",
    "onMethodInvalidated",
    "_shader",
    "_updateShader",
    "_updateLights",
    "_lightPicker",
    "enableLightFallOff",
    "diffuseLightSources",
    "specularLightSources",
    "_iInitConstantData",
    "colorTransformMethod",
    "_iColorTransformMethodVO",
    "_removeDependency",
    "_addDependency",
    "effectsDependency",
    "invalidatePass",
    "hasEffectMethod",
    "getDependencyForMethod",
    "_iNormalMethodVO",
    "_iAmbientMethodVO",
    "_iShadowMethodVO",
    "_iDiffuseMethodVO",
    "_iSpecularMethodVO",
    "_iActivate",
    "_iRender",
    "viewProjection",
    "_iDeactivate",
    "_iIncludeDependencies",
    "usesFragmentAnimation",
    "usesTangentSpace",
    "usesLights",
    "globalPosDependencies",
    "usesGlobalPosFragment",
    "setupAndCountDependencies",
    "projectionDependencies",
    "tangentDependencies",
    "viewDirDependencies",
    "_iGetPreLightingVertexCode",
    "_iGetPreLightingFragmentCode",
    "shadedTarget",
    "_iGetPerLightDiffuseFragmentCode",
    "diffuseColorReg",
    "_iGetPerLightSpecularFragmentCode",
    "specularColorReg",
    "_iGetPerProbeDiffuseFragmentCode",
    "texReg",
    "weightReg",
    "_iGetPerProbeSpecularFragmentCode",
    "_iGetPostLightingVertexCode",
    "_iGetPostLightingFragmentCode",
    "useAlphaPremultiplied",
    "_pEnableBlending",
    "_pUsesTangentSpace",
    "usesProbes",
    "_pOutputsTangentNormals",
    "_pOutputsNormals",
    "_iGetNormalVertexCode",
    "_iGetNormalFragmentCode",
    "removeVertexTempUsage",
    "_iGetVertexCode",
    "sharedReg",
    "alphaReg",
    "_iUsesShadows",
    "castingDirectionalLights",
    "castingPointLights",
    "_iUsesSpecular",
    "_iUsesDiffuse",
    "numDirectionalLightsOld",
    "numPointLightsOld",
    "numLightProbesOld",
    "calculateNumDirectionalLights",
    "calculateNumPointLights",
    "calculateNumProbes",
    "min",
    "numFree",
    "numChannels",
    "PROBES",
    "awayjs-display/lib/materials/LightSources",
    "awayjs-renderergl/lib/compilation/ShaderLightingObject",
    "awayjs-renderergl/lib/compilation/ShaderObjectBase",
    "awayjs-renderergl/lib/passes/RenderPassBase",
    "awayjs-methodmaterials/lib/passes/SingleObjectDepthPass",
    "TriangleSubGeometry",
    "Matrix3D",
    "ContextGLProgramType",
    "SingleObjectDepthPass",
    "_textureSize",
    "_polyOffset",
    "_projectionTexturesInvalid",
    "_textures",
    "key",
    "updateProjectionTextures",
    "_projections",
    "renderableOwner",
    "id",
    "context",
    "light",
    "lights",
    "_renderObjectOwner",
    "allPickedLights",
    "rId",
    "iGetObjectProjectionMatrix",
    "sourceEntity",
    "setRenderTarget",
    "clear",
    "setProgramConstantsFromMatrix",
    "VERTEX",
    "setProgramConstantsFromArray",
    "FRAGMENT",
    "_enc",
    "activateBuffer",
    "getVertexData",
    "POSITION_DATA",
    "getVertexOffset",
    "POSITION_FORMAT",
    "NORMAL_DATA",
    "NORMAL_FORMAT",
    "drawTriangles",
    "getIndexBuffer",
    "getIndexData",
    "numTriangles",
    "awayjs-core/lib/data/TriangleSubGeometry",
    "awayjs-core/lib/geom/Matrix3D",
    "awayjs-stagegl/lib/base/ContextGLProgramType"
  ],
  "mappings": "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",
  "file": "awayjs-methodmaterials.min.js",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "class MethodMaterialMode\n{\n\t/**\n\t *\n\t */\n\tpublic static SINGLE_PASS:string = \"singlePass\";\n\n\t/**\n\t *\n\t */\n\tpublic static MULTI_PASS:string = \"multiPass\";\n}\n\nexport = MethodMaterialMode;",
    null,
    "﻿import BlendMode\t\t\t\t\t= require(\"awayjs-core/lib/data/BlendMode\");\nimport Image2D\t\t\t\t\t\t= require(\"awayjs-core/lib/data/Image2D\");\n\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport StaticLightPicker\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\nimport IRenderObjectOwner\t\t\t= require(\"awayjs-display/lib/base/IRenderObjectOwner\");\nimport MaterialBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\nimport IRenderObject\t\t\t\t= require(\"awayjs-display/lib/pool/IRenderObject\");\nimport Single2DTexture\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ContextGLCompareMode\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\n\nimport RenderObjectPool\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/RenderObjectPool\");\n\nimport RenderMethodMaterialObject\t= require(\"awayjs-methodmaterials/lib/compilation/RenderMethodMaterialObject\");\nimport AmbientBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport NormalBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport MethodMaterialMode\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\n\n/**\n * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,\n * using material methods to define their appearance.\n */\nclass MethodMaterial extends MaterialBase\n{\n\tpublic static assetType:string = \"[materials MethodMaterial]\";\n\n\tprivate _effectMethods:Array<EffectMethodBase> = new Array<EffectMethodBase>();\n\tprivate _mode:string;\n\n\tprivate _ambientMethod:AmbientBasicMethod = new AmbientBasicMethod();\n\tprivate _shadowMethod:ShadowMapMethodBase;\n\tprivate _diffuseMethod:DiffuseBasicMethod = new DiffuseBasicMethod();\n\tprivate _normalMethod:NormalBasicMethod = new NormalBasicMethod();\n\tprivate _specularMethod:SpecularBasicMethod = new SpecularBasicMethod();\n\n\n\tprivate _depthCompareMode:string = ContextGLCompareMode.LESS_EQUAL;\n\n\tprivate static register = MethodMaterial.addRenderable();\n\n\tprivate static addRenderable()\n\t{\n\t\tRenderObjectPool.registerClass(RenderMethodMaterialObject, MethodMaterial);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn MethodMaterial.assetType;\n\t}\n\n\t/**\n\t * Creates a new MethodMaterial object.\n\t *\n\t * @param texture The texture used for the material's albedo color.\n\t * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.\n\t * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to false.\n\t * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to false.\n\t */\n\tconstructor(texture?:Image2D, smooth?:boolean, repeat?:boolean, mipmap?:boolean);\n\tconstructor(texture?:TextureBase, smooth?:boolean, repeat?:boolean, mipmap?:boolean);\n\tconstructor(color?:number, alpha?:number);\n\tconstructor(textureColor:any = null, smoothAlpha:any = null, repeat:boolean = false, mipmap:boolean = true)\n\t{\n\t\tsuper();\n\n\t\tthis._mode = MethodMaterialMode.SINGLE_PASS;\n\n\t\tif (textureColor instanceof Image2D)\n\t\t\ttextureColor = new Single2DTexture(textureColor);\n\n\t\tif (textureColor instanceof TextureBase) {\n\t\t\tthis.texture = <TextureBase> textureColor;\n\n\t\t\tthis.smooth = (smoothAlpha == null)? true : false;\n\t\t\tthis.repeat = repeat;\n\t\t\tthis.mipmap = mipmap;\n\t\t} else {\n\t\t\tthis.color = (textureColor == null)? 0xFFFFFF : Number(textureColor);\n\t\t\tthis.alpha = (smoothAlpha == null)? 1 : Number(smoothAlpha);\n\t\t}\n\t}\n\n\n\tpublic get mode():string\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:string)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\n\t\tthis._mode = value;\n\n\t\tthis._pInvalidateRenderObject();\n\t}\n\n\t/**\n\t * The depth compare mode used to render the renderables using this material.\n\t *\n\t * @see away.stagegl.ContextGLCompareMode\n\t */\n\n\tpublic get depthCompareMode():string\n\t{\n\t\treturn this._depthCompareMode;\n\t}\n\n\tpublic set depthCompareMode(value:string)\n\t{\n\t\tif (this._depthCompareMode == value)\n\t\t\treturn;\n\n\t\tthis._depthCompareMode = value;\n\n\t\tthis._pInvalidateRenderObject();\n\t}\n\n\t/**\n\t * The texture object to use for the ambient colour.\n\t */\n\tpublic get diffuseTexture():TextureBase\n\t{\n\t\treturn this._diffuseMethod.texture;\n\t}\n\n\tpublic set diffuseTexture(value:TextureBase)\n\t{\n\t\tthis._diffuseMethod.texture = value;\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._ambientMethod;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._ambientMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._ambientMethod)\n\t\t\tvalue.copyFrom(this._ambientMethod);\n\n\t\tthis._ambientMethod = value;\n\n\t\tthis._pInvalidateRenderObject();\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._shadowMethod;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._shadowMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._shadowMethod)\n\t\t\tvalue.copyFrom(this._shadowMethod);\n\n\t\tthis._shadowMethod = value;\n\n\t\tthis._pInvalidateRenderObject();\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._diffuseMethod;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._diffuseMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._diffuseMethod)\n\t\t\tvalue.copyFrom(this._diffuseMethod);\n\n\t\tthis._diffuseMethod = value;\n\n\t\tthis._pInvalidateRenderObject();\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._specularMethod;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._specularMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._specularMethod)\n\t\t\tvalue.copyFrom(this._specularMethod);\n\n\t\tthis._specularMethod = value;\n\n\t\tthis._pInvalidateRenderObject();\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._normalMethod;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._normalMethod == value)\n\t\t\treturn;\n\n\t\tif (value && this._normalMethod)\n\t\t\tvalue.copyFrom(this._normalMethod);\n\n\t\tthis._normalMethod = value;\n\n\t\tthis._pInvalidateRenderObject();\n\t}\n\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._effectMethods.length;\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._effectMethods.push(method);\n\n\t\tthis._pInvalidateRenderObject();\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\treturn this._effectMethods[index];\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tthis._effectMethods.splice(index, 0, method);\n\n\t\tthis._pInvalidateRenderObject();\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._effectMethods.splice(this._effectMethods.indexOf(method), 1);\n\n\t\tthis._pInvalidateRenderObject();\n\t}\n\n\t/**\n\t * The normal map to modulate the direction of the surface for each texel. The default normal method expects\n\t * tangent-space normal maps, but others could expect object-space maps.\n\t */\n\tpublic get normalMap():TextureBase\n\t{\n\t\treturn this._normalMethod.normalMap;\n\t}\n\n\tpublic set normalMap(value:TextureBase)\n\t{\n\t\tthis._normalMethod.normalMap = value;\n\t}\n\n\t/**\n\t * A specular map that defines the strength of specular reflections for each texel in the red channel,\n\t * and the gloss factor in the green channel. You can use Specular2DTexture if you want to easily set\n\t * specular and gloss maps from grayscale images, but correctly authored images are preferred.\n\t */\n\tpublic get specularMap():TextureBase\n\t{\n\t\treturn this._specularMethod.texture;\n\t}\n\n\tpublic set specularMap(value:TextureBase)\n\t{\n\t\tthis._specularMethod.texture = value;\n\t}\n\n\t/**\n\t * The glossiness of the material (sharpness of the specular highlight).\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._specularMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._specularMethod.gloss = value;\n\t}\n\n\t/**\n\t * The strength of the ambient reflection.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambientMethod.ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tthis._ambientMethod.ambient = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular reflection.\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._specularMethod.specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tthis._specularMethod.specular = value;\n\t}\n\n\t/**\n\t * The colour of the ambient reflection.\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this._diffuseMethod.ambientColor;\n\t}\n\n\tpublic set ambientColor(value:number)\n\t{\n\t\tthis._diffuseMethod.ambientColor = value;\n\t}\n\n\t/**\n\t * The colour of the diffuse reflection.\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this._diffuseMethod.diffuseColor;\n\t}\n\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tthis._diffuseMethod.diffuseColor = value;\n\t}\n\n\t/**\n\t * The colour of the specular reflection.\n\t */\n\tpublic get specularColor():number\n\t{\n\t\treturn this._specularMethod.specularColor;\n\t}\n\n\tpublic set specularColor(value:number)\n\t{\n\t\tthis._specularMethod.specularColor = value;\n\t}\n}\n\nexport = MethodMaterial;",
    "import BlendMode\t\t\t\t\t\t= require(\"awayjs-core/lib/data/BlendMode\");\nimport TriangleSubGeometry\t\t\t\t= require(\"awayjs-core/lib/data/TriangleSubGeometry\");\nimport ColorTransform\t\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Matrix\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport Matrix3DUtils\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3DUtils\");\nimport Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderObjectOwner\t\t\t\t= require(\"awayjs-display/lib/base/IRenderObjectOwner\");\nimport StaticLightPicker\t\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\nimport ContextGLCompareMode\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport RenderObjectPool\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/RenderObjectPool\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport RenderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/RenderObjectBase\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/IRenderableClass\");\n\nimport MethodMaterial\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterial\");\nimport MethodPassMode\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/passes/MethodPassMode\");\nimport MethodPass\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/passes/MethodPass\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectColorTransformMethod\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport MethodMaterialMode\t\t\t\t= require(\"awayjs-methodmaterials/lib/MethodMaterialMode\");\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass RenderMethodMaterialObject extends RenderObjectBase\n{\n\tprivate _material:MethodMaterial;\n\tprivate _screenPass:MethodPass;\n\tprivate _casterLightPass:MethodPass;\n\tprivate _nonCasterLightPasses:Array<MethodPass>;\n\t\n\t/**\n\t * The maximum total number of lights provided by the light picker.\n\t */\n\tprivate get numLights():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights + this._material.lightPicker.numCastingDirectionalLights + this._material.lightPicker.numCastingPointLights : 0;\n\t}\n\n\t/**\n\t * The amount of lights that don't cast shadows.\n\t */\n\tprivate get numNonCasters():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights : 0;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(pool:RenderObjectPool, material:MethodMaterial, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(pool, material, renderableClass, stage);\n\n\t\tthis._material = material;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pUpdateRenderObject()\n\t{\n\t\tsuper._pUpdateRenderObject();\n\n\t\tthis.initPasses();\n\n\t\tthis.setBlendAndCompareModes();\n\n\t\tthis._pClearScreenPasses();\n\n\t\tif (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this._casterLightPass)\n\t\t\t\tthis._pAddScreenPass(this._casterLightPass);\n\n\t\t\tif (this._nonCasterLightPasses)\n\t\t\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\t\t\tthis._pAddScreenPass(this._nonCasterLightPasses[i]);\n\t\t}\n\n\t\tif (this._screenPass)\n\t\t\tthis._pAddScreenPass(this._screenPass);\n\t}\n\n\t/**\n\t * Initializes all the passes and their dependent passes.\n\t */\n\tprivate initPasses()\n\t{\n\t\t// let the effects pass handle everything if there are no lights, when there are effect methods applied\n\t\t// after shading, or when the material mode is single pass.\n\t\tif (this.numLights == 0 || this._material.numEffectMethods > 0 || this._material.mode == MethodMaterialMode.SINGLE_PASS)\n\t\t\tthis.initEffectPass();\n\t\telse if (this._screenPass)\n\t\t\tthis.removeEffectPass();\n\n\t\t// only use a caster light pass if shadows need to be rendered\n\t\tif (this._material.shadowMethod && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initCasterLightPass();\n\t\telse if (this._casterLightPass)\n\t\t\tthis.removeCasterLightPass();\n\n\t\t// only use non caster light passes if there are lights that don't cast\n\t\tif (this.numNonCasters > 0 && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initNonCasterLightPasses();\n\t\telse if (this._nonCasterLightPasses)\n\t\t\tthis.removeNonCasterLightPasses();\n\t}\n\n\t/**\n\t * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.\n\t */\n\tprivate setBlendAndCompareModes()\n\t{\n\t\tvar forceSeparateMVP:boolean = Boolean(this._casterLightPass || this._screenPass);\n\n\t\t// caster light pass is always first if it exists, hence it uses normal blending\n\t\tif (this._casterLightPass) {\n\t\t\tthis._casterLightPass.forceSeparateMVP = forceSeparateMVP;\n\t\t\tthis._casterLightPass.setBlendMode(BlendMode.NORMAL);\n\t\t\tthis._casterLightPass.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\n\t\tif (this._nonCasterLightPasses) {\n\t\t\tvar firstAdditiveIndex:number = 0;\n\n\t\t\t// if there's no caster light pass, the first non caster light pass will be the first\n\t\t\t// and should use normal blending\n\t\t\tif (!this._casterLightPass) {\n\t\t\t\tthis._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[0].setBlendMode(BlendMode.NORMAL);\n\t\t\t\tthis._nonCasterLightPasses[0].depthCompareMode = this._material.depthCompareMode;\n\t\t\t\tfirstAdditiveIndex = 1;\n\t\t\t}\n\n\t\t\t// all lighting passes following the first light pass should use additive blending\n\t\t\tfor (var i:number = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {\n\t\t\t\tthis._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[i].setBlendMode(BlendMode.ADD);\n\t\t\t\tthis._nonCasterLightPasses[i].depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t}\n\t\t}\n\n\t\tif (this._casterLightPass || this._nonCasterLightPasses) {\n\t\t\t//cannot be blended by blendmode property if multipass enabled\n\t\t\tthis._pRequiresBlending = false;\n\n\t\t\t// there are light passes, so this should be blended in\n\t\t\tif (this._screenPass) {\n\t\t\t\tthis._screenPass.mode = MethodPassMode.EFFECTS;\n\t\t\t\tthis._screenPass.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t\tthis._screenPass.setBlendMode(BlendMode.LAYER);\n\t\t\t\tthis._screenPass.forceSeparateMVP = forceSeparateMVP;\n\t\t\t}\n\n\t\t} else if (this._screenPass) {\n\t\t\tthis._pRequiresBlending = (this._material.blendMode != BlendMode.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));\n\t\t\t// effects pass is the only pass, so it should just blend normally\n\t\t\tthis._screenPass.mode = MethodPassMode.SUPER_SHADER;\n\t\t\tthis._screenPass.depthCompareMode = this._material.depthCompareMode;\n\t\t\tthis._screenPass.preserveAlpha = this._pRequiresBlending;\n\t\t\tthis._screenPass.colorTransform = this._material.colorTransform;\n\t\t\tthis._screenPass.setBlendMode((this._material.blendMode == BlendMode.NORMAL && this._pRequiresBlending)? BlendMode.LAYER : this._material.blendMode);\n\t\t\tthis._screenPass.forceSeparateMVP = false;\n\t\t}\n\t}\n\n\tprivate initCasterLightPass()\n\t{\n\n\t\tif (this._casterLightPass == null)\n\t\t\tthis._casterLightPass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._renderableClass, this._stage);\n\n\t\tthis._casterLightPass.lightPicker = new StaticLightPicker([this._material.shadowMethod.castingLight]);\n\t\tthis._casterLightPass.shadowMethod = this._material.shadowMethod;\n\t\tthis._casterLightPass.diffuseMethod = this._material.diffuseMethod;\n\t\tthis._casterLightPass.ambientMethod = this._material.ambientMethod;\n\t\tthis._casterLightPass.normalMethod = this._material.normalMethod;\n\t\tthis._casterLightPass.specularMethod = this._material.specularMethod;\n\t}\n\n\tprivate removeCasterLightPass()\n\t{\n\t\tthis._casterLightPass.dispose();\n\t\tthis._pRemoveScreenPass(this._casterLightPass);\n\t\tthis._casterLightPass = null;\n\t}\n\n\tprivate initNonCasterLightPasses()\n\t{\n\t\tthis.removeNonCasterLightPasses();\n\t\tvar pass:MethodPass;\n\t\tvar numDirLights:number = this._material.lightPicker.numDirectionalLights;\n\t\tvar numPointLights:number = this._material.lightPicker.numPointLights;\n\t\tvar numLightProbes:number = this._material.lightPicker.numLightProbes;\n\t\tvar dirLightOffset:number = 0;\n\t\tvar pointLightOffset:number = 0;\n\t\tvar probeOffset:number = 0;\n\n\t\tif (!this._casterLightPass) {\n\t\t\tnumDirLights += this._material.lightPicker.numCastingDirectionalLights;\n\t\t\tnumPointLights += this._material.lightPicker.numCastingPointLights;\n\t\t}\n\n\t\tthis._nonCasterLightPasses = new Array<MethodPass>();\n\n\t\twhile (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {\n\t\t\tpass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._renderableClass, this._stage);\n\t\t\tpass.includeCasters = this._material.shadowMethod == null;\n\t\t\tpass.directionalLightsOffset = dirLightOffset;\n\t\t\tpass.pointLightsOffset = pointLightOffset;\n\t\t\tpass.lightProbesOffset = probeOffset;\n\t\t\tpass.lightPicker = this._material.lightPicker;\n\t\t\tpass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tpass.ambientMethod = this._material.ambientMethod;\n\t\t\tpass.normalMethod = this._material.normalMethod;\n\t\t\tpass.specularMethod = this._material.specularMethod;\n\t\t\tthis._nonCasterLightPasses.push(pass);\n\n\t\t\tdirLightOffset += pass.numDirectionalLights;\n\t\t\tpointLightOffset += pass.numPointLights;\n\t\t\tprobeOffset += pass.numLightProbes;\n\t\t}\n\t}\n\n\tprivate removeNonCasterLightPasses()\n\t{\n\t\tif (!this._nonCasterLightPasses)\n\t\t\treturn;\n\n\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\tthis._pRemoveScreenPass(this._nonCasterLightPasses[i]);\n\n\t\tthis._nonCasterLightPasses = null;\n\t}\n\n\tprivate removeEffectPass()\n\t{\n\t\tif (this._screenPass.ambientMethod != this._material.ambientMethod)\n\t\t\tthis._screenPass.ambientMethod.dispose();\n\n\t\tif (this._screenPass.diffuseMethod != this._material.diffuseMethod)\n\t\t\tthis._screenPass.diffuseMethod.dispose();\n\n\t\tif (this._screenPass.specularMethod != this._material.specularMethod)\n\t\t\tthis._screenPass.specularMethod.dispose();\n\n\t\tif (this._screenPass.normalMethod != this._material.normalMethod)\n\t\t\tthis._screenPass.normalMethod.dispose();\n\n\t\tthis._pRemoveScreenPass(this._screenPass);\n\t\tthis._screenPass = null;\n\t}\n\n\tprivate initEffectPass()\n\t{\n\t\tif (this._screenPass == null)\n\t\t\tthis._screenPass = new MethodPass(MethodPassMode.SUPER_SHADER, this, this._material, this._renderableClass, this._stage);\n\n\t\tif (this._material.mode == MethodMaterialMode.SINGLE_PASS) {\n\t\t\tthis._screenPass.ambientMethod = this._material.ambientMethod;\n\t\t\tthis._screenPass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tthis._screenPass.specularMethod = this._material.specularMethod;\n\t\t\tthis._screenPass.normalMethod = this._material.normalMethod;\n\t\t\tthis._screenPass.shadowMethod = this._material.shadowMethod;\n\t\t} else if (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this.numLights == 0) {\n\t\t\t\tthis._screenPass.ambientMethod = this._material.ambientMethod;\n\t\t\t} else {\n\t\t\t\tthis._screenPass.ambientMethod = null;\n\t\t\t}\n\n\t\t\tthis._screenPass.preserveAlpha = false;\n\t\t\tthis._screenPass.normalMethod = this._material.normalMethod;\n\t\t}\n\n\t\t//update effect methods\n\t\tvar i:number = 0;\n\t\tvar effectMethod:EffectMethodBase;\n\t\tvar len:number = Math.max(this._material.numEffectMethods, this._screenPass.numEffectMethods);\n\n\t\twhile (i < len) {\n\t\t\teffectMethod = this._material.getEffectMethodAt(i);\n\t\t\tif (effectMethod != this._screenPass.getEffectMethodAt(i)) {\n\t\t\t\tthis._screenPass.removeEffectMethodAt(i);\n\n\t\t\t\tif (effectMethod != null) {\n\t\t\t\t\tif (i < this._screenPass.numEffectMethods)\n\t\t\t\t\t\tthis._screenPass.addEffectMethodAt(effectMethod, i);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis._screenPass.addEffectMethod(effectMethod);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\t//TODO\n\t}\n}\n\nexport = RenderMethodMaterialObject;",
    "import TextureObjectBase\t\t\t= require(\"awayjs-renderergl/lib/pool/TextureObjectBase\");\n\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * MethodVO contains data for a given shader object for the use within a single material.\n * This allows shader methods to be shared across materials while their non-public state differs.\n */\nclass MethodVO\n{\n\tpublic useMethod:boolean = true;\n\n\tpublic method:ShadingMethodBase;\n\n\t// public register indices\n\tpublic textureObject:TextureObjectBase;\n\tpublic secondaryTextureObject:TextureObjectBase; // sometimes needed for composites\n\tpublic vertexConstantsIndex:number;\n\tpublic secondaryVertexConstantsIndex:number; // sometimes needed for composites\n\tpublic fragmentConstantsIndex:number;\n\tpublic secondaryFragmentConstantsIndex:number; // sometimes needed for composites\n\n\t// internal stuff for the material to know before assembling code\n\tpublic needsProjection:boolean;\n\tpublic needsView:boolean;\n\tpublic needsNormals:boolean;\n\tpublic needsTangents:boolean;\n\tpublic needsGlobalVertexPos:boolean;\n\tpublic needsGlobalFragmentPos:boolean;\n\t/**\n\t * Creates a new MethodVO object.\n\t */\n\tconstructor(method:ShadingMethodBase)\n\t{\n\t\tthis.method = method;\n\t}\n\n\t/**\n\t * Resets the values of the value object to their \"unused\" state.\n\t */\n\tpublic reset()\n\t{\n\t\tthis.method.iReset();\n\n\t\tthis.vertexConstantsIndex = -1;\n\t\tthis.secondaryVertexConstantsIndex = -1;\n\t\tthis.fragmentConstantsIndex = -1;\n\t\tthis.secondaryFragmentConstantsIndex = -1;\n\n\t\tthis.needsProjection = false;\n\t\tthis.needsView = false;\n\t\tthis.needsNormals = false;\n\t\tthis.needsTangents = false;\n\t\tthis.needsGlobalVertexPos = false;\n\t\tthis.needsGlobalFragmentPos = false;\n\t}\n}\n\nexport = MethodVO;\n",
    "import Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass AmbientBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tif (shaderObject.texture)\n\t\t\tshaderObject.uvDependencies++;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tif (!shaderObject.texture) {\n\t\t\tthis._color = shaderObject.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:AmbientBasicMethod = <AmbientBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shaderObject.texture) {\n\t\t\tshaderObject.texture._iInitRegisters(shaderObject, registerCache);\n\n\t\t\tcode += shaderObject.texture._iGetFragmentCode(shaderObject, targetReg, registerCache, sharedRegisters.uvVarying);\n\n\t\t\tif (shaderObject.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tvar ambientInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (shaderObject.texture) {\n\t\t\tshaderObject.texture.activate(shaderObject);\n\n\t\t\tif (shaderObject.alphaThreshold > 0)\n\t\t\t\tshaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex] = shaderObject.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\n\nexport = AmbientBasicMethod;",
    "import ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\n\n/**\n * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to\n * approximate global lighting rather than lights.\n */\nclass AmbientEnvMapMethod extends AmbientBasicMethod\n{\n\t/**\n\t * Creates a new <code>AmbientEnvMapMethod</code> object.\n\t *\n\t * @param envMap The cube environment map to use for the ambient lighting.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tshaderObject.texture._iInitRegisters(shaderObject, regCache);\n\n\t\treturn shaderObject.texture._iGetFragmentCode(shaderObject, targetReg, regCache, sharedRegisters.normalFragment);\n\t}\n}\n\nexport = AmbientEnvMapMethod;",
    "import Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nclass CurveBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tif (shaderObject.texture)\n\t\t\tshaderObject.uvDependencies++;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tif (!shaderObject.texture) {\n\t\t\tthis._color = shaderObject.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar m:any = method;\n\t\tvar b:CurveBasicMethod = <CurveBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n    /*\n    public iGeVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string {\n        var code:string = \"\";\n        code = \"mov \" + sharedRegisters.uvVarying + \" \" + registerCache.uv +  \" \\n\";\n    }*/\n    public iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar ambientInputRegister:ShaderRegisterElement;\n\n\t\tif (shaderObject.texture) {\n\t\t\tshaderObject.texture._iInitRegisters(shaderObject, registerCache);\n\n\t\t\tcode += shaderObject.texture._iGetFragmentCode(shaderObject, targetReg, registerCache, sharedRegisters.uvVarying);\n\n\t\t\tif (shaderObject.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tambientInputRegister = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n        code = \"mov \" + targetReg + \", \" + sharedRegisters.uvVarying + \"\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (shaderObject.texture) {\n\t\t\tshaderObject.texture.activate(shaderObject);\n\n\t\t\tif (shaderObject.alphaThreshold > 0)\n\t\t\t\tshaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex] = shaderObject.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor()\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\nexport = CurveBasicMethod;",
    "import Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\nimport LightingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\n\n/**\n * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.\n */\nclass DiffuseBasicMethod extends LightingMethodBase\n{\n\tprivate _multiply:boolean = true;\n\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\n\tpublic _texture:TextureBase;\n\tprivate _diffuseColor:number = 0xffffff;\n\tprivate _ambientColor:number = 0xffffff;\n\tprivate _diffuseR:number = 1;\n\tprivate _diffuseG:number = 1;\n\tprivate _diffuseB:number = 1;\n\tprivate _ambientR:number = 1;\n\tprivate _ambientG:number = 1;\n\tprivate _ambientB:number = 1;\n\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shaderObject:ShaderLightingObject):boolean\n\t{\n\t\tif (!shaderObject.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Set internally if diffuse color component multiplies or replaces the ambient color\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this._multiply;\n\t}\n\n\tpublic set multiply(value:boolean)\n\t{\n\t\tif (this._multiply == value)\n\t\t\treturn;\n\n\t\tthis._multiply = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureObject = shaderObject.getTextureObject(this._texture);\n\t\t\tshaderObject.uvDependencies++;\n\t\t} else if (methodVO.textureObject) {\n\t\t\tmethodVO.textureObject.dispose();\n\t\t\tmethodVO.textureObject = null;\n\t\t}\n\n\n\t\tmethodVO.needsNormals = shaderObject.numLights > 0;\n\t}\n\n\t/**\n\t * The color of the diffuse reflection when not using a texture.\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this._diffuseColor;\n\t}\n\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tif (this._diffuseColor == value)\n\t\t\treturn;\n\n\t\tthis._diffuseColor = value;\n\n\t\tthis.updateDiffuse();\n\t}\n\n\t/**\n\t * The color of the ambient reflection\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this._ambientColor;\n\t}\n\n\tpublic set ambientColor(value:number)\n\t{\n\t\tif (this._ambientColor == value)\n\t\t\treturn;\n\n\t\tthis._ambientColor = value;\n\n\t\tthis.updateAmbient();\n\t}\n\n\n\t/**\n\t * The bitmapData to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tthis._texture = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar diff:DiffuseBasicMethod = <DiffuseBasicMethod> method;\n\n\t\tthis.texture = diff.texture;\n\t\tthis.multiply = diff.multiply;\n\t\tthis.diffuseColor = diff.diffuseColor;\n\t\tthis.ambientColor = diff.ambientColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pTotalLightColorReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \", \" + sharedRegisters.normalFragment + \"\\n\" +\n\t\t\t\t\"max \" + t + \".w, \" + t + \".x, \" + sharedRegisters.commons + \".y\\n\";\n\n\t\tif (shaderObject.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".w, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shaderObject:ShaderLightingObject, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"tex \" + t + \", \" + sharedRegisters.normalFragment + \", \" + cubeMapReg + \" <cube,linear,miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tvar albedo:ShaderRegisterElement;\n\t\tvar cutOffReg:ShaderRegisterElement;\n\n\t\t// incorporate input from ambient\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += this.pApplyShadow(shaderObject, methodVO, registerCache, sharedRegisters);\n\n\t\tregisterCache.addFragmentTempUsages(albedo = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar ambientColorRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = ambientColorRegister.index*4;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\t\tcode += methodVO.textureObject._iGetFragmentCode(shaderObject, albedo, registerCache, sharedRegisters.uvVarying);\n\t\t} else {\n\t\t\tvar diffuseInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\t\tcode += \"mov \" + albedo + \", \" + diffuseInputRegister + \"\\n\";\n\t\t}\n\n\t\tcode += \"sat \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\"mul \" + albedo + \".xyz, \" + albedo + \", \" + this._pTotalLightColorReg + \"\\n\";\n\n\t\tif (this._multiply) {\n\t\t\tcode += \"add \" + albedo + \".xyz, \" + albedo + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + albedo + \"\\n\";\n\t\t} else {\n\t\t\tcode += \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + albedo + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\tregisterCache.removeFragmentTempUsage(albedo);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Generate the code that applies the calculated shadow to the diffuse light\n\t * @param methodVO The MethodVO object for which the compilation is currently happening.\n\t * @param regCache The register cache the compiler is currently using for the register management.\n\t */\n\tpublic pApplyShadow(shaderObject:ShaderLightingObject, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureObject.activate(shaderObject);\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\t\tdata[index + 4] = this._diffuseR;\n\t\t\tdata[index + 5] = this._diffuseG;\n\t\t\tdata[index + 6] = this._diffuseB;\n\t\t\tdata[index + 7] = 1;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the diffuse color data used by the render state.\n\t */\n\tprivate updateDiffuse()\n\t{\n\t\tthis._diffuseR = ((this._diffuseColor >> 16) & 0xff)/0xff;\n\t\tthis._diffuseG = ((this._diffuseColor >> 8) & 0xff)/0xff;\n\t\tthis._diffuseB = (this._diffuseColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateAmbient()\n\t{\n\t\tthis._ambientR = ((this._ambientColor >> 16) & 0xff)/0xff;\n\t\tthis._ambientG = ((this._ambientColor >> 8) & 0xff)/0xff;\n\t\tthis._ambientB = (this._ambientColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderLightingObject, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\t//TODO move this to Activate (ambientR/G/B currently calc'd in render state)\n\t\tif (shaderObject.numLights > 0) {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\t\tdata[index] = shaderObject.ambientR*this._ambientR;\n\t\t\tdata[index + 1] = shaderObject.ambientG*this._ambientG;\n\t\t\tdata[index + 2] = shaderObject.ambientB*this._ambientB;\n\t\t\tdata[index + 3] = 1;\n\t\t}\n\t}\n}\n\nexport = DiffuseBasicMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.\n */\nclass DiffuseCelMethod extends DiffuseCompositeMethod\n{\n\tprivate _levels:number /*uint*/;\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\n\t/**\n\t * Creates a new DiffuseCelMethod object.\n\t * @param levels The amount of shadow gradations.\n\t * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.\n\t */\n\tconstructor(levels:number /*uint*/ = 3, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampDiffuse(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._levels = levels;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tsuper.iInitConstants(shaderObject, methodVO);\n\t\tdata[index + 1] = 1;\n\t\tdata[index + 2] = 0;\n\t}\n\n\t/**\n\t * The amount of shadow gradations.\n\t */\n\tpublic get levels():number /*uint*/\n\t{\n\t\treturn this._levels;\n\t}\n\n\tpublic set levels(value:number /*uint*/)\n\t{\n\t\tthis._levels = value;\n\t}\n\n\t/**\n\t * The smoothness of the edge between 2 shading levels.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = this._levels;\n\t\tdata[index + 3] = this._smoothness;\n\t}\n\n\t/**\n\t * Snaps the diffuse shading of the wrapped method to one of the levels.\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the diffuse strength in the \"w\" component.\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampDiffuse(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"frc \" + targetReg + \".z, \" + targetReg + \".w\\n\" +\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t\"mov \" + targetReg + \".x, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"rcp \" + targetReg + \".x,\" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\n\t\t\t// previous clamped strength\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".x\\n\" +\n\n\t\t\t// fract/epsilon (so 0 - epsilon will become 0 - 1)\n\t\t\t\"div \" + targetReg + \".z, \" + targetReg + \".z, \" + this._dataReg + \".w\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t// 1-z\n\t\t\t\"sub \" + targetReg + \".z, \" + this._dataReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t}\n}\n\nexport = DiffuseCelMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the\n * calculated diffuse reflection strength.\n */\nclass DiffuseCompositeMethod extends DiffuseBasicMethod\n{\n\tpublic pBaseMethod:DiffuseBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new <code>DiffuseCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.\n\t * @param baseMethod The base diffuse method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis.pBaseMethod = baseMethod || new DiffuseBasicMethod();\n\t\tthis.pBaseMethod._iModulateMethod = modulateMethod;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base diffuse method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this.pBaseMethod;\n\t}\n\n\tpublic set baseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this.pBaseMethod == value)\n\t\t\treturn;\n\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod = value;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitVO(shaderObject, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tthis.pBaseMethod.iInitConstants(shaderObject, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this.pBaseMethod.texture;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis.pBaseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get diffuseColor():number\n\t{\n\t\treturn this.pBaseMethod.diffuseColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set diffuseColor(value:number)\n\t{\n\t\tthis.pBaseMethod.diffuseColor = value;\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get ambientColor():number\n\t{\n\t\treturn this.pBaseMethod.ambientColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set ambientColor(value:number)\n\t{\n\t\tthis.pBaseMethod.ambientColor = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerLight(shaderObject, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shaderObject:ShaderLightingObject, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerProbe(shaderObject, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iActivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderLightingObject, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis.pBaseMethod.iSetRenderState(shaderObject, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis.pBaseMethod.iDeactivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetVertexCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPostLightingCode(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.pBaseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis.pBaseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = DiffuseCompositeMethod;",
    "import ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseDepthMethod provides a debug method to visualise depth maps\n */\nclass DiffuseDepthMethod extends DiffuseBasicMethod\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = 1.0;\n\t\tdata[index + 1] = 1/255.0;\n\t\tdata[index + 2] = 1/65025.0;\n\t\tdata[index + 3] = 1/16581375.0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement;\n\t\tvar decReg:ShaderRegisterElement;\n\n\t\tif (!this._texture)\n\t\t\tthrow new Error(\"DiffuseDepthMethod requires texture!\");\n\n\t\t// incorporate input from ambient\n\t\tif (shaderObject.numLights > 0) {\n\t\t\tif (sharedRegisters.shadowTarget)\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t\t\tcode += \"add \" + targetReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"sat \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\t\tregisterCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);\n\t\t} else {\n\t\t\ttemp = targetReg;\n\t\t}\n\n\t\tdecReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tmethodVO.textureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\tcode += methodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, sharedRegisters.uvVarying) +\n\t\t\t\"dp4 \" + temp + \".x, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"mov \" + temp + \".yz, \" + temp + \".xx\t\t\t\\n\" +\n\t\t\t\"mov \" + temp + \".w, \" + decReg + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + decReg + \".xxx, \" + temp + \".xyz\\n\";\n\n\t\tif (shaderObject.numLights == 0)\n\t\t\treturn code;\n\n\t\tcode += \"mul \" + targetReg + \".xyz, \" + temp + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mov \" + targetReg + \".w, \" + temp + \".w\\n\";\n\n\t\tif (shaderObject.numLights > 0)\n\t\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseDepthMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient\n * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude\n * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate\n * scattered light within the skin attributing to the final colour)\n */\nclass DiffuseGradientMethod extends DiffuseBasicMethod\n{\n\tprivate _gradient:TextureBase;\n\n\t/**\n\t * Creates a new DiffuseGradientMethod object.\n\t * @param gradient A texture that contains the light colour based on the angle. This can be used to change\n\t * the light colour due to subsurface scattering when the surface faces away from the light.\n\t */\n\tconstructor(gradient:TextureBase)\n\t{\n\t\tsuper();\n\n\t\tthis._gradient = gradient;\n\t}\n\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shaderObject, methodVO);\n\n\t\tmethodVO.secondaryTextureObject = shaderObject.getTextureObject(this._gradient);\n\t}\n\n\t/**\n\t * A texture that contains the light colour based on the angle. This can be used to change the light colour\n\t * due to subsurface scattering when the surface faces away from the light.\n\t */\n\tpublic get gradient():TextureBase\n\t{\n\t\treturn this._gradient;\n\t}\n\n\tpublic set gradient(value:TextureBase)\n\t{\n\t\tif (this._gradient == value)\n\t\t\treturn;\n\n\t\tthis._gradient = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\n\t\tif (shaderObject.numLights > 0)\n\t\t\tmethodVO.secondaryTextureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += methodVO.secondaryTextureObject._iGetFragmentCode(shaderObject, t, registerCache, t) +\n\t\t\t//\t\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + t + \".w\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + lightColReg + \".xyz\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic pApplyShadow(shaderObject:ShaderLightingObject, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar t:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn \"mov \" + t + \", \" + sharedRegisters.shadowTarget + \".wwww\\n\" +\n\t\t\tmethodVO.secondaryTextureObject._iGetFragmentCode(shaderObject, t, regCache, sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureObject.activate(shaderObject);\n\t}\n}\n\nexport = DiffuseGradientMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\n\n/**\n * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse\n * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather\n * than only the diffuse lighting value.\n */\nclass DiffuseLightMapMethod extends DiffuseCompositeMethod\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t * This can be used to add pre-calculated shadows or occlusion.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t * This can be used to add pre-calculated lighting or global illumination.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new DiffuseLightMapMethod method.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t\tthis._lightMap = lightMap;\n\t\tthis.blendMode = blendMode;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tmethodVO.secondaryTextureObject = shaderObject.getTextureObject(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshaderObject.secondaryUVDependencies++;\n\t\telse\n\t\t\tshaderObject.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see DiffuseLightMapMethod.ADD\n\t * @see DiffuseLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture containing the light map data.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tthis._lightMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tmethodVO.secondaryTextureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\tcode = methodVO.secondaryTextureObject._iGetFragmentCode(shaderObject, temp, registerCache, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase DiffuseLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase DiffuseLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcode += super.iGetFragmentPostLightingCode(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureObject.activate(shaderObject);\n\t}\n}\n\nexport = DiffuseLightMapMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport DiffuseCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\");\nimport SingleObjectDepthPass\t\t\t= require(\"awayjs-methodmaterials/lib/passes/SingleObjectDepthPass\");\n\n/**\n * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of\n * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.\n * It can be used for candle wax, ice, skin, ...\n */\nclass DiffuseSubSurfaceMethod extends DiffuseCompositeMethod\n{\n\tprivate _depthPass:SingleObjectDepthPass;\n\tprivate _lightProjVarying:ShaderRegisterElement;\n\tprivate _propReg:ShaderRegisterElement;\n\tprivate _scattering:number;\n\tprivate _translucency:number = 1;\n\tprivate _lightColorReg:ShaderRegisterElement;\n\tprivate _scatterColor:number /*uint*/ = 0xffffff;\n\tprivate _colorReg:ShaderRegisterElement;\n\tprivate _decReg:ShaderRegisterElement;\n\tprivate _scatterR:number = 1.0;\n\tprivate _scatterG:number = 1.0;\n\tprivate _scatterB:number = 1.0;\n\tprivate _targetReg:ShaderRegisterElement;\n\t\n\t/**\n\t * Creates a new <code>DiffuseSubSurfaceMethod</code> object.\n\t *\n\t * @param depthMapSize The size of the depth map used.\n\t * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(depthMapSize:number /*int*/ = 512, depthMapOffset:number = 15, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.pBaseMethod._iModulateMethod = (shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.scatterLight(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\t//this._passes = new Array<MaterialPassGLBase>();\n\t\t//this._depthPass = new SingleObjectDepthPass();\n\t\t//this._depthPass.textureSize = depthMapSize;\n\t\t//this._depthPass.polyOffset = depthMapOffset;\n\t\t//this._passes.push(this._depthPass);\n\t\tthis._scattering = 0.2;\n\t\tthis._translucency = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shaderObject, methodVO);\n\n\t\tvar data:Array<number> = shaderObject.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryVertexConstantsIndex;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = -.5;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\t\n\t\tdata = shaderObject.fragmentConstantData;\n\t\tindex = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index + 3] = 1.0;\n\t\tdata[index + 4] = 1.0;\n\t\tdata[index + 5] = 1/255;\n\t\tdata[index + 6] = 1/65025;\n\t\tdata[index + 7] = 1/16581375;\n\t\tdata[index + 10] = .5;\n\t\tdata[index + 11] = -.1;\n\t}\n\t\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._lightProjVarying = null;\n\t\tthis._propReg = null;\n\t\tthis._lightColorReg = null;\n\t\tthis._colorReg = null;\n\t\tthis._decReg = null;\n\t\tthis._targetReg = null;\n\t}\n\t\n\t/**\n\t * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low\n\t * values for skin.\n\t */\n\tpublic get scattering():number\n\t{\n\t\treturn this._scattering;\n\t}\n\t\n\tpublic set scattering(value:number)\n\t{\n\t\tthis._scattering = value;\n\t}\n\t\n\t/**\n\t * The translucency of the object.\n\t */\n\tpublic get translucency():number\n\t{\n\t\treturn this._translucency;\n\t}\n\t\n\tpublic set translucency(value:number)\n\t{\n\t\tthis._translucency = value;\n\t}\n\t\n\t/**\n\t * The colour of the \"insides\" of the object, ie: the colour the light becomes after leaving the object.\n\t */\n\tpublic get scatterColor():number /*uint*/\n\t{\n\t\treturn this._scatterColor;\n\t}\n\t\n\tpublic set scatterColor(scatterColor:number /*uint*/)\n\t{\n\t\tthis._scatterColor = scatterColor;\n\t\tthis._scatterR = ((scatterColor >> 16) & 0xff)/0xff;\n\t\tthis._scatterG = ((scatterColor >> 8) & 0xff)/0xff;\n\t\tthis._scatterB = (scatterColor & 0xff)/0xff;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetVertexCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t\tvar lightProjection:ShaderRegisterElement;\n\t\tvar toTexRegister:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\t\t\n\t\ttoTexRegister = registerCache.getFreeVertexConstant();\n\t\tmethodVO.secondaryVertexConstantsIndex = toTexRegister.index*4;\n\n\t\tthis._lightProjVarying = registerCache.getFreeVarying();\n\t\tlightProjection = registerCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\t\n\t\tcode += \"m44 \" + temp + \", vt0, \" + lightProjection + \"\\n\" +\n\t\t\t\"div \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xy\\n\" +\n\t\t\t\"add \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xx\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".w, va0.w\\n\";\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._colorReg = registerCache.getFreeFragmentConstant();\n\t\tthis._decReg = registerCache.getFreeFragmentConstant();\n\t\tthis._propReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._colorReg.index*4;\n\t\t\n\t\treturn super.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pIsFirstLight = true;\n\t\tthis._lightColorReg = lightColReg;\n\t\treturn super.iGetFragmentCodePerLight(shaderObject, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPostLightingCode(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\t\n\t\tcode += \"mul \" + temp + \".xyz, \" + this._lightColorReg + \".xyz, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + this._colorReg + \".xyz\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t\n\t\tif (this._targetReg != sharedRegisters.viewDirFragment)\n\t\t\tregisterCache.removeFragmentTempUsage(targetReg);\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = this._scatterR;\n\t\tdata[index + 1] = this._scatterG;\n\t\tdata[index + 2] = this._scatterB;\n\t\tdata[index + 8] = this._scattering;\n\t\tdata[index + 9] = this._translucency;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderObjectBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tmethodVO.secondaryTextureObject = shaderObject.getTextureObject(this._depthPass._iGetDepthMap(renderable));\n\t\tmethodVO.secondaryTextureObject.activate(shaderObject);\n\n\t\tthis._depthPass._iGetProjection(renderable).copyRawDataTo(shaderObject.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);\n\t}\n\t\n\t/**\n\t * Generates the code for this method\n\t */\n\tprivate scatterLight(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// only scatter first light\n\t\tif (!this._pIsFirstLight)\n\t\t\treturn \"\";\n\n\t\tthis._pIsFirstLight = false;\n\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.viewDirFragment)\n\t\t\tthis._targetReg = sharedRegisters.viewDirFragment;\n\t\telse\n\t\t\tregisterCache.addFragmentTempUsages(this._targetReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += methodVO.secondaryTextureObject._iGetFragmentCode(shaderObject, temp, registerCache, this._lightProjVarying) +\n\t\t\t// reencode RGBA\n\t\t\t\"dp4 \" + targetReg + \".z, \" + temp + \", \" + this._decReg + \"\\n\";\n\t\t// currentDistanceToLight - closestDistanceToLight\n\t\tcode += \"sub \" + targetReg + \".z, \" + this._lightProjVarying + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t\"sub \" + targetReg + \".z, \" + this._propReg + \".x, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".z, \" + this._propReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t// targetReg.x contains dot(lightDir, normal)\n\t\t\t// modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)\n\t\t\t\"neg \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"mul \" + this._targetReg + \".w, \" + targetReg + \".z, \" + targetReg + \".y\\n\" +\n\t\t\t\n\t\t\t// blend diffuse: d' = (1-s)*d + s*1\n\t\t\t\"sub \" + targetReg + \".y, \" + this._colorReg + \".w, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t\t\n\t\treturn code;\n\t}\n}\n\nexport = DiffuseSubSurfaceMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\n\n/**\n * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be \"wrapped around\" the normally dark area, to some extent.\n * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.\n */\nclass DiffuseWrapMethod extends DiffuseBasicMethod\n{\n\tprivate _wrapDataRegister:ShaderRegisterElement;\n\tprivate _wrapFactor:number;\n\n\t/**\n\t * Creates a new DiffuseWrapMethod object.\n\t * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap\n\t */\n\tconstructor(wrapFactor:number = .5)\n\t{\n\t\tsuper();\n\n\t\tthis.wrapFactor = wrapFactor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._wrapDataRegister = null;\n\t}\n\n\t/**\n\t * A factor to indicate the amount by which the light is allowed to wrap.\n\t */\n\tpublic get wrapFactor():number\n\t{\n\t\treturn this._wrapFactor;\n\t}\n\n\tpublic set wrapFactor(value:number)\n\t{\n\t\tthis._wrapFactor = value;\n\t\tthis._wrapFactor = 1/(value + 1);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\t\tthis._wrapDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index*4;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + t + \".y, \" + t + \".x, \" + this._wrapDataRegister + \".x\\n\" +\n\t\t\t\"mul \" + t + \".y, \" + t + \".y, \" + this._wrapDataRegister + \".y\\n\" +\n\t\t\t\"sat \" + t + \".w, \" + t + \".y\\n\" +\n\t\t\t\"mul \" + t + \".xz, \" + t + \".w, \" + lightDirReg + \".wz\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, lightDirReg, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".x, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = this._wrapFactor;\n\t\tdata[index + 1] = 1/(this._wrapFactor + 1);\n\t}\n}\n\nexport = DiffuseWrapMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used\n * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water\n * etc).\n */\nclass EffectAlphaMaskMethod extends EffectMethodBase\n{\n\tprivate _texture:TextureBase;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectAlphaMaskMethod object.\n\t *\n\t * @param texture The texture to use as the alpha mask.\n\t * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.\n\t */\n\tconstructor(texture:TextureBase, useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureObject = shaderObject.getTextureObject(this._texture);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshaderObject.secondaryUVDependencies++;\n\t\telse\n\t\t\tshaderObject.uvDependencies++;\n\t}\n\n\t/**\n\t * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for\n\t * instance to tile the main texture and normal map while providing untiled alpha, for example to define the\n\t * transparency over a tiled water surface.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture to use as the alpha mask.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tthis._texture = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \".x\\n\";\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tmethodVO.textureObject.activate(shaderObject);\n\t}\n}\n\nexport = EffectAlphaMaskMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.\n */\nclass EffectColorMatrixMethod extends EffectMethodBase\n{\n\tprivate _matrix:Array<number>;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t *\n\t * @param matrix An array of 20 items for 4 x 5 color transform.\n\t */\n\tconstructor(matrix:Array<number>)\n\t{\n\t\tsuper();\n\n\t\tif (matrix.length != 20)\n\t\t\tthrow new Error(\"Matrix length must be 20!\");\n\n\t\tthis._matrix = matrix;\n\t}\n\n\t/**\n\t * The 4 x 5 matrix to transform the color of the material.\n\t */\n\tpublic get colorMatrix():Array<number>\n\t{\n\t\treturn this._matrix;\n\t}\n\n\tpublic set colorMatrix(value:Array<number>)\n\t{\n\t\tthis._matrix = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\n\t\tvar colorOffsetReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += \"m44 \" + temp + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + temp + \", \" + colorOffsetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar matrix:Array<number> = this._matrix;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\n\t\t// r\n\t\tdata[index] = matrix[0];\n\t\tdata[index + 1] = matrix[1];\n\t\tdata[index + 2] = matrix[2];\n\t\tdata[index + 3] = matrix[3];\n\n\t\t// g\n\t\tdata[index + 4] = matrix[5];\n\t\tdata[index + 5] = matrix[6];\n\t\tdata[index + 6] = matrix[7];\n\t\tdata[index + 7] = matrix[8];\n\n\t\t// b\n\t\tdata[index + 8] = matrix[10];\n\t\tdata[index + 9] = matrix[11];\n\t\tdata[index + 10] = matrix[12];\n\t\tdata[index + 11] = matrix[13];\n\n\t\t// a\n\t\tdata[index + 12] = matrix[15];\n\t\tdata[index + 13] = matrix[16];\n\t\tdata[index + 14] = matrix[17];\n\t\tdata[index + 15] = matrix[18];\n\n\t\t// rgba offset\n\t\tdata[index + 16] = matrix[4];\n\t\tdata[index + 17] = matrix[9];\n\t\tdata[index + 18] = matrix[14];\n\t\tdata[index + 19] = matrix[19];\n\t}\n}\n\nexport = EffectColorMatrixMethod;",
    "import ColorTransform\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a\n * ColorTransform object.\n */\nclass EffectColorTransformMethod extends EffectMethodBase\n{\n\tprivate _colorTransform:ColorTransform;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this._colorTransform;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tthis._colorTransform = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar colorOffsReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\t//TODO: AGAL <> GLSL\n\n\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" + \"add \" + targetReg + \", \" + targetReg + \", \" + colorOffsReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar inv:number = 1/0xff;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\n\t\tdata[index] = this._colorTransform.redMultiplier;\n\t\tdata[index + 1] = this._colorTransform.greenMultiplier;\n\t\tdata[index + 2] = this._colorTransform.blueMultiplier;\n\t\tdata[index + 3] = this._colorTransform.alphaMultiplier;\n\t\tdata[index + 4] = this._colorTransform.redOffset*inv;\n\t\tdata[index + 5] = this._colorTransform.greenOffset*inv;\n\t\tdata[index + 6] = this._colorTransform.blueOffset*inv;\n\t\tdata[index + 7] = this._colorTransform.alphaOffset*inv;\n\n\t}\n}\n\nexport = EffectColorTransformMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.\n */\nclass EffectEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates an EffectEnvMapMethod object.\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the surface.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (value == this._mask)\n\t\t\treturn;\n\n\t\tthis._mask = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureObject = shaderObject.getTextureObject(this._envMap);\n\n\t\tif (this._mask != null) {\n\t\t\tmethodVO.secondaryTextureObject = shaderObject.getTextureObject(this._mask);\n\t\t\tshaderObject.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tthis._envMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tshaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;\n\n\t\tmethodVO.textureObject.activate(shaderObject);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureObject.activate(shaderObject);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\tmethodVO.textureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\t// r = I - 2(I.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + sharedRegisters.normalFragment + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\" +\n\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, temp) +\n\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" + // -.5\n\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\tif (this._mask) {\n\t\t\tmethodVO.secondaryTextureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\t\tcode += methodVO.secondaryTextureObject._iGetFragmentCode(shaderObject, temp2, registerCache, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + temp + \", \" + temp2 + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + dataRegister + \".x\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFogMethod provides a method to add distance-based fog to a material.\n */\nclass EffectFogMethod extends EffectMethodBase\n{\n\tprivate _minDistance:number = 0;\n\tprivate _maxDistance:number = 1000;\n\tprivate _fogColor:number /*uint*/;\n\tprivate _fogR:number;\n\tprivate _fogG:number;\n\tprivate _fogB:number;\n\n\t/**\n\t * Creates a new EffectFogMethod object.\n\t * @param minDistance The distance from which the fog starts appearing.\n\t * @param maxDistance The distance at which the fog is densest.\n\t * @param fogColor The colour of the fog.\n\t */\n\tconstructor(minDistance:number, maxDistance:number, fogColor:number /*uint*/ = 0x808080)\n\t{\n\t\tsuper();\n\t\tthis.minDistance = minDistance;\n\t\tthis.maxDistance = maxDistance;\n\t\tthis.fogColor = fogColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 6] = 0;\n\t\tdata[index + 7] = 0;\n\t}\n\n\t/**\n\t * The distance from which the fog starts appearing.\n\t */\n\tpublic get minDistance():number\n\t{\n\t\treturn this._minDistance;\n\t}\n\n\tpublic set minDistance(value:number)\n\t{\n\t\tthis._minDistance = value;\n\t}\n\n\t/**\n\t * The distance at which the fog is densest.\n\t */\n\tpublic get maxDistance():number\n\t{\n\t\treturn this._maxDistance;\n\t}\n\n\tpublic set maxDistance(value:number)\n\t{\n\t\tthis._maxDistance = value;\n\t}\n\n\t/**\n\t * The colour of the fog.\n\t */\n\tpublic get fogColor():number /*uint*/\n\t{\n\t\treturn this._fogColor;\n\t}\n\n\tpublic set fogColor(value:number/*uint*/)\n\t{\n\t\tthis._fogColor = value;\n\t\tthis._fogR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._fogG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._fogB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._fogR;\n\t\tdata[index + 1] = this._fogG;\n\t\tdata[index + 2] = this._fogB;\n\t\tdata[index + 4] = this._minDistance;\n\t\tdata[index + 5] = 1/(this._maxDistance - this._minDistance);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar fogColor:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar fogData:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\t\tmethodVO.fragmentConstantsIndex = fogColor.index*4;\n\n\t\tcode += \"sub \" + temp2 + \".w, \" + sharedRegisters.projectionFragment + \".z, \" + fogData + \".x\\n\" +\n\t\t\t\t\"mul \" + temp2 + \".w, \" + temp2 + \".w, \" + fogData + \".y\\n\" +\n\t\t\t\t\"sat \" + temp2 + \".w, \" + temp2 + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \", \" + fogColor + \", \" + targetReg + \"\\n\" + // (fogColor- col)\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + temp2 + \".w\\n\" + // (fogColor- col)*fogRatio\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\"; // fogRatio*(fogColor- col) + col\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFogMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets\n * stronger as the viewing angle becomes more grazing.\n */\nclass EffectFresnelEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = 0;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates a new <code>EffectFresnelEnvMapMethod</code> object.\n\t *\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the material.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureObject = shaderObject.getTextureObject(this._envMap);\n\n\t\tif (this._mask != null) {\n\t\t\tmethodVO.secondaryTextureObject = shaderObject.getTextureObject(this._mask);\n\t\t\tshaderObject.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tshaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (this._mask == value)\n\t\t\treturn;\n\t\t\n\t\tthis._mask = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tthis._envMap = value;\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._alpha;\n\t\tdata[index + 1] = this._normalReflectance;\n\t\tdata[index + 2] = this._fresnelPower;\n\n\t\tmethodVO.textureObject.activate(shaderObject);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureObject.activate(shaderObject);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\tmethodVO.textureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\t// r = V - 2(V.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + normalReg + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + viewDirReg + \".xyz\\n\" +\n\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, temp) +\n\t\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +               \t// -.5\n\t\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\t// calculate fresnel term\n\t\tcode += \"dp3 \" + viewDirReg + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +  // dot(V, H)\n\t\t\t\t\"sub \" + viewDirReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +       // base = 1-dot(V, H)\n\t\t\t\t\"pow \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + dataRegister + \".z\\n\" +       // exp = pow(base, 5)\n\t\t\t\t\"sub \" + normalReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +        // 1 - exp\n\t\t\t\t\"mul \" + normalReg + \".w, \" + dataRegister + \".y, \" + normalReg + \".w\\n\" +         // f0*(1 - exp)\n\t\t\t\t\"add \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + normalReg + \".w\\n\" +          // exp + f0*(1 - exp)\n\n\t\t\t\t// total alpha\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + dataRegister + \".x, \" + viewDirReg + \".w\\n\";\n\n\t\tif (this._mask) {\n\t\t\tmethodVO.secondaryTextureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\t\tcode += methodVO.secondaryTextureObject._iGetFragmentCode(shaderObject, temp2, registerCache, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + temp2 + \".x, \" + viewDirReg + \".w\\n\";\n\t\t}\n\n\t\t// blend\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + viewDirReg + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectFresnelEnvMapMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.\n * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather\n * than the whole pixel colour.\n */\nclass EffectLightMapMethod extends EffectMethodBase\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectLightMapMethod object.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tif (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._lightMap = lightMap;\n\t\tthis._blendMode = blendMode;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.textureObject = shaderObject.getTextureObject(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshaderObject.secondaryUVDependencies++;\n\t\telse\n\t\t\tshaderObject.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see EffectLightMapMethod.ADD\n\t * @see EffectLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tif (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The lightMap containing the light map.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tthis._lightMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureObject._iGetFragmentCode(shaderObject, temp, registerCache, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase EffectLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase EffectLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tmethodVO.textureObject.activate(shaderObject);\n\t}\n}\n\nexport = EffectLightMapMethod;",
    "import IAsset\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\nimport AbstractMethodError\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,\n * and are in essence post-process effects on the materials.\n */\nclass EffectMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset EffectMethod]\";\n\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn EffectMethodBase.assetType;\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register that will be containing the method's output.\n\t * @private\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n}\n\nexport = EffectMethodBase;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.\n */\nclass EffectRefractionEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\n\tprivate _dispersionR:number = 0;\n\tprivate _dispersionG:number = 0;\n\tprivate _dispersionB:number = 0;\n\tprivate _useDispersion:boolean;\n\tprivate _refractionIndex:number;\n\tprivate _alpha:number = 1;\n\n\t/**\n\t * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015\n\t *\n\t * @param envMap The environment map containing the refracted scene.\n\t * @param refractionIndex The refractive index of the material.\n\t * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tconstructor(envMap:TextureBase, refractionIndex:number = .1, dispersionR:number = 0, dispersionG:number = 0, dispersionB:number = 0)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._dispersionR = dispersionR;\n\t\tthis._dispersionG = dispersionG;\n\t\tthis._dispersionB = dispersionB;\n\t\tthis._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tthis._refractionIndex = refractionIndex;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index + 4] = 1;\n\t\tdata[index + 5] = 0;\n\t\tdata[index + 7] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureObject = shaderObject.getTextureObject(this._envMap);\n\t}\n\n\t/**\n\t * The cube environment map to use for the refraction.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tthis._envMap = value;\n\t}\n\n\t/**\n\t * The refractive index of the material.\n\t */\n\tpublic get refractionIndex():number\n\t{\n\t\treturn this._refractionIndex;\n\t}\n\n\tpublic set refractionIndex(value:number)\n\t{\n\t\tthis._refractionIndex = value;\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionR():number\n\t{\n\t\treturn this._dispersionR;\n\t}\n\n\tpublic set dispersionR(value:number)\n\t{\n\t\tthis._dispersionR = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionG():number\n\t{\n\t\treturn this._dispersionG;\n\t}\n\n\tpublic set dispersionG(value:number)\n\t{\n\t\tthis._dispersionG = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionB():number\n\t{\n\t\treturn this._dispersionB;\n\t}\n\n\tpublic set dispersionB(value:number)\n\t{\n\t\tthis._dispersionB = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual\n\t * material. A value of 1 will make it appear fully transparent.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\n\t\tdata[index] = this._dispersionR + this._refractionIndex;\n\n\t\tif (this._useDispersion) {\n\t\t\tdata[index + 1] = this._dispersionG + this._refractionIndex;\n\t\t\tdata[index + 2] = this._dispersionB + this._refractionIndex;\n\t\t}\n\t\tdata[index + 3] = this._alpha;\n\n\t\tmethodVO.textureObject.activate(shaderObject);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: data2.x could use common reg, so only 1 reg is used\n\t\tvar data:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar data2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar refractionDir:ShaderRegisterElement;\n\t\tvar refractionColor:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement;\n\n\t\tmethodVO.fragmentConstantsIndex = data.index*4;\n\n\t\trefractionDir = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionDir, 1);\n\t\trefractionColor = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionColor, 1);\n\t\ttemp = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tmethodVO.textureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\"mul \" + temp + \".x, \" + data + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\"mul \" + refractionDir + \", \" + data + \".x, \" + viewDirReg + \"\\n\" +\n\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, refractionColor, registerCache, refractionDir) +\n\t\t\t\"sub \" + refractionColor + \".w, \" + refractionColor + \".w, fc0.x\t\\n\" +\n\t\t\t\"kil \" + refractionColor + \".w\\n\";\n\n\t\tif (this._useDispersion) {\n\t\t\t// GREEN\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".y, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".y, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".y, \" + temp + \".y\\n\";\n\n\t\t\t// BLUE\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".z, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".z, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".z, \" + temp + \".z\\n\";\n\t\t}\n\n\t\tcode += \"sub \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mul \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + data + \".w\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + refractionColor + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(refractionDir);\n\t\tregisterCache.removeFragmentTempUsage(refractionColor);\n\n\t\t// restore\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRefractionEnvMapMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\n\n/**\n * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.\n */\nclass EffectRimLightMethod extends EffectMethodBase\n{\n\tpublic static ADD:string = \"add\";\n\tpublic static MULTIPLY:string = \"multiply\";\n\tpublic static MIX:string = \"mix\";\n\n\tprivate _color:number /*uint*/;\n\tprivate _blendMode:string;\n\tprivate _colorR:number;\n\tprivate _colorG:number;\n\tprivate _colorB:number;\n\tprivate _strength:number;\n\tprivate _power:number;\n\n\t/**\n\t * Creates a new <code>EffectRimLightMethod</code> object.\n\t *\n\t * @param color The colour of the rim light.\n\t * @param strength The strength of the rim light.\n\t * @param power The power of the rim light. Higher values will result in a higher edge fall-off.\n\t * @param blend The blend mode with which to add the light to the object.\n\t */\n\tconstructor(color:number /*uint*/ = 0xffffff, strength:number = .4, power:number = 2, blend:string = \"mix\")\n\t{\n\t\tsuper();\n\n\t\tthis._blendMode = blend;\n\t\tthis._strength = strength;\n\t\tthis._power = power;\n\n\t\tthis.color = color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tshaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\n\t/**\n\t * The blend mode with which to add the light to the object.\n\t *\n\t * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.\n\t * EffectRimLightMethod.ADD adds the rim light with the material's colour.\n\t * EffectRimLightMethod.MIX provides normal alpha blending.\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The color of the rim light.\n\t */\n\tpublic get color():number /*uint*/\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number /*uint*/)\n\t{\n\t\tthis._color = value;\n\t\tthis._colorR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * The strength of the rim light.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._strength = value;\n\t}\n\n\t/**\n\t * The power of the rim light. Higher values will result in a higher edge fall-off.\n\t */\n\tpublic get power():number\n\t{\n\t\treturn this._power;\n\t}\n\n\tpublic set power(value:number)\n\t{\n\t\tthis._power = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = this._colorR;\n\t\tdata[index + 1] = this._colorG;\n\t\tdata[index + 2] = this._colorB;\n\t\tdata[index + 4] = this._strength;\n\t\tdata[index + 5] = this._power;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataRegister2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"sat \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"pow \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + dataRegister + \".w, \" + temp + \".x\\n\";\n\n\t\tif (this._blendMode == EffectRimLightMethod.ADD) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else {\n\t\t\tcode += \"sub \" + temp + \".xyz, \" + dataRegister + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n}\n\nexport = EffectRimLightMethod;",
    "import ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderLightingObject\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * LightingMethodBase provides an abstract base method for shading methods that uses lights.\n * Used for diffuse and specular shaders only.\n */\nclass LightingMethodBase extends ShadingMethodBase\n{\n\t/**\n\t * A method that is exposed to wrappers in case the strength needs to be controlled\n\t */\n\tpublic _iModulateMethod:(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string;\n\n\t/**\n\t * Creates a new LightingMethodBase.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * Get the fragment shader code that will be needed before any per-light code is added.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @private\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param lightDirReg The register containing the light direction vector.\n\t * @param lightColReg The register containing the light colour.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light probe object.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param cubeMapReg The register containing the cube map for the current probe\n\t * @param weightRegister A string representation of the register + component containing the current weight\n\t * @param regCache The register cache providing any necessary registers to the shader\n\t */\n\tpublic iGetFragmentCodePerProbe(shaderObject:ShaderLightingObject, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register containing the final shading output.\n\t * @private\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n}\n\nexport = LightingMethodBase;",
    "import TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalBasicMethod is the default method for standard tangent-space normal mapping.\n */\nclass NormalBasicMethod extends ShadingMethodBase\n{\n\tprivate _normalMap:TextureBase;\n\n\t/**\n\t * Creates a new NormalBasicMethod object.\n\t */\n\tconstructor(normalMap:TextureBase = null)\n\t{\n\t\tsuper();\n\n\t\tthis._normalMap = normalMap;\n\t}\n\n\tpublic iIsUsed(shaderObject:ShaderObjectBase):boolean\n\t{\n\t\tif (this._normalMap && shaderObject.normalDependencies)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tif (this._normalMap) {\n\t\t\tmethodVO.textureObject = shaderObject.getTextureObject(this._normalMap);\n\t\t\tshaderObject.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iOutputsTangentNormals():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tvar s:any = method;\n\t\tvar bnm:NormalBasicMethod = <NormalBasicMethod> method;\n\n\t\tif (bnm.normalMap != null)\n\t\t\tthis.normalMap = bnm.normalMap;\n\t}\n\n\t/**\n\t * The texture containing the normals per pixel.\n\t */\n\tpublic get normalMap():TextureBase\n\t{\n\t\treturn this._normalMap;\n\t}\n\n\tpublic set normalMap(value:TextureBase)\n\t{\n\t\tif (this._normalMap == value)\n\t\t\treturn;\n\n\t\tthis._normalMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._normalMap)\n\t\t\tthis._normalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._normalMap)\n\t\t\tmethodVO.textureObject.activate(shaderObject);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._normalMap) {\n\t\t\tmethodVO.textureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\t\tcode += methodVO.textureObject._iGetFragmentCode(shaderObject, targetReg, registerCache, sharedRegisters.uvVarying);\n\t\t}\n\n\t\tcode += \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalBasicMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.\n */\nclass NormalHeightMapMethod extends NormalBasicMethod\n{\n\tprivate _worldXYRatio:number;\n\tprivate _worldXZRatio:number;\n\n\t/**\n\t * Creates a new NormalHeightMapMethod method.\n\t *\n\t * @param heightMap The texture containing the height data. 0 means low, 1 means high.\n\t * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.\n\t * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.\n\t * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.\n\t */\n\tconstructor(heightMap:TextureBase, worldWidth:number, worldHeight:number, worldDepth:number)\n\t{\n\t\tsuper();\n\n\t\tthis.normalMap = heightMap;\n\t\tthis._worldXYRatio = worldWidth/worldHeight;\n\t\tthis._worldXZRatio = worldDepth/worldHeight;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = 1/this.normalMap.width;\n\t\tdata[index + 1] = 1/this.normalMap.height;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 4] = this._worldXYRatio;\n\t\tdata[index + 5] = this._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get tangentSpace():boolean\n\t{\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t\tsuper.copyFrom(method);\n\n\t\tthis._worldXYRatio = (<NormalHeightMapMethod> method)._worldXYRatio;\n\t\tthis._worldXZRatio = (<NormalHeightMapMethod> method)._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode+= methodVO.textureObject._iGetFragmentCode(shaderObject, targetReg, registerCache, sharedRegisters.uvVarying) +\n\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".xzzz\\n\" +\n\n\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, temp) +\n\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".zyzz\\n\" +\n\n\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, temp) +\n\n\t\t\t\"sub \" + targetReg + \".z, \" + targetReg + \".z, \" + temp + \".x\\n\" +\n\t\t\t\"mov \" + targetReg + \".y, \" + dataReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".xz, \" + targetReg + \".xz, \" + dataReg2 + \".xy\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalHeightMapMethod;",
    "import TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\n\n/**\n * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.\n */\nclass NormalSimpleWaterMethod extends NormalBasicMethod\n{\n\tprivate _secondaryNormalMap:TextureBase;\n\tprivate _water1OffsetX:number = 0;\n\tprivate _water1OffsetY:number = 0;\n\tprivate _water2OffsetX:number = 0;\n\tprivate _water2OffsetY:number = 0;\n\n\t/**\n\t * Creates a new NormalSimpleWaterMethod object.\n\t * @param waveMap1 A normal map containing one layer of a wave structure.\n\t * @param waveMap2 A normal map containing a second layer of a wave structure.\n\t */\n\tconstructor(normalMap:TextureBase = null, secondaryNormalMap:TextureBase = null)\n\t{\n\t\tsuper(normalMap);\n\n\t\tthis._secondaryNormalMap = secondaryNormalMap;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = 0;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shaderObject, methodVO);\n\t\t\n\t\tif (this._secondaryNormalMap) {\n\t\t\tmethodVO.secondaryTextureObject = shaderObject.getTextureObject(this._secondaryNormalMap);\n\t\t\tshaderObject.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the X-axis.\n\t */\n\tpublic get water1OffsetX():number\n\t{\n\t\treturn this._water1OffsetX;\n\t}\n\n\tpublic set water1OffsetX(value:number)\n\t{\n\t\tthis._water1OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the Y-axis.\n\t */\n\tpublic get water1OffsetY():number\n\t{\n\t\treturn this._water1OffsetY;\n\t}\n\n\tpublic set water1OffsetY(value:number)\n\t{\n\t\tthis._water1OffsetY = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the X-axis.\n\t */\n\tpublic get water2OffsetX():number\n\t{\n\t\treturn this._water2OffsetX;\n\t}\n\n\tpublic set water2OffsetX(value:number)\n\t{\n\t\tthis._water2OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the Y-axis.\n\t */\n\tpublic get water2OffsetY():number\n\t{\n\t\treturn this._water2OffsetY;\n\t}\n\n\tpublic set water2OffsetY(value:number)\n\t{\n\t\tthis._water2OffsetY = value;\n\t}\n\n\t/**\n\t * A second normal map that will be combined with the first to create a wave-like animation pattern.\n\t */\n\tpublic get secondaryNormalMap():TextureBase\n\t{\n\t\treturn this._secondaryNormalMap;\n\t}\n\n\tpublic set secondaryNormalMap(value:TextureBase)\n\t{\n\t\tif (this._secondaryNormalMap == value)\n\t\t\treturn;\n\n\t\tthis._secondaryNormalMap = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\tthis._secondaryNormalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\n\t\tdata[index + 4] = this._water1OffsetX;\n\t\tdata[index + 5] = this._water1OffsetY;\n\t\tdata[index + 6] = this._water2OffsetX;\n\t\tdata[index + 7] = this._water2OffsetY;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureObject.activate(shaderObject);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".xyxy\\n\";\n\n\t\tif (this.normalMap) {\n\t\t\tmethodVO.textureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\t\tcode += methodVO.textureObject._iGetFragmentCode(shaderObject, targetReg, registerCache, temp);\n\t\t}\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".zwzw\\n\";\n\n\t\tif (this._secondaryNormalMap) {\n\t\t\tmethodVO.secondaryTextureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\t\tcode += methodVO.secondaryTextureObject._iGetFragmentCode(shaderObject, temp, registerCache, temp);\n\t\t}\n\n\t\tcode +=\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\t\t\\n\" +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + dataReg + \".x\t\\n\" +\n\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\t\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\t\t\t\t\t\t\t\\n\";\n\n\t\treturn code;\n\t}\n}\n\nexport = NormalSimpleWaterMethod;",
    "import AssetBase\t\t\t\t\t= require(\"awayjs-core/lib/library/AssetBase\");\n\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport ShadingMethodEvent\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\n\n\n/**\n * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile\n * the final shading program.\n */\nclass ShadingMethodBase extends AssetBase\n{\n\tpublic static assetType:string = \"[asset ShadingMethod]\";\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadingMethodBase.assetType;\n\t}\n\n\t/**\n\t * Create a new ShadingMethodBase object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shaderObject:ShaderObjectBase):boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Initializes the properties for a MethodVO, including register and texture indices.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitVO(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\n\t}\n\n\t/**\n\t * Initializes unchanging shader constants using the data from a MethodVO.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\n\n\t}\n\n\t/**\n\t * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iUsesTangentSpace():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Cleans up any resources used by the current object.\n\t */\n\tpublic dispose()\n\t{\n\n\t}\n\n\t/**\n\t * Resets the compilation state of the method.\n\t *\n\t * @internal\n\t */\n\tpublic iReset()\n\t{\n\t\tthis.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Resets the method's state for compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t}\n\n\t/**\n\t * Get the vertex shader code for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn null;\n\t}\n\n\t/**\n\t * Sets the render state for this method.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Sets the render state for a single renderable.\n\t *\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param renderable The renderable currently being rendered.\n\t * @param stage The Stage object currently used for rendering.\n\t * @param camera The camera from which the scene is currently rendered.\n\t *\n\t * @internal\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderObjectBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\n\t}\n\n\t/**\n\t * Clears the render state for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iDeactivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\n\t}\n\n\t/**\n\t * Marks the shader program as invalid, so it will be recompiled before the next render.\n\t *\n\t * @internal\n\t */\n\tpublic iInvalidateShaderProgram()\n\t{\n\t\tthis.dispatchEvent(new ShadingMethodEvent(ShadingMethodEvent.SHADER_INVALIDATED));\n\t}\n\n\t/**\n\t * Copies the state from a ShadingMethodBase object into the current object.\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\t}\n}\n\nexport = ShadingMethodBase;",
    "import Event\t\t\t\t\t\t\t= require(\"awayjs-core/lib/events/Event\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport CascadeShadowMapper\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/CascadeShadowMapper\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.\n * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.\n *\n * @see away.lights.CascadeShadowMapper\n */\nclass ShadowCascadeMethod extends ShadowMapMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\tprivate _cascadeShadowMapper:CascadeShadowMapper;\n\tprivate _depthMapCoordVaryings:Array<ShaderRegisterElement>;\n\tprivate _cascadeProjections:Array<ShaderRegisterElement>;\n\n\t/**\n\t * Creates a new ShadowCascadeMethod object.\n\t *\n\t * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t */\n\tconstructor(shadowMethodBase:ShadowMethodBase)\n\t{\n\t\tsuper(shadowMethodBase.castingLight);\n\n\t\tthis._baseMethod = shadowMethodBase;\n\t\tif (!(this._pCastingLight instanceof DirectionalLight))\n\t\t\tthrow new Error(\"ShadowCascadeMethod is only compatible with DirectionalLight\");\n\n\t\tthis._cascadeShadowMapper = <CascadeShadowMapper> this._pCastingLight.shadowMapper;\n\n\t\tif (!this._cascadeShadowMapper)\n\t\t\tthrow new Error(\"ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.\");\n\n\t\tthis._cascadeShadowMapper.addEventListener(Event.CHANGE, (event:Event) => this.onCascadeChange(event));\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\t}\n\n\t/**\n\t * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction\n\t * with a DirectionalShadowMapper.\n\t *\n\t * @see ShadowHardMethod\n\t * @see ShadowSoftMethod\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tvar tempVO:MethodVO = new MethodVO(this._baseMethod);\n\t\tthis._baseMethod.iInitVO(shaderObject, tempVO);\n\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.textureObject = shaderObject.getTextureObject(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar vertexData:Array<number> = shaderObject.vertexConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = .5;\n\t\tfragmentData[index + 7] = -.5;\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tvertexData[index] = .5;\n\t\tvertexData[index + 1] = -.5;\n\t\tvertexData[index + 2] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._cascadeProjections = null;\n\t\tthis._depthMapCoordVaryings = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeVertexConstant();\n\n\t\tthis.initProjectionsRegs(registerCache);\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + this._cascadeProjections[i] + \"\\n\" +\n\t\t\t\t\"add \" + this._depthMapCoordVaryings[i] + \", \" + temp + \", \" + dataReg + \".zzwz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Creates the registers for the cascades' projection coordinates.\n\t */\n\tprivate initProjectionsRegs(registerCache:ShaderRegisterCache)\n\t{\n\t\tthis._cascadeProjections = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\t\tthis._depthMapCoordVaryings = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tthis._depthMapCoordVaryings[i] = registerCache.getFreeVarying();\n\t\t\tthis._cascadeProjections[i] = registerCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvar decReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistanceReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistances:Array<string> = Array<string>( planeDistanceReg + \".x\", planeDistanceReg + \".y\", planeDistanceReg + \".z\", planeDistanceReg + \".w\" );\n\t\tvar code:string;\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar inQuad:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(inQuad, 1);\n\t\tvar uvCoord:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvCoord, 1);\n\n\t\t// assume lowest partition is selected, will be overwritten later otherwise\n\t\tcode = \"mov \" + uvCoord + \", \" + this._depthMapCoordVaryings[numCascades - 1] + \"\\n\";\n\n\t\tfor (var i:number = numCascades - 2; i >= 0; --i) {\n\t\t\tvar uvProjection:ShaderRegisterElement = this._depthMapCoordVaryings[i];\n\n\t\t\t// calculate if in texturemap (result == 0 or 1, only 1 for a single partition)\n\t\t\tcode += \"slt \" + inQuad + \".z, \" + sharedRegisters.projectionFragment + \".z, \" + planeDistances[i] + \"\\n\"; // z = x > minX, w = y > minY\n\n\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t// linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)\n\t\t\tcode += \"sub \" + temp + \", \" + uvProjection + \", \" + uvCoord + \"\\n\" +\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + inQuad + \".z\\n\" +\n\t\t\t\t\"add \" + uvCoord + \", \" + uvCoord + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(inQuad);\n\n\t\tcode += \"div \" + uvCoord + \", \" + uvCoord + \", \" + uvCoord + \".w\\n\" +\n\t\t\t\"mul \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zw\\n\" +\n\t\t\t\"add \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zz\\n\";\n\n\t\tcode += this._baseMethod._iGetCascadeFragmentCode(shaderObject, methodVO, decReg, uvCoord, targetReg, registerCache, sharedRegisters) +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + dataReg + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(uvCoord);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tmethodVO.textureObject.activate(shaderObject);\n\n\t\tvar vertexData:Array<number> = shaderObject.vertexConstantData;\n\t\tvar vertexIndex:number = methodVO.vertexConstantsIndex;\n\n\t\tshaderObject.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/(this._cascadeShadowMapper.depth*this._pEpsilon);\n\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvertexIndex += 4;\n\t\tfor (var k:number = 0; k < numCascades; ++k) {\n\t\t\tthis._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);\n\t\t\tvertexIndex += 16;\n\t\t}\n\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar fragmentIndex:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[fragmentIndex + 5] = 1 - this._pAlpha;\n\n\t\tvar nearPlaneDistances:Array<number> = this._cascadeShadowMapper._iNearPlaneDistances;\n\n\t\tfragmentIndex += 8;\n\t\tfor (var i:number = 0; i < numCascades; ++i)\n\t\t\tfragmentData[fragmentIndex + i] = nearPlaneDistances[i];\n\n\t\tthis._baseMethod.iActivateForCascade(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderObjectBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t}\n\n\t/**\n\t * Called when the shadow mappers cascade configuration changes.\n\t */\n\tprivate onCascadeChange(event:Event)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowCascadeMethod;",
    "import BitmapImage2D\t\t\t\t\t= require(\"awayjs-core/lib/data/BitmapImage2D\");\n\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.\n */\nclass ShadowDitheredMethod extends ShadowMethodBase\n{\n\tprivate static _grainTexture:Single2DTexture;\n\tprivate static _grainUsages:number /*int*/;\n\tprivate static _grainBitmapImage2D:BitmapImage2D;\n\tprivate _depthMapSize:number /*int*/;\n\tprivate _range:number;\n\tprivate _numSamples:number /*int*/;\n\n\t/**\n\t * Creates a new ShadowDitheredMethod object.\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 4, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\n\t\t++ShadowDitheredMethod._grainUsages;\n\n\t\tif (!ShadowDitheredMethod._grainTexture)\n\t\t\tthis.initGrainTexture();\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tif (value < 1)\n\t\t\tvalue = 1;\n\t\telse if (value > 24)\n\t\t\tvalue = 24;\n\n\t\tif (this._numSamples == value)\n\t\t\treturn;\n\n\t\tthis._numSamples = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitVO(shaderObject, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.secondaryTextureObject = shaderObject.getTextureObject(ShadowDitheredMethod._grainTexture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shaderObject, methodVO);\n\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = 1/this._numSamples;\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range*2;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value/2;\n\t}\n\n\t/**\n\t * Creates a texture containing the dithering noise texture.\n\t */\n\tprivate initGrainTexture()\n\t{\n\t\tShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D(64, 64, false);\n\t\tvar vec:Array<number> /*uint*/ = new Array<number>();\n\t\tvar len:number /*uint*/ = 4096;\n\t\tvar step:number = 1/(this._depthMapSize*this._range);\n\t\tvar r:number, g:number;\n\n\t\tfor (var i:number /*uint*/ = 0; i < len; ++i) {\n\t\t\tr = 2*(Math.random() - .5);\n\t\t\tg = 2*(Math.random() - .5);\n\t\t\tif (r < 0)\n\t\t\t\tr -= step; else\n\t\t\t\tr += step;\n\t\t\tif (g < 0)\n\t\t\t\tg -= step; else\n\t\t\t\tg += step;\n\t\t\tif (r > 1)\n\t\t\t\tr = 1; else if (r < -1)\n\t\t\t\tr = -1;\n\t\t\tif (g > 1)\n\t\t\t\tg = 1; else if (g < -1)\n\t\t\t\tg = -1;\n\t\t\tvec[i] = (Math.floor((r*.5 + .5)*0xff) << 16) | (Math.floor((g*.5 + .5)*0xff) << 8);\n\t\t}\n\n\t\tShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);\n\t\tShadowDitheredMethod._grainTexture = new Single2DTexture(ShadowDitheredMethod._grainBitmapImage2D);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (--ShadowDitheredMethod._grainUsages == 0) {\n\t\t\tShadowDitheredMethod._grainTexture.dispose();\n\t\t\tShadowDitheredMethod._grainBitmapImage2D.dispose();\n\t\t\tShadowDitheredMethod._grainTexture = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 9] = (stage.width - 1)/63;\n\t\tdata[index + 10] = (stage.height - 1)/63;\n\t\tdata[index + 11] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureObject.activate(shaderObject);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shaderObject, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t */\n\tprivate getSampleCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, customDataReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar numSamples:number /*int*/ = this._numSamples;\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar projectionReg:ShaderRegisterElement = sharedRegisters.projectionFragment;\n\n\t\tmethodVO.textureObject._iInitRegisters(shaderObject, regCache);\n\t\tmethodVO.secondaryTextureObject._iInitRegisters(shaderObject, regCache);\n\n\t\tcode += \"div \" + uvReg + \", \" + projectionReg + \", \" + projectionReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".xy, \" + uvReg + \".xy, \" + customDataReg + \".yz\\n\";\n\n\t\twhile (numSamples > 0) {\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\tcode += methodVO.secondaryTextureObject._iGetFragmentCode(shaderObject, uvReg, regCache, uvReg);\n\t\t\t} else {\n\t\t\t\tcode += \"mov \" + temp + \", \" + uvReg + \".zwxy \\n\" +\n\t\t\t\t\tmethodVO.secondaryTextureObject._iGetFragmentCode(shaderObject, uvReg, regCache, temp);\n\t\t\t}\n\n\t\t\t// keep grain in uvReg.zw\n\t\t\tcode += \"sub \" + uvReg + \".zw, \" + uvReg + \".xy, fc0.xx\\n\" + // uv-.5\n\t\t\t\t\"mul \" + uvReg + \".zw, \" + uvReg + \".zw, \" + customDataReg + \".w\\n\"; // (tex unpack scale and tex scale in one)\n\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\t// first sample\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".zw, \" + this._pDepthMapCoordReg + \".xy\\n\" +\n\t\t\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, temp, regCache, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t\t\t} else {\n\t\t\t\tcode += this.addSample(shaderObject, methodVO, uvReg, decReg, targetReg, regCache);\n\t\t\t}\n\n\t\t\tif (numSamples > 4)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shaderObject, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 1)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shaderObject, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 5)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shaderObject, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 2) {\n\t\t\t\tcode += \"neg \" + uvReg + \".w, \" + uvReg + \".w\\n\"; // will be rotated 90 degrees when being accessed as wz\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".wz, \" + this._pDepthMapCoordReg + \".xy\\n\" + this.addSample(shaderObject, methodVO, uvReg, decReg, targetReg, regCache);\n\t\t\t}\n\n\t\t\tif (numSamples > 6)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shaderObject, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 3)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shaderObject, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tif (numSamples > 7)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shaderObject, methodVO, uvReg, decReg, targetReg, regCache);\n\n\t\t\tnumSamples -= 8;\n\t\t}\n\n\t\tregCache.removeFragmentTempUsage(temp);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\t\tcode += \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + customDataReg + \".x\\n\"; // average\n\t\treturn code;\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uvReg The uv register for the tap.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shaderObject:ShaderObjectBase, methodVO:MethodVO, uvReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache):string\n\t{\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureObject._iGetFragmentCode(shaderObject, temp, regCache, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + temp + \".z, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \".z\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = (stage.width - 1)/63;\n\t\tdata[index + 2] = (stage.height - 1)/63;\n\t\tdata[index + 3] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureObject.activate(shaderObject);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shaderObject, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);\n\t}\n}\n\nexport = ShadowDitheredMethod;",
    "import DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison\n * results of neighbouring pixels.\n */\nclass ShadowFilteredMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadow\n\t */\n\tconstructor(castingLight:DirectionalLight)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shaderObject, methodVO);\n\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = .5;\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tfragmentData[index + 9] = size;\n\t\tfragmentData[index + 10] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthCol, 1);\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tmethodVO.textureObject._iInitRegisters(shaderObject, regCache);\n\n\t\tcode += \"mov \" + uvReg + \", \" + this._pDepthMapCoordReg + \"\\n\" +\n\n\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, depthCol, regCache, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" + \t// (1, 0)\n\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, depthCol, regCache, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mov \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".y, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".z\\n\" +\t// (0, 1)\n\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, depthCol, regCache, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\t// (1, 1)\n\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, depthCol, regCache, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t// recalculate fraction, since we ran out of registers :(\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + uvReg + \".w\\n\";\n\n\t\tregCache.removeFragmentTempUsage(depthCol);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = size;\n\t\tdata[index + 1] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar predicate:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(predicate, 1);\n\n\t\tmethodVO.textureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\tcode = methodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".x, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".z, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".y, \" + depthProjection + \".y, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"sub \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".y, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"mul \" + temp + \".xy, \" + depthProjection + \".xy, \" + dataReg + \".x\\n\" +\n\t\t\t\"frc \" + temp + \".xy, \" + temp + \".xy\\n\" +\n\n\t\t\t// some strange register juggling to prevent agal bugging out\n\t\t\t\"sub \" + depthProjection + \", \" + predicate + \".xyzw, \" + predicate + \".zwxy\\n\" +\n\t\t\t\"mul \" + depthProjection + \", \" + depthProjection + \", \" + temp + \".x\\n\" +\n\n\t\t\t\"add \" + predicate + \".xy, \" + predicate + \".xy, \" + depthProjection + \".zw\\n\" +\n\n\t\t\t\"sub \" + predicate + \".y, \" + predicate + \".y, \" + predicate + \".x\\n\" +\n\t\t\t\"mul \" + predicate + \".y, \" + predicate + \".y, \" + temp + \".y\\n\" +\n\t\t\t\"add \" + targetRegister + \".w, \" + predicate + \".x, \" + predicate + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(predicate);\n\t\treturn code;\n\t}\n}\n\nexport = ShadowFilteredMethod;",
    "import LightBase\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.\n */\nclass ShadowHardMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new ShadowHardMethod object.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tmethodVO.textureObject._iInitRegisters(shaderObject, regCache);\n\n\t\tcode += methodVO.textureObject._iGetFragmentCode(shaderObject, depthCol, regCache, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\"; // 0 if in shadow\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPointFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar epsReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar posReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar depthSampleCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthSampleCol, 1);\n\t\tvar lightDir:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(lightDir, 1);\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tmethodVO.textureObject._iInitRegisters(shaderObject, regCache);\n\n\t\tcode += \"sub \" + lightDir + \", \" + sharedRegisters.globalPositionVarying + \", \" + posReg + \"\\n\" +\n\t\t\t\"dp3 \" + lightDir + \".w, \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\t\t\t\"mul \" + lightDir + \".w, \" + lightDir + \".w, \" + posReg + \".w\\n\" +\n\t\t\t\"nrm \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\n\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, depthSampleCol, regCache, lightDir) +\n\t\t\t\"dp4 \" + depthSampleCol + \".z, \" + depthSampleCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + lightDir + \".w, \" + epsReg + \".x\\n\" +    // offset by epsilon\n\n\t\t\t\"slt \" + targetReg + \".w, \" + targetReg + \".w, \" + depthSampleCol + \".z\\n\"; // 0 if in shadow\n\n\t\tregCache.removeFragmentTempUsage(lightDir);\n\t\tregCache.removeFragmentTempUsage(depthSampleCol);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\treturn methodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + targetRegister + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t}\n}\n\nexport = ShadowHardMethod;",
    "import IAsset\t\t\t\t\t\t= require(\"awayjs-core/lib/library/IAsset\");\n\nimport LightBase\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport ShadowMapperBase\t\t\t\t= require(\"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase\");\n\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * ShadowMapMethodBase provides an abstract base method for shadow map methods.\n */\nclass ShadowMapMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset ShadowMapMethod]\";\n\n\tpublic _pCastingLight:LightBase;\n\tpublic _pShadowMapper:ShadowMapperBase;\n\n\tpublic _pEpsilon:number = .02;\n\tpublic _pAlpha:number = 1;\n\n\t/**\n\t * Creates a new ShadowMapMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper();\n\t\tthis._pCastingLight = castingLight;\n\t\tcastingLight.castsShadows = true;\n\t\tthis._pShadowMapper = castingLight.shadowMapper;\n\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadowMapMethodBase.assetType;\n\t}\n\n\t/**\n\t * The \"transparency\" of the shadows. This allows making shadows less strong.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._pAlpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._pAlpha = value;\n\t}\n\n\t/**\n\t * The light casting the shadows.\n\t */\n\tpublic get castingLight():LightBase\n\t{\n\t\treturn this._pCastingLight;\n\t}\n\n\t/**\n\t * A small value to counter floating point precision errors when comparing values in the shadow map with the\n\t * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._pEpsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._pEpsilon = value;\n\t}\n}\n\nexport = ShadowMapMethodBase;",
    "import Vector3D\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\n\nimport LightBase\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport Camera\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport DirectionalLight\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\nimport PointLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/PointLight\");\nimport DirectionalShadowMapper\t\t= require(\"awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper\");\nimport TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport ShaderLightingObject\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMapMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\n\n/**\n * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.\n */\nclass ShadowMethodBase extends ShadowMapMethodBase\n{\n\tpublic _pDepthMapCoordReg:ShaderRegisterElement;\n\tpublic _pUsePoint:boolean;\n\n\t/**\n\t * Creates a new ShadowMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tthis._pUsePoint = (castingLight instanceof PointLight);\n\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsView = true;\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsGlobalFragmentPos = this._pUsePoint;\n\t\tmethodVO.needsNormals = shaderObject.numLights > 0;\n\n\t\tmethodVO.textureObject = shaderObject.getTextureObject(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar vertexData:Array<number> = shaderObject.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = 0;\n\t\tfragmentData[index + 7] = 1;\n\n\t\tif (this._pUsePoint) {\n\t\t\tfragmentData[index + 8] = 0;\n\t\t\tfragmentData[index + 9] = 0;\n\t\t\tfragmentData[index + 10] = 0;\n\t\t\tfragmentData[index + 11] = 1;\n\t\t}\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tif (index != -1) {\n\t\t\tvertexData[index] = .5;\n\t\t\tvertexData[index + 1] = .5;\n\t\t\tvertexData[index + 2] = 0.0;\n\t\t\tvertexData[index + 3] = 1.0;\n\t\t}\n\t}\n\n\t/**\n\t * Wrappers that override the vertex shader need to set this explicitly\n\t */\n\tpublic get _iDepthMapCoordReg():ShaderRegisterElement\n\t{\n\t\treturn this._pDepthMapCoordReg;\n\t}\n\n\tpublic set _iDepthMapCoordReg(value:ShaderRegisterElement)\n\t{\n\t\tthis._pDepthMapCoordReg = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pDepthMapCoordReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._pUsePoint? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters):this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a point light.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic _pGetPointVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tmethodVO.vertexConstantsIndex = -1;\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic pGetPlanarVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeVertexVectorTemp();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tvar depthMapProj:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tthis._pDepthMapCoordReg = regCache.getFreeVarying();\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\t// todo: can epsilon be applied here instead of fragment shader?\n\n\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + depthMapProj + \"\\n\" +\n\t\t\t\"div \" + temp + \", \" + temp + \", \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + dataReg + \".xy\\n\" +\n\t\t\t\"add \" + this._pDepthMapCoordReg + \", \" + temp + \", \" + dataReg + \".xxwz\\n\";\n\t\t//\"sub \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._pUsePoint? this._pGetPointFragmentCode(shaderObject, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tcode += \"add \" + targetReg + \".w, \" + targetReg + \".w, fc\" + (methodVO.fragmentConstantsIndex/4 + 1) + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a planar shadow map.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPlanarFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a point light.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPointFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderObjectBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tif (!this._pUsePoint)\n\t\t\t(<DirectionalShadowMapper> this._pShadowMapper).iDepthProjection.copyRawDataTo(shaderObject.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);\n\t}\n\n\t/**\n\t * Gets the fragment code for combining this method with a cascaded shadow map method.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param decodeRegister The register containing the data to decode the shadow map depth value.\n\t * @param depthTexture The texture containing the shadow map.\n\t * @param depthProjection The projection of the fragment relative to the light.\n\t * @param targetRegister The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _iGetCascadeFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\n\t\tif (this._pUsePoint)\n\t\t\tfragmentData[index + 4] = -Math.pow(1/((<PointLight> this._pCastingLight).fallOff*this._pEpsilon), 2);\n\t\telse\n\t\t\tshaderObject.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/((<DirectionalShadowMapper> this._pShadowMapper).depth*this._pEpsilon);\n\n\t\tfragmentData[index + 5] = 1 - this._pAlpha;\n\n\t\tif (this._pUsePoint) {\n\t\t\tvar pos:Vector3D = this._pCastingLight.scenePosition;\n\t\t\tfragmentData[index + 8] = pos.x;\n\t\t\tfragmentData[index + 9] = pos.y;\n\t\t\tfragmentData[index + 10] = pos.z;\n\t\t\t// used to decompress distance\n\t\t\tvar f:number = (<PointLight> this._pCastingLight).fallOff;\n\t\t\tfragmentData[index + 11] = 1/(2*f*f);\n\t\t}\n\n\t\tmethodVO.textureObject.activate(shaderObject);\n\t}\n\n\t/**\n\t * Sets the method state for cascade shadow mapping.\n\t */\n\tpublic iActivateForCascade(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n}\n\nexport = ShadowMethodBase;",
    "import NearDirectionalShadowMapper\t\t= require(\"awayjs-display/lib/materials/shadowmappers/NearDirectionalShadowMapper\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work\n/**\n * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize\n * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.\n *\n * @see away.lights.NearDirectionalShadowMapper\n */\nclass ShadowNearMethod extends ShadowMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\n\tprivate _fadeRatio:number;\n\tprivate _nearShadowMapper:NearDirectionalShadowMapper;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new ShadowNearMethod object.\n\t * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tconstructor(baseMethod:ShadowMethodBase, fadeRatio:number = .1)\n\t{\n\t\tsuper(baseMethod.castingLight);\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod;\n\t\tthis._fadeRatio = fadeRatio;\n\t\tthis._nearShadowMapper = <NearDirectionalShadowMapper> this._pCastingLight.shadowMapper;\n\t\tif (!this._nearShadowMapper)\n\t\t\tthrow new Error(\"ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.\");\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base shadow map method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shaderObject, methodVO);\n\t\tthis._baseMethod.iInitConstants(shaderObject, methodVO);\n\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index + 2] = 0;\n\t\tfragmentData[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shaderObject, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._baseMethod.alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._baseMethod.alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._baseMethod.epsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._baseMethod.epsilon = value;\n\t}\n\n\t/**\n\t * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tpublic get fadeRatio():number\n\t{\n\t\treturn this._fadeRatio;\n\t}\n\n\tpublic set fadeRatio(value:number)\n\t{\n\t\tthis._fadeRatio = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._baseMethod.iGetFragmentCode(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentSingleTemp();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"abs \" + temp + \", \" + sharedRegisters.projectionFragment + \".w\\n\" +\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + dataReg + \".x\\n\" +\n\t\t\t\"mul \" + temp + \", \" + temp + \", \" + dataReg + \".y\\n\" +\n\t\t\t\"sat \" + temp + \", \" + temp + \"\\n\" +\n\t\t\t\"sub \" + temp + \", \" + dataReg + \".w,\" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderObjectBase, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\t// todo: move this to activate (needs camera)\n\t\tvar near:number = camera.projection.near;\n\t\tvar d:number = camera.projection.far - near;\n\t\tvar maxDistance:number = this._nearShadowMapper.coverageRatio;\n\t\tvar minDistance:number = maxDistance*(1 - this._fadeRatio);\n\n\t\tmaxDistance = near + maxDistance*d;\n\t\tminDistance = near + minDistance*d;\n\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = minDistance;\n\t\tfragmentData[index + 1] = 1/(maxDistance - minDistance);\n\n\t\tthis._baseMethod.iSetRenderState(shaderObject, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = ShadowNearMethod;",
    "import PoissonLookup\t\t\t\t\t= require(\"awayjs-core/lib/geom/PoissonLookup\");\n\nimport DirectionalLight\t\t\t\t\t= require(\"awayjs-display/lib/entities/DirectionalLight\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport ShadowMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\");\n\n/**\n * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.\n */\nclass ShadowSoftMethod extends ShadowMethodBase\n{\n\tprivate _range:number = 1;\n\tprivate _numSamples:number /*int*/;\n\tprivate _offsets:Array<number>;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 5, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tthis._numSamples = value;\n\t\t\n\t\tif (this._numSamples < 1)\n\t\t\tthis._numSamples = 1;\n\t\telse if (this._numSamples > 32)\n\t\t\tthis._numSamples = 32;\n\n\t\tthis._offsets = PoissonLookup.getDistribution(this._numSamples);\n\t\t\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tsuper.iInitConstants(shaderObject, methodVO);\n\n\t\tshaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1/this._numSamples;\n\t\tshaderObject.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar texRange:number = .5*this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex + 10;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: move some things to super\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tmethodVO.textureObject._iInitRegisters(shaderObject, regCache);\n\n\t\treturn this.getSampleCode(shaderObject, methodVO, decReg, targetReg, regCache, dataReg);\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uv The uv register for the tap.\n\t * @param texture The texture register containing the depth map.\n\t * @param decode The register containing the depth map decoding data.\n\t * @param target The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shaderObject:ShaderObjectBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, uvReg:ShaderRegisterElement):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\treturn methodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetRegister + \".w, \" + targetRegister + \".w, \" + uvReg + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar texRange:number = this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = 0;\n\t\tindex += 2;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\n\t\tif (len%4 == 0) {\n\t\t\tdata[index + len] = 0;\n\t\t\tdata[index + len + 1] = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shaderObject, methodVO, decodeRegister, targetRegister, registerCache, dataReg);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthTexture The texture register containing the depth map.\n\t * @param decodeRegister The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t * @param dataReg The register containing additional data.\n\t */\n\tprivate getSampleCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, dataReg:ShaderRegisterElement):string\n\t{\n\t\tvar code:string;\n\t\tvar uvReg:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tvar offsets:Array<string> = new Array<string>(dataReg + \".zw\");\n\t\tvar numRegs:number /*int*/ = this._numSamples >> 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < numRegs; ++i) {\n\t\t\tvar reg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\toffsets.push(reg + \".xy\");\n\t\t\toffsets.push(reg + \".zw\");\n\t\t}\n\n\t\tfor (i = 0; i < this._numSamples; ++i) {\n\t\t\tif (i == 0) {\n\t\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t\tcode = \"add \" + uvReg + \", \" + this._pDepthMapCoordReg + \", \" + dataReg + \".zwyy\\n\" +\n\t\t\t\t\tmethodVO.textureObject._iGetFragmentCode(shaderObject, temp, registerCache, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetRegister + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow;\n\t\t\t} else {\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + offsets[i] + \"\\n\" +\n\t\t\t\t\tthis.addSample(shaderObject, methodVO, decodeRegister, targetRegister, registerCache, uvReg);\n\t\t\t}\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(uvReg);\n\n\t\tcode += \"mul \" + targetRegister + \".w, \" + targetRegister + \".w, \" + dataReg + \".x\\n\"; // average\n\n\t\treturn code;\n\t}\n}\n\nexport = ShadowSoftMethod;",
    "import ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for\n * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.\n * The tangent vectors are used as the surface groove directions.\n */\nclass SpecularAnisotropicMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularAnisotropicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsTangents = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\t// (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k\n\n\t\tcode += \"nrm \" + t + \".xyz, \" + sharedRegisters.tangentVarying + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".w, \" + t + \".xyz, \" + lightDirReg + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".z, \" + t + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\";\n\n\t\t// (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k\n\t\tcode += \"sin \" + t + \".x, \" + t + \".w\\n\" +\n\t\t\t\"sin \" + t + \".y, \" + t + \".z\\n\" +\n\t\t\t// (t.x * t.y - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"mul \" + t + \".x, \" + t + \".x, \" + t + \".y\\n\" +\n\t\t\t// (t.x - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"cos \" + t + \".z, \" + t + \".z\\n\" +\n\t\t\t\"cos \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t// (t.x - t.w*t.z) ^ k\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + t + \".z\\n\" +\n\t\t\t// (t.x - t.w) ^ k\n\t\t\t\"sub \" + t + \".w, \" + t + \".x, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularAnisotropicMethod;",
    "import TextureBase\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport LightingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport ShadingMethodBase\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\");\n\n/**\n * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated\n * version of Phong specularity).\n */\nclass SpecularBasicMethod extends LightingMethodBase\n{\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\tpublic _pSpecularTexData:ShaderRegisterElement;\n\tpublic _pSpecularDataRegister:ShaderRegisterElement;\n\n\tprivate _texture:TextureBase;\n\n\tprivate _gloss:number = 50;\n\tprivate _specular:number = 1;\n\tprivate _specularColor:number = 0xffffff;\n\tpublic _iSpecularR:number = 1;\n\tpublic _iSpecularG:number = 1;\n\tpublic _iSpecularB:number = 1;\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new SpecularBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shaderObject:ShaderLightingObject):boolean\n\t{\n\t\tif (!shaderObject.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tmethodVO.needsNormals = shaderObject.numLights > 0;\n\t\tmethodVO.needsView = shaderObject.numLights > 0;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureObject = shaderObject.getTextureObject(this._texture);\n\t\t\tshaderObject.uvDependencies++;\n\t\t} else if (methodVO.textureObject) {\n\t\t\tmethodVO.textureObject.dispose();\n\t\t\tmethodVO.textureObject = null;\n\t\t}\n\t}\n\n\t/**\n\t * The sharpness of the specular highlight.\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._gloss = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular highlights.\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tif (value == this._specular)\n\t\t\treturn;\n\n\t\tthis._specular = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The colour of the specular reflection of the surface.\n\t */\n\tpublic get specularColor():number\n\t{\n\t\treturn this._specularColor;\n\t}\n\n\tpublic set specularColor(value:number)\n\t{\n\t\tif (this._specularColor == value)\n\t\t\treturn;\n\n\t\t// specular is now either enabled or disabled\n\t\tif (this._specularColor == 0 || value == 0)\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._specularColor = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The bitmapData that encodes the specular highlight strength per texel in the red channel, and the sharpness\n\t * in the green channel. You can use SpecularTextureBase if you want to easily set specular and gloss maps\n\t * from grayscale images, but prepared images are preferred.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tthis._texture = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase)\n\t{\n\n\t\tvar m:any = method;\n\t\tvar bsm:SpecularBasicMethod = <SpecularBasicMethod> method;\n\n\t\tvar spec:SpecularBasicMethod = bsm;//SpecularBasicMethod(method);\n\t\tthis.texture = spec.texture;\n\t\tthis.specular = spec.specular;\n\t\tthis.specularColor = spec.specularColor;\n\t\tthis.gloss = spec.gloss;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._pTotalLightColorReg = null;\n\t\tthis._pSpecularTexData = null;\n\t\tthis._pSpecularDataRegister = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tthis._pSpecularDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index*4;\n\n\t\tif (this._texture) {\n\n\t\t\tthis._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(this._pSpecularTexData, 1);\n\n\t\t\tmethodVO.textureObject._iInitRegisters(shaderObject, registerCache);\n\n\t\t\tcode += methodVO.textureObject._iGetFragmentCode(shaderObject, this._pSpecularTexData, registerCache, sharedRegisters.uvVarying);\n\t\t}\n\n\t\tthis._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\t// blinn-phong half vector model\n\t\tcode += \"add \" + t + \", \" + lightDirReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"nrm \" + t + \".xyz, \" + t + \"\\n\" +\n\t\t\t\t\"dp3 \" + t + \".w, \" + normalReg + \", \" + t + \"\\n\" +\n\t\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else {\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\t\t}\n\n\t\t// attenuate\n\t\tif (shaderObject.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \", \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shaderObject:ShaderLightingObject, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\n\t\tcode += \"dp3 \" + t + \".w, \" + normalReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t\t\"mul \" + t + \", \" + t + \".w, \" + normalReg + \"\\n\" +\n\t\t\t\t\"sub \" + t + \", \" + t + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"tex \" + t + \", \" + t + \", \" + cubeMapReg + \" <cube,\" + (shaderObject.useSmoothTextures? \"linear\":\"nearest\") + \",miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply strength modulation from texture\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularTexData + \".x\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pSpecularTexData);\n\t\t}\n\n\t\t// apply material's specular reflection\n\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularDataRegister + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\";\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureObject.activate(shaderObject);\n\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = this._iSpecularR;\n\t\tdata[index + 1] = this._iSpecularG;\n\t\tdata[index + 2] = this._iSpecularB;\n\t\tdata[index + 3] = this._gloss;\n\t}\n\n\t/**\n\t * Updates the specular color data used by the render state.\n\t */\n\tprivate updateSpecular()\n\t{\n\t\tthis._iSpecularR = (( this._specularColor >> 16) & 0xff)/0xff*this._specular;\n\t\tthis._iSpecularG = (( this._specularColor >> 8) & 0xff)/0xff*this._specular;\n\t\tthis._iSpecularB = ( this._specularColor & 0xff)/0xff*this._specular;\n\t}\n}\n\nexport = SpecularBasicMethod;",
    "import Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.\n */\nclass SpecularCelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\tprivate _specularCutOff:number = .1;\n\n\t/**\n\t * Creates a new SpecularCelMethod object.\n\t * @param specularCutOff The threshold at which the specular highlight should be shown.\n\t * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.\n\t */\n\tconstructor(specularCutOff:number = .5, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampSpecular(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._specularCutOff = specularCutOff;\n\t}\n\n\t/**\n\t * The smoothness of the highlight edge.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * The threshold at which the specular highlight should be shown.\n\t */\n\tpublic get specularCutOff():number\n\t{\n\t\treturn this._specularCutOff;\n\t}\n\n\tpublic set specularCutOff(value:number)\n\t{\n\t\tthis._specularCutOff = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Array<number> = shaderObject.fragmentConstantData;\n\t\tdata[index] = this._smoothness;\n\t\tdata[index + 1] = this._specularCutOff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the specular strength in the \"w\" component, and either the half-vector or the reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampSpecular(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" + // x - cutoff\n\t\t\t\"div \" + targetReg + \".y, \" + targetReg + \".y, \" + this._dataReg + \".x\\n\" + // (x - cutoff)/epsilon\n\t\t\t\"sat \" + targetReg + \".y, \" + targetReg + \".y\\n\" +\n\t\t\t\"sge \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n}\n\nexport = SpecularCelMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the\n * calculated specular reflection strength.\n */\nclass SpecularCompositeMethod extends SpecularBasicMethod\n{\n\tprivate _baseMethod:SpecularBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:Function;\n\n\t/**\n\t * Creates a new <code>SpecularCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.\n\t * @param baseMethod The base specular method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod || new SpecularBasicMethod();\n\t\tthis._baseMethod._iModulateMethod = modulateMethod;\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shaderObject:ShaderLightingObject, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitVO(shaderObject, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tthis._baseMethod.iInitConstants(shaderObject, methodVO);\n\t}\n\n\t/**\n\t * The base specular method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():SpecularBasicMethod\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._baseMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._baseMethod.gloss = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get specular():number\n\t{\n\t\treturn this._baseMethod.specular;\n\t}\n\n\tpublic set specular(value:number)\n\t{\n\t\tthis._baseMethod.specular = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis._baseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._baseMethod.texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis._baseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iActivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shaderObject:ShaderLightingObject, methodVO:MethodVO, renderable:RenderableBase, stage:Stage, camera:Camera)\n\t{\n\t\tthis._baseMethod.iSetRenderState(shaderObject, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shaderObject:ShaderObjectBase, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tthis._baseMethod.iDeactivate(shaderObject, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shaderObject:ShaderObjectBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerLight(shaderObject, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @return\n\t */\n\tpublic iGetFragmentCodePerProbe(shaderObject:ShaderLightingObject, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerProbe(shaderObject, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPostLightingCode(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset()\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}\n\nexport = SpecularCompositeMethod;",
    "import Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport SpecularCompositeMethod\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\");\n\n/**\n * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.\n */\nclass SpecularFresnelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _incidentLight:boolean;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = .028; // default value for skin\n\n\t/**\n\t * Creates a new SpecularFresnelMethod object.\n\t * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.\n\t */\n\tconstructor(basedOnSurface:boolean = true, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\t// may want to offer diff speculars\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.modulateSpecular(shaderObject, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._incidentLight = !basedOnSurface;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tshaderObject.fragmentConstantData[index + 2] = 1;\n\t\tshaderObject.fragmentConstantData[index + 3] = 0;\n\t}\n\n\t/**\n\t * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t */\n\tpublic get basedOnSurface():boolean\n\t{\n\t\treturn !this._incidentLight;\n\t}\n\n\tpublic set basedOnSurface(value:boolean)\n\t{\n\t\tif (this._incidentLight != value)\n\t\t\treturn;\n\n\t\tthis._incidentLight = !value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData()\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shaderObject:ShaderLightingObject, methodVO:MethodVO, stage:Stage)\n\t{\n\t\tsuper.iActivate(shaderObject, methodVO, stage);\n\n\t\tvar fragmentData:Array<number> = shaderObject.fragmentConstantData;\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = this._normalReflectance;\n\t\tfragmentData[index + 1] = this._fresnelPower;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shaderObject:ShaderLightingObject, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shaderObject, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Applies the fresnel effect to the specular strength.\n\t *\n\t * @param vo The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param target The register containing the specular strength in the \"w\" component, and the half-vector/reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared registers created by the compiler.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate modulateSpecular(shaderObject:ShaderObjectBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\n\t\tcode = \"dp3 \" + targetReg + \".y, \" + sharedRegisters.viewDirFragment + \".xyz, \" + (this._incidentLight? targetReg : sharedRegisters.normalFragment) + \".xyz\\n\" +   // dot(V, H)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // base = 1-dot(V, H)\n\t\t\t\"pow \" + targetReg + \".x, \" + targetReg + \".y, \" + this._dataReg + \".y\\n\" +             // exp = pow(base, 5)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // 1 - exp\n\t\t\t\"mul \" + targetReg + \".y, \" + this._dataReg + \".x, \" + targetReg + \".y\\n\" +             // f0*(1 - exp)\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".x, \" + targetReg + \".y\\n\" +          // exp + f0*(1 - exp)\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\n\t\treturn code;\n\t}\n\n}\n\nexport = SpecularFresnelMethod;",
    "import ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\n\n/**\n * SpecularPhongMethod provides a specular method that provides Phong highlights.\n */\nclass SpecularPhongMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularPhongMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shaderObject:ShaderLightingObject, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement =sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement =sharedRegisters.normalFragment;\n\n\t\t// phong model\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \", \" + normalReg + \"\\n\" + // sca1 = light.normal\n\n\t\t\t//find the reflected light vector R\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" + // sca1 = sca1*2\n\t\t\t\"mul \" + t + \".xyz, \" + normalReg + \", \" + t + \".w\\n\" + // vec1 = normal*sca1\n\t\t\t\"sub \" + t + \".xyz, \" + t + \", \" + lightDirReg + \"\\n\" + // vec1 = vec1 - light (light vector is negative)\n\n\t\t\t//smooth the edge as incidence angle approaches 90\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" +sharedRegisters.commons + \".w\\n\" + // sca1 = sca1 + smoothtep;\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\" + // sca1 range 0 - 1\n\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + t + \".w\\n\" + // vec1 = vec1*sca1\n\n\t\t\t//find the dot product between R and V\n\t\t\t\"dp3 \" + t + \".w, \" + t + \", \" + viewDirReg + \"\\n\" + // sca1 = vec1.view\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tif (shaderObject.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shaderObject, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}\n\nexport = SpecularPhongMethod;",
    "class PassMode\n{\n\t/**\n\t *\n\t */\n\tpublic static EFFECTS:number = 0x01;\n\n\t/**\n\t *\n\t */\n\tpublic static LIGHTING:number = 0x02;\n\n\t/**\n\t *\n\t */\n\tpublic static SUPER_SHADER:number = 0x03;\n}\n\nexport = PassMode;",
    "import TriangleSubGeometry\t\t\t\t= require(\"awayjs-core/lib/data/TriangleSubGeometry\");\nimport ColorTransform\t\t\t\t\t= require(\"awayjs-core/lib/geom/ColorTransform\");\nimport Matrix\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\nimport Matrix3DUtils\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3DUtils\");\nimport Vector3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Vector3D\");\nimport AbstractMethodError\t\t\t\t= require(\"awayjs-core/lib/errors/AbstractMethodError\");\nimport Event\t\t\t\t\t\t\t= require(\"awayjs-core/lib/events/Event\");\nimport MaterialBase\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\n\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport IRenderObjectOwner\t\t\t\t= require(\"awayjs-display/lib/base/IRenderObjectOwner\");\nimport LightPickerBase\t\t\t\t\t= require(\"awayjs-display/lib/materials/lightpickers/LightPickerBase\");\nimport LightSources\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/LightSources\");\n\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport ShaderLightingObject\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderLightingObject\");\nimport ShadingMethodEvent\t\t\t\t= require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport ShaderRegisterElement\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterElement\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport RenderPassBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/passes/RenderPassBase\");\nimport IRenderLightingPass\t\t\t\t= require(\"awayjs-renderergl/lib/passes/IRenderLightingPass\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/IRenderableClass\");\n\nimport MethodVO\t\t\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/data/MethodVO\");\nimport RenderMethodMaterialObject\t\t= require(\"awayjs-methodmaterials/lib/compilation/RenderMethodMaterialObject\");\nimport AmbientBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\");\nimport DiffuseBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\");\nimport EffectColorTransformMethod\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\");\nimport EffectMethodBase\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/EffectMethodBase\");\nimport LightingMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/LightingMethodBase\");\nimport NormalBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\");\nimport ShadowMapMethodBase\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\");\nimport SpecularBasicMethod\t\t\t\t= require(\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\");\nimport MethodPassMode\t\t\t\t\t= require(\"awayjs-methodmaterials/lib/passes/MethodPassMode\");\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nclass MethodPass extends RenderPassBase implements IRenderLightingPass\n{\n\tprivate _maxLights:number = 3;\n\n\tprivate _mode:number = 0x03;\n\tprivate _material:MaterialBase;\n\tprivate _lightPicker:LightPickerBase;\n\n\tprivate _includeCasters:boolean = true;\n\n\tpublic _iColorTransformMethodVO:MethodVO;\n\tpublic _iNormalMethodVO:MethodVO;\n\tpublic _iAmbientMethodVO:MethodVO;\n\tpublic _iShadowMethodVO:MethodVO;\n\tpublic _iDiffuseMethodVO:MethodVO;\n\tpublic _iSpecularMethodVO:MethodVO;\n\tpublic _iMethodVOs:Array<MethodVO> = new Array<MethodVO>();\n\n\tpublic _numEffectDependencies:number = 0;\n\n\tprivate _onLightsChangeDelegate:(event:Event) => void;\n\tprivate _onMethodInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\tpublic numDirectionalLights:number = 0;\n\n\tpublic numPointLights:number = 0;\n\n\tpublic numLightProbes:number = 0;\n\n\tpublic pointLightsOffset:number = 0;\n\t\n\tpublic directionalLightsOffset:number= 0;\n\t\n\tpublic lightProbesOffset:number = 0;\n\t\n\t/**\n\t *\n\t */\n\tpublic get mode():number\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:number)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\t\t\n\t\tthis._mode = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * Indicates whether or not shadow casting lights need to be included.\n\t */\n\tpublic get includeCasters():boolean\n\t{\n\t\treturn this._includeCasters;\n\t}\n\n\tpublic set includeCasters(value:boolean)\n\t{\n\t\tif (this._includeCasters == value)\n\t\t\treturn;\n\n\t\tthis._includeCasters = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * \n\t * @returns {LightPickerBase}\n\t */\n\tpublic get lightPicker():LightPickerBase\n\t{\n\t\treturn this._lightPicker;\n\t}\n\n\tpublic set lightPicker(value:LightPickerBase)\n\t{\n\t\t//if (this._lightPicker == value)\n\t\t//\treturn;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);\n\n\t\tthis._lightPicker = value;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.addEventListener(Event.CHANGE, this._onLightsChangeDelegate);\n\n\t\tthis._updateLights();\n\t}\n\t\n\t/**\n\t * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and\n\t * compatibility for constrained mode.\n\t */\n\tpublic get enableLightFallOff():boolean\n\t{\n\t\treturn this._material.enableLightFallOff;\n\t}\n\n\t/**\n\t * Define which light source types to use for diffuse reflections. This allows choosing between regular lights\n\t * and/or light probes for diffuse reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get diffuseLightSources():number\n\t{\n\t\treturn this._material.diffuseLightSources;\n\t}\n\n\t/**\n\t * Define which light source types to use for specular reflections. This allows choosing between regular lights\n\t * and/or light probes for specular reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get specularLightSources():number\n\t{\n\t\treturn this._material.specularLightSources;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(mode:number, renderObject:RenderMethodMaterialObject, renderObjectOwner:MaterialBase, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(renderObject, renderObjectOwner, renderableClass, stage);\n\n\t\tthis._mode = mode;\n\n\t\tthis._material = renderObjectOwner;\n\n\t\tthis._onLightsChangeDelegate = (event:Event) => this.onLightsChange(event);\n\t\t\n\t\tthis._onMethodInvalidatedDelegate = (event:ShadingMethodEvent) => this.onMethodInvalidated(event);\n\n\t\tthis.lightPicker = renderObjectOwner.lightPicker;\n\n\t\tif (this._shader == null)\n\t\t\tthis._updateShader();\n\t}\n\n\tprivate _updateShader()\n\t{\n\t\tif ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof ShaderLightingObject)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new ShaderLightingObject(this._renderableClass, this, this._stage);\n\t\t} else if (!(this._shader instanceof ShaderObjectBase)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new ShaderObjectBase(this._renderableClass, this, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the unchanging constant data for this material.\n\t */\n\tpublic _iInitConstantData(shaderObject:ShaderObjectBase)\n\t{\n\t\tsuper._iInitConstantData(shaderObject);\n\n\t\t//Updates method constants if they have changed.\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tthis._iMethodVOs[i].method.iInitConstants(shaderObject, this._iMethodVOs[i]);\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this.colorTransformMethod? this.colorTransformMethod.colorTransform : null;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tif (value) {\n\t\t\tif (this.colorTransformMethod == null)\n\t\t\t\tthis.colorTransformMethod = new EffectColorTransformMethod();\n\n\t\t\tthis.colorTransformMethod.colorTransform = value;\n\n\t\t} else if (!value) {\n\t\t\tif (this.colorTransformMethod)\n\t\t\t\tthis.colorTransformMethod = null;\n\t\t}\n\t}\n\n\t/**\n\t * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransformMethod():EffectColorTransformMethod\n\t{\n\t\treturn this._iColorTransformMethodVO? <EffectColorTransformMethod> this._iColorTransformMethodVO.method : null;\n\t}\n\n\tpublic set colorTransformMethod(value:EffectColorTransformMethod)\n\t{\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iColorTransformMethodVO) {\n\t\t\tthis._removeDependency(this._iColorTransformMethodVO);\n\t\t\tthis._iColorTransformMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iColorTransformMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iColorTransformMethodVO);\n\t\t}\n\t}\n\n\tprivate _removeDependency(methodVO:MethodVO, effectsDependency:boolean = false)\n\t{\n\t\tvar index:number = this._iMethodVOs.indexOf(methodVO);\n\n\t\tif (!effectsDependency)\n\t\t\tthis._numEffectDependencies--;\n\n\t\tmethodVO.method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\t\tthis._iMethodVOs.splice(index, 1);\n\n\t\tthis.invalidatePass();\n\t}\n\n\tprivate _addDependency(methodVO:MethodVO, effectsDependency:boolean = false, index:number = -1)\n\t{\n\t\tmethodVO.method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\n\t\tif (effectsDependency) {\n\t\t\tif (index != -1)\n\t\t\t\tthis._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t\telse\n\t\t\t\tthis._iMethodVOs.push(methodVO);\n\t\t\tthis._numEffectDependencies++;\n\t\t} else {\n\t\t\tthis._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t}\n\n\t\tthis.invalidatePass();\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase)\n\t{\n\t\tthis._addDependency(new MethodVO(method), true);\n\t}\n\n\t/**\n\t * The number of \"effect\" methods added to the material.\n\t */\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._numEffectDependencies;\n\t}\n\n\t/**\n\t * Queries whether a given effects method was added to the material.\n\t *\n\t * @param method The method to be queried.\n\t * @return true if the method was added to the material, false otherwise.\n\t */\n\tpublic hasEffectMethod(method:EffectMethodBase):boolean\n\t{\n\t\treturn this.getDependencyForMethod(method) != null;\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn null;\n\n\t\treturn <EffectMethodBase> this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number)\n\t{\n\t\tthis._addDependency(new MethodVO(method), true, index);\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase)\n\t{\n\t\tvar methodVO:MethodVO = this.getDependencyForMethod(method);\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\t/**\n\t * remove an effect method at the specified index from the material.\n\t */\n\tpublic removeEffectMethodAt(index:number)\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn;\n\n\t\tvar methodVO:MethodVO = this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies];\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\tprivate getDependencyForMethod(method:EffectMethodBase):MethodVO\n\t{\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tif (this._iMethodVOs[i].method == method)\n\t\t\t\treturn this._iMethodVOs[i];\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._iNormalMethodVO? <NormalBasicMethod> this._iNormalMethodVO.method : null;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._iNormalMethodVO && this._iNormalMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iNormalMethodVO) {\n\t\t\tthis._removeDependency(this._iNormalMethodVO);\n\t\t\tthis._iNormalMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iNormalMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iNormalMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._iAmbientMethodVO? <AmbientBasicMethod> this._iAmbientMethodVO.method : null;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iAmbientMethodVO) {\n\t\t\tthis._removeDependency(this._iAmbientMethodVO);\n\t\t\tthis._iAmbientMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iAmbientMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iAmbientMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._iShadowMethodVO? <ShadowMapMethodBase> this._iShadowMethodVO.method : null;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._iShadowMethodVO && this._iShadowMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iShadowMethodVO) {\n\t\t\tthis._removeDependency(this._iShadowMethodVO);\n\t\t\tthis._iShadowMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iShadowMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iShadowMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._iDiffuseMethodVO? <DiffuseBasicMethod> this._iDiffuseMethodVO.method : null;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iDiffuseMethodVO) {\n\t\t\tthis._removeDependency(this._iDiffuseMethodVO);\n\t\t\tthis._iDiffuseMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iDiffuseMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iDiffuseMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._iSpecularMethodVO? <SpecularBasicMethod> this._iSpecularMethodVO.method : null;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iSpecularMethodVO) {\n\t\t\tthis._removeDependency(this._iSpecularMethodVO);\n\t\t\tthis._iSpecularMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iSpecularMethodVO = new MethodVO(value);\n\t\t\tthis._addDependency(this._iSpecularMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tsuper.dispose();\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(Event.CHANGE, this._onLightsChangeDelegate);\n\t\t\n\t\twhile (this._iMethodVOs.length)\n\t\t\tthis._removeDependency(this._iMethodVOs[0]);\n\n\t\tthis._iMethodVOs = null;\n\t}\n\n\t/**\n\t * Called when any method's shader code is invalidated.\n\t */\n\tprivate onMethodInvalidated(event:ShadingMethodEvent)\n\t{\n\t\tthis.invalidatePass();\n\t}\n\n\t// RENDER LOOP\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tsuper._iActivate(camera);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iActivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param renderable\n\t * @param stage\n\t * @param camera\n\t */\n\tpublic _iRender(renderable:RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tsuper._iRender(renderable, camera, viewProjection);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iSetRenderState(this._shader, methodVO, renderable, this._stage, camera);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iDeactivate()\n\t{\n\t\tsuper._iDeactivate();\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iDeactivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\tpublic _iIncludeDependencies(shaderObject:ShaderLightingObject)\n\t{\n\t\tsuper._iIncludeDependencies(shaderObject);\n\n\t\t//TODO: fragment animtion should be compatible with lighting pass\n\t\tshaderObject.usesFragmentAnimation = Boolean(this._mode == MethodPassMode.SUPER_SHADER);\n\n\t\tif (!shaderObject.usesTangentSpace && this.numPointLights > 0 && shaderObject.usesLights) {\n\t\t\tshaderObject.globalPosDependencies++;\n\n\t\t\tif (Boolean(this._mode & MethodPassMode.EFFECTS))\n\t\t\t\tshaderObject.usesGlobalPosFragment = true;\n\t\t}\n\n\t\tvar i:number;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tthis.setupAndCountDependencies(shaderObject, this._iMethodVOs[i]);\n\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tthis._iMethodVOs[i].useMethod = this._iMethodVOs[i].method.iIsUsed(shaderObject);\n\t}\n\n\n\t/**\n\t * Counts the dependencies for a given method.\n\t * @param method The method to count the dependencies for.\n\t * @param methodVO The method's data for this material.\n\t */\n\tprivate setupAndCountDependencies(shaderObject:ShaderObjectBase, methodVO:MethodVO)\n\t{\n\t\tmethodVO.reset();\n\n\t\tmethodVO.method.iInitVO(shaderObject, methodVO);\n\n\t\tif (methodVO.needsProjection)\n\t\t\tshaderObject.projectionDependencies++;\n\n\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos) {\n\n\t\t\tshaderObject.globalPosDependencies++;\n\n\t\t\tif (methodVO.needsGlobalFragmentPos)\n\t\t\t\tshaderObject.usesGlobalPosFragment = true;\n\n\t\t}\n\n\t\tif (methodVO.needsNormals)\n\t\t\tshaderObject.normalDependencies++;\n\n\t\tif (methodVO.needsTangents)\n\t\t\tshaderObject.tangentDependencies++;\n\n\t\tif (methodVO.needsView)\n\t\t\tshaderObject.viewDirDependencies++;\n\t}\n\n\tpublic _iGetPreLightingVertexCode(shaderObject:ShaderObjectBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)\n\t\t\tcode += this._iAmbientMethodVO.method.iGetVertexCode(shaderObject, this._iAmbientMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += this._iDiffuseMethodVO.method.iGetVertexCode(shaderObject, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += this._iSpecularMethodVO.method.iGetVertexCode(shaderObject, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPreLightingFragmentCode(shaderObject:ShaderObjectBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {\n\t\t\tcode += this._iAmbientMethodVO.method.iGetFragmentCode(shaderObject, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\tif (this._iAmbientMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iAmbientMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPreLightingCode(<ShaderLightingObject> shaderObject, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPreLightingCode(<ShaderLightingObject> shaderObject, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPerLightDiffuseFragmentCode(shaderObject:ShaderLightingObject, lightDirReg:ShaderRegisterElement, diffuseColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerLight(shaderObject, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerLightSpecularFragmentCode(shaderObject:ShaderLightingObject, lightDirReg:ShaderRegisterElement, specularColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerLight(shaderObject, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeDiffuseFragmentCode(shaderObject:ShaderLightingObject, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerProbe(shaderObject, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeSpecularFragmentCode(shaderObject:ShaderLightingObject, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerProbe(shaderObject, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPostLightingVertexCode(shaderObject:ShaderLightingObject, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetVertexCode(shaderObject, this._iShadowMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPostLightingFragmentCode(shaderObject:ShaderLightingObject, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shaderObject.useAlphaPremultiplied && this._pEnableBlending) {\n\t\t\tcode += \"add \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"div \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \", \" + sharedRegisters.shadedTarget + \".w\\n\" +\n\t\t\t\"sub \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"sat \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \"\\n\";\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetFragmentCode(shaderObject, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPostLightingCode(shaderObject, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\t// resolve other dependencies as well?\n\t\t\tif (this._iDiffuseMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iDiffuseMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPostLightingCode(shaderObject, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\t\t\tif (this._iSpecularMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\t\t\tif (this._iSpecularMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Indicates whether or not normals are allowed in tangent space. This is only the case if no object-space\n\t * dependencies exist.\n\t */\n\tpublic _pUsesTangentSpace(shaderObject:ShaderLightingObject):boolean\n\t{\n\t\tif (shaderObject.usesProbes)\n\t\t\treturn false;\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod && !methodVO.method.iUsesTangentSpace())\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Indicates whether or not normals are output in tangent space.\n\t */\n\tpublic _pOutputsTangentNormals(shaderObject:ShaderObjectBase):boolean\n\t{\n\t\treturn (<NormalBasicMethod> this._iNormalMethodVO.method).iOutputsTangentNormals();\n\t}\n\n\t/**\n\t * Indicates whether or not normals are output by the pass.\n\t */\n\tpublic _pOutputsNormals(shaderObject:ShaderObjectBase):boolean\n\t{\n\t\treturn this._iNormalMethodVO && this._iNormalMethodVO.useMethod;\n\t}\n\n\n\tpublic _iGetNormalVertexCode(shaderObject:ShaderObjectBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._iNormalMethodVO.method.iGetVertexCode(shaderObject, this._iNormalMethodVO, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetNormalFragmentCode(shaderObject:ShaderObjectBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._iNormalMethodVO.method.iGetFragmentCode(shaderObject, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);\n\n\t\tif (this._iNormalMethodVO.needsView)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\n\t\tif (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)\n\t\t\tregisterCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode(shaderObject:ShaderObjectBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetVertexCode(shaderObject, methodVO, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)\n\t\t\t\t\tregCache.removeVertexTempUsage(sharedReg.globalPositionVertex);\n\t\t\t}\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetVertexCode(shaderObject, this._iColorTransformMethodVO, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shaderObject:ShaderObjectBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar alphaReg:ShaderRegisterElement;\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\talphaReg = regCache.getFreeFragmentSingleTemp();\n\t\t\tregCache.addFragmentTempUsages(alphaReg, 1);\n\t\t\tcode += \"mov \" + alphaReg + \", \" + sharedReg.shadedTarget + \".w\\n\";\n\t\t}\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetFragmentCode(shaderObject, methodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsNormals)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.normalFragment);\n\n\t\t\t\tif (methodVO.needsView)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.viewDirFragment);\n\n\t\t\t}\n\t\t}\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\tcode += \"mov \" + sharedReg.shadedTarget + \".w, \" + alphaReg + \"\\n\";\n\t\t\tregCache.removeFragmentTempUsage(alphaReg);\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetFragmentCode(shaderObject, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\t/**\n\t * Indicates whether the shader uses any shadows.\n\t */\n\tpublic _iUsesShadows(shaderObject:ShaderObjectBase):boolean\n\t{\n\t\treturn Boolean(this._iShadowMethodVO && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesSpecular(shaderObject:ShaderObjectBase):boolean\n\t{\n\t\treturn Boolean(this._iSpecularMethodVO);\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesDiffuse(shaderObject:ShaderObjectBase):boolean\n\t{\n\t\treturn Boolean(this._iDiffuseMethodVO);\n\t}\n\n\n\tprivate onLightsChange(event:Event)\n\t{\n\t\tthis._updateLights();\n\t}\n\n\tprivate _updateLights()\n\t{\n\t\tvar numDirectionalLightsOld:number = this.numDirectionalLights;\n\t\tvar numPointLightsOld:number = this.numPointLights;\n\t\tvar numLightProbesOld:number = this.numLightProbes;\n\n\t\tif (this._lightPicker && (this._mode & MethodPassMode.LIGHTING)) {\n\t\t\tthis.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);\n\t\t\tthis.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);\n\t\t\tthis.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);\n\n\t\t\tif (this._includeCasters) {\n\t\t\t\tthis.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;\n\t\t\t\tthis.numPointLights += this._lightPicker.numCastingPointLights;\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis.numDirectionalLights = 0;\n\t\t\tthis.numPointLights = 0;\n\t\t\tthis.numLightProbes = 0;\n\t\t}\n\n\t\tif (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {\n\t\t\tthis._updateShader();\n\n\t\t\tthis.invalidatePass();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the amount of directional lights this material will support.\n\t * @param numDirectionalLights The maximum amount of directional lights to support.\n\t * @return The amount of directional lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumDirectionalLights(numDirectionalLights:number):number\n\t{\n\t\treturn Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);\n\t}\n\n\t/**\n\t * Calculates the amount of point lights this material will support.\n\t * @param numDirectionalLights The maximum amount of point lights to support.\n\t * @return The amount of point lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumPointLights(numPointLights:number):number\n\t{\n\t\tvar numFree:number = this._maxLights - this.numDirectionalLights;\n\t\treturn Math.min(numPointLights - this.pointLightsOffset, numFree);\n\t}\n\n\t/**\n\t * Calculates the amount of light probes this material will support.\n\t * @param numDirectionalLights The maximum amount of light probes to support.\n\t * @return The amount of light probes this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumProbes(numLightProbes:number):number\n\t{\n\t\tvar numChannels:number = 0;\n\n\t\tif ((this.specularLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\tif ((this.diffuseLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\t// 4 channels available\n\t\treturn Math.min(numLightProbes - this.lightProbesOffset, (4/numChannels) | 0);\n\t}\n}\n\nexport = MethodPass;",
    "import Image2D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/data/Image2D\");\nimport TriangleSubGeometry\t\t\t\t= require(\"awayjs-core/lib/data/TriangleSubGeometry\");\nimport Matrix3D\t\t\t\t\t\t\t= require(\"awayjs-core/lib/geom/Matrix3D\");\n\nimport LightBase\t\t\t\t\t\t= require(\"awayjs-display/lib/base/LightBase\");\nimport Camera\t\t\t\t\t\t\t= require(\"awayjs-display/lib/entities/Camera\");\nimport MaterialBase\t\t\t\t\t\t= require(\"awayjs-display/lib/materials/MaterialBase\");\nimport IRenderObjectOwner\t\t\t\t= require(\"awayjs-display/lib/base/IRenderObjectOwner\");\nimport Single2DTexture\t\t\t\t\t= require(\"awayjs-display/lib/textures/Single2DTexture\");\nimport TextureBase\t\t\t\t\t\t= require(\"awayjs-display/lib/textures/TextureBase\");\n\nimport ContextGLProgramType\t\t\t\t= require(\"awayjs-stagegl/lib/base/ContextGLProgramType\");\nimport IContextGL\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/IContextGL\");\nimport Stage\t\t\t\t\t\t\t= require(\"awayjs-stagegl/lib/base/Stage\");\n\nimport RendererBase\t\t\t\t\t\t= require(\"awayjs-renderergl/lib/RendererBase\");\nimport RenderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/RenderObjectBase\");\nimport RenderableBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/RenderableBase\");\nimport ShaderObjectBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderObjectBase\");\nimport ShaderRegisterCache\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterCache\");\nimport ShaderRegisterData\t\t\t\t= require(\"awayjs-renderergl/lib/compilation/ShaderRegisterData\");\nimport IRenderableClass\t\t\t\t\t= require(\"awayjs-renderergl/lib/pool/IRenderableClass\");\nimport RenderPassBase\t\t\t\t\t= require(\"awayjs-renderergl/lib/passes/RenderPassBase\");\n\n/**\n * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point\n * of view from a light.\n */\nclass SingleObjectDepthPass extends RenderPassBase\n{\n\tprivate _textures:Object;\n\tprivate _projections:Object;\n\tprivate _textureSize:number /*uint*/ = 512;\n\tprivate _polyOffset:Array<number> = Array<number>(15, 0, 0, 0);\n\tprivate _enc:Array<number>;\n\tprivate _projectionTexturesInvalid:Boolean = true;\n\n\t/**\n\t * The size of the depth map texture to render to.\n\t */\n\tpublic get textureSize():number\n\t{\n\t\treturn this._textureSize;\n\t}\n\n\tpublic set textureSize(value:number)\n\t{\n\t\tthis._textureSize = value;\n\t}\n\n\t/**\n\t * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t */\n\tpublic get polyOffset():number\n\t{\n\t\treturn this._polyOffset[0];\n\t}\n\n\tpublic set polyOffset(value:number)\n\t{\n\t\tthis._polyOffset[0] = value;\n\t}\n\n\t/**\n\t * Creates a new SingleObjectDepthPass object.\n\t */\n\tconstructor(renderObject:RenderObjectBase, renderObjectOwner:IRenderObjectOwner, renderableClass:IRenderableClass, stage:Stage)\n\t{\n\t\tsuper(renderObject, renderObjectOwner, renderableClass, stage);\n\n\t\t//this._pNumUsedStreams = 2;\n\t\t//this._pNumUsedVertexConstants = 7;\n\t\t//this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n\t\t//\n\t\t//this._pAnimatableAttributes = Array<string>(\"va0\", \"va1\");\n\t\t//this._pAnimationTargetRegisters = Array<string>(\"vt0\", \"vt1\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t\tthis._textures = null;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the projection textures used to contain the depth renders.\n\t */\n\tprivate updateProjectionTextures()\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t}\n\n\t\tthis._textures = new Object();\n\t\tthis._projections = new Object();\n\t\tthis._projectionTexturesInvalid = false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode():string\n\t{\n\t\tvar code:string;\n\t\t// offset\n\t\tcode = \"mul vt7, vt1, vc4.x\t\\n\" +\n\t\t\t\t\"add vt7, vt7, vt0\\n\" +\n\t\t\t\t\"mov vt7.w, vt0.w\\n\";\n\t\t// project\n\t\tcode += \"m44 vt2, vt7, vc0\\n\" +\n\t\t\t\t\"mov op, vt2\\n\";\n\n\t\t// perspective divide\n\t\tcode += \"div v0, vt2, vt2.w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shaderObject:ShaderObjectBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\t// encode float -> rgba\n\t\tcode += \"mul ft0, fc0, v0.z\\n\" +\n\t\t\t\t\"frc ft0, ft0\\n\" +\n\t\t\t\t\"mul ft1, ft0.yzww, fc1\\n\" +\n\t\t\t\t\"sub ft0, ft0, ft1\\n\" +\n\t\t\t\t\"mov oc, ft0\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the depth maps rendered for this object from all lights.\n\t * @param renderable The renderable for which to retrieve the depth maps.\n\t * @param stage3DProxy The Stage3DProxy object currently used for rendering.\n\t * @return A list of depth map textures for all supported lights.\n\t */\n\tpublic _iGetDepthMap(renderable:RenderableBase):TextureBase\n\t{\n\t\treturn this._textures[renderable.renderableOwner.id];\n\t}\n\n\t/**\n\t * Retrieves the depth map projection maps for all lights.\n\t * @param renderable The renderable for which to retrieve the projection maps.\n\t * @return A list of projection maps for all supported lights.\n\t */\n\tpublic _iGetProjection(renderable:RenderableBase):Matrix3D\n\t{\n\t\treturn this._projections[renderable.renderableOwner.id];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iRender(renderable:RenderableBase, camera:Camera, viewProjection:Matrix3D)\n\t{\n\t\tvar matrix:Matrix3D;\n\t\tvar context:IContextGL = this._stage.context;\n\t\tvar len:number /*uint*/;\n\t\tvar light:LightBase;\n\t\tvar lights:Array<LightBase> = this._renderObjectOwner.lightPicker.allPickedLights;\n\t\tvar rId:number = renderable.renderableOwner.id;\n\n\t\tif (!this._textures[rId])\n\t\t\tthis._textures[rId] = new Single2DTexture(new Image2D(this._textureSize, this._textureSize));\n\n\t\tif (!this._projections[rId])\n\t\t\tthis._projections[rId] = new Matrix3D();\n\n\t\tlen = lights.length;\n\n\t\t// local position = enough\n\t\tlight = lights[0];\n\n\t\tmatrix = light.iGetObjectProjectionMatrix(renderable.sourceEntity, camera, this._projections[rId]);\n\n\t\tthis._stage.setRenderTarget(this._textures[rId], true);\n\t\tcontext.clear(1.0, 1.0, 1.0);\n\t\tcontext.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, matrix, true);\n\t\tcontext.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, this._enc, 2);\n\n\t\tthis._stage.activateBuffer(0, renderable.getVertexData(TriangleSubGeometry.POSITION_DATA), renderable.getVertexOffset(TriangleSubGeometry.POSITION_DATA), TriangleSubGeometry.POSITION_FORMAT);\n\t\tthis._stage.activateBuffer(1, renderable.getVertexData(TriangleSubGeometry.NORMAL_DATA), renderable.getVertexOffset(TriangleSubGeometry.NORMAL_DATA), TriangleSubGeometry.NORMAL_FORMAT);\n\t\tcontext.drawTriangles(this._stage.getIndexBuffer(renderable.getIndexData()), 0, renderable.numTriangles);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera)\n\t{\n\t\tif (this._projectionTexturesInvalid)\n\t\t\tthis.updateProjectionTextures();\n\n\t\t// never scale\n\t\tsuper._iActivate(camera);\n\n\t\tthis._stage.context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);\n\t}\n}\n\nexport = SingleObjectDepthPass;"
  ],
  "sourceRoot": ""
}