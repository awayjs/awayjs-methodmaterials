{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "awayjs-methodmaterials.js",
    "../index.ts",
    "lib/MethodMaterialMode.ts",
    "lib/MethodMaterial.ts",
    "lib/lib/data/MethodVO.ts",
    "lib/data.ts",
    "lib/lib/methods/AmbientBasicMethod.ts",
    "lib/lib/methods/AmbientEnvMapMethod.ts",
    "lib/lib/methods/CurveBasicMethod.ts",
    "lib/lib/methods/DiffuseBasicMethod.ts",
    "lib/lib/methods/DiffuseCelMethod.ts",
    "lib/lib/methods/DiffuseCompositeMethod.ts",
    "lib/lib/methods/DiffuseDepthMethod.ts",
    "lib/lib/methods/DiffuseGradientMethod.ts",
    "lib/lib/methods/DiffuseLightMapMethod.ts",
    "lib/lib/methods/DiffuseSubSurfaceMethod.ts",
    "lib/lib/methods/DiffuseWrapMethod.ts",
    "lib/lib/methods/EffectAlphaMaskMethod.ts",
    "lib/lib/methods/EffectColorMatrixMethod.ts",
    "lib/lib/methods/EffectColorTransformMethod.ts",
    "lib/lib/methods/EffectEnvMapMethod.ts",
    "lib/lib/methods/EffectFogMethod.ts",
    "lib/lib/methods/EffectFresnelEnvMapMethod.ts",
    "lib/lib/methods/EffectLightMapMethod.ts",
    "lib/lib/methods/EffectMethodBase.ts",
    "lib/lib/methods/EffectRefractionEnvMapMethod.ts",
    "lib/lib/methods/EffectRimLightMethod.ts",
    "lib/lib/methods/LightingMethodBase.ts",
    "lib/lib/methods/NormalBasicMethod.ts",
    "lib/lib/methods/NormalHeightMapMethod.ts",
    "lib/lib/methods/NormalSimpleWaterMethod.ts",
    "lib/lib/methods/ShadingMethodBase.ts",
    "lib/lib/methods/ShadowCascadeMethod.ts",
    "lib/lib/methods/ShadowDitheredMethod.ts",
    "lib/lib/methods/ShadowFilteredMethod.ts",
    "lib/lib/methods/ShadowHardMethod.ts",
    "lib/lib/methods/ShadowMapMethodBase.ts",
    "lib/lib/methods/ShadowMethodBase.ts",
    "lib/lib/methods/ShadowNearMethod.ts",
    "lib/lib/methods/ShadowSoftMethod.ts",
    "lib/lib/methods/SpecularAnisotropicMethod.ts",
    "lib/lib/methods/SpecularBasicMethod.ts",
    "lib/lib/methods/SpecularCelMethod.ts",
    "lib/lib/methods/SpecularCompositeMethod.ts",
    "lib/lib/methods/SpecularFresnelMethod.ts",
    "lib/lib/methods/SpecularPhongMethod.ts",
    "lib/methods.ts",
    "lib/lib/surfaces/GL_MethodMaterialSurface.ts",
    "lib/surfaces/lib/surfaces/passes/MethodPassMode.ts",
    "lib/surfaces/lib/surfaces/passes/MethodPass.ts",
    "lib/surfaces/lib/surfaces/passes/SingleObjectDepthPass.ts",
    "lib/surfaces.ts"
  ],
  "names": [
    "require",
    "e",
    "t",
    "n",
    "r",
    "s",
    "o",
    "u",
    "a",
    "i",
    "f",
    "Error",
    "code",
    "l",
    "exports",
    "call",
    "length",
    1,
    "module",
    "data",
    "methods",
    "surfaces",
    "MethodMaterial_1",
    "MethodMaterial",
    "MethodMaterialMode_1",
    "MethodMaterialMode",
    "SurfacePool_1",
    "SurfacePool",
    "registerAbstraction",
    "GL_MethodMaterialSurface",
    "./lib/MethodMaterial",
    "./lib/MethodMaterialMode",
    "./lib/data",
    "./lib/methods",
    "./lib/surfaces",
    "awayjs-renderergl/lib/surfaces/SurfacePool",
    "undefined",
    "awayjs-methodmaterials/lib/MethodMaterialMode",
    "SINGLE_PASS",
    "MULTI_PASS",
    "awayjs-methodmaterials/lib/MethodMaterial",
    "__extends",
    "this",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "__",
    "constructor",
    "prototype",
    "Object",
    "create",
    "Image2D_1",
    "MaterialBase_1",
    "Single2DTexture_1",
    "ContextGLCompareMode_1",
    "AmbientBasicMethod_1",
    "DiffuseBasicMethod_1",
    "NormalBasicMethod_1",
    "SpecularBasicMethod_1",
    "_super",
    "imageColor",
    "alpha",
    "_effectMethods",
    "Array",
    "_ambientMethod",
    "AmbientBasicMethod",
    "_diffuseMethod",
    "DiffuseBasicMethod",
    "_normalMethod",
    "NormalBasicMethod",
    "_specularMethod",
    "SpecularBasicMethod",
    "_depthCompareMode",
    "ContextGLCompareMode",
    "LESS_EQUAL",
    "_mode",
    "iAddOwner",
    "Image2D",
    "texture",
    "Single2DTexture",
    "defineProperty",
    "get",
    "assetType",
    "enumerable",
    "configurable",
    "set",
    "value",
    "invalidate",
    "iRemoveOwner",
    "_shadowMethod",
    "addEffectMethod",
    "method",
    "push",
    "getEffectMethodAt",
    "index",
    "addEffectMethodAt",
    "splice",
    "removeEffectMethod",
    "indexOf",
    "MaterialBase",
    "./MethodMaterialMode",
    "./methods/AmbientBasicMethod",
    "./methods/DiffuseBasicMethod",
    "./methods/NormalBasicMethod",
    "./methods/SpecularBasicMethod",
    "awayjs-core/lib/image/Image2D",
    "awayjs-display/lib/materials/MaterialBase",
    "awayjs-display/lib/textures/Single2DTexture",
    "awayjs-stagegl/lib/base/ContextGLCompareMode",
    "awayjs-methodmaterials/lib/data/MethodVO",
    "MethodVO",
    "pass",
    "useMethod",
    "reset",
    "iReset",
    "vertexConstantsIndex",
    "secondaryVertexConstantsIndex",
    "fragmentConstantsIndex",
    "secondaryFragmentConstantsIndex",
    "needsProjection",
    "needsView",
    "needsNormals",
    "needsTangents",
    "needsGlobalVertexPos",
    "needsGlobalFragmentPos",
    "awayjs-methodmaterials/lib/data",
    "MethodVO_1",
    "./data/MethodVO",
    "awayjs-methodmaterials/lib/methods/AmbientBasicMethod",
    "AssetEvent_1",
    "ShadingMethodBase_1",
    "_alpha",
    "_colorR",
    "_colorG",
    "_colorB",
    "_strength",
    "iInitVO",
    "shader",
    "methodVO",
    "_texture",
    "textureGL",
    "getAbstraction",
    "uvDependencies",
    "onClear",
    "AssetEvent",
    "CLEAR",
    "iInitConstants",
    "_color",
    "numLights",
    "_surface",
    "style",
    "color",
    "updateColor",
    "iRemoveTexture",
    "iAddTexture",
    "iInvalidateShaderProgram",
    "copyFrom",
    "m",
    "iGetFragmentCode",
    "targetReg",
    "registerCache",
    "sharedRegisters",
    "_iGetFragmentCode",
    "uvVarying",
    "alphaThreshold",
    "cutOffReg",
    "getFreeFragmentConstant",
    "ambientInputRegister",
    "iActivate",
    "stage",
    "activate",
    "_render",
    "fragmentConstantData",
    "iSetRenderState",
    "renderable",
    "camera",
    "_setRenderState",
    "ShadingMethodBase",
    "../methods/ShadingMethodBase",
    "awayjs-core/lib/events/AssetEvent",
    "awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod",
    "AmbientEnvMapMethod",
    "regCache",
    "normalFragment",
    "../methods/AmbientBasicMethod",
    "awayjs-methodmaterials/lib/methods/CurveBasicMethod",
    "CurveBasicMethod",
    "_ambient",
    "default",
    "awayjs-methodmaterials/lib/methods/DiffuseBasicMethod",
    "LightingMethodBase_1",
    "_multiply",
    "_ambientColorR",
    "_ambientColorG",
    "_ambientColorB",
    "iIsUsed",
    "usesCommonData",
    "_ambientColor",
    "updateAmbientColor",
    "dispose",
    "diff",
    "multiply",
    "iCleanCompilationData",
    "_pTotalLightColorReg",
    "iGetFragmentPreLightingCode",
    "_pIsFirstLight",
    "addFragmentTempUsages",
    "getFreeFragmentVectorTemp",
    "iGetFragmentCodePerLight",
    "lightDirReg",
    "lightColReg",
    "commons",
    "usesLightFallOff",
    "_iModulateMethod",
    "removeFragmentTempUsage",
    "iGetFragmentCodePerProbe",
    "cubeMapReg",
    "weightRegister",
    "iGetFragmentPostLightingCode",
    "diffuseColor",
    "shadowTarget",
    "pApplyShadow",
    "ambientColorRegister",
    "diffuseInputRegister",
    "ambientR",
    "ambientG",
    "ambientB",
    "LightingMethodBase",
    "../methods/LightingMethodBase",
    "awayjs-methodmaterials/lib/methods/DiffuseCelMethod",
    "DiffuseCompositeMethod_1",
    "DiffuseCelMethod",
    "levels",
    "baseMethod",
    "_this",
    "_smoothness",
    "clampDiffuse",
    "_levels",
    "_dataReg",
    "DiffuseCompositeMethod",
    "../methods/DiffuseCompositeMethod",
    "awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod",
    "ShadingMethodEvent_1",
    "modulateMethod",
    "_onShaderInvalidatedDelegate",
    "event",
    "onShaderInvalidated",
    "pBaseMethod",
    "addEventListener",
    "ShadingMethodEvent",
    "SHADER_INVALIDATED",
    "removeEventListener",
    "owner",
    "iDeactivate",
    "iGetVertexCode",
    "../methods/DiffuseBasicMethod",
    "awayjs-renderergl/lib/events/ShadingMethodEvent",
    "awayjs-methodmaterials/lib/methods/DiffuseDepthMethod",
    "DiffuseDepthMethod",
    "temp",
    "decReg",
    "awayjs-methodmaterials/lib/methods/DiffuseGradientMethod",
    "DiffuseGradientMethod",
    "gradient",
    "_gradient",
    "secondaryTextureGL",
    "awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod",
    "DiffuseLightMapMethod",
    "lightMap",
    "blendMode",
    "useSecondaryUV",
    "_useSecondaryUV",
    "_lightMap",
    "secondaryUVDependencies",
    "_blendMode",
    "ADD",
    "MULTIPLY",
    "secondaryUVVarying",
    "awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod",
    "DiffuseSubSurfaceMethod",
    "depthMapSize",
    "depthMapOffset",
    "_translucency",
    "_scatterColor",
    "_scatterR",
    "_scatterG",
    "_scatterB",
    "scatterLight",
    "_scattering",
    "vertexConstantData",
    "_lightProjVarying",
    "_propReg",
    "_lightColorReg",
    "_colorReg",
    "_decReg",
    "_targetReg",
    "scatterColor",
    "lightProjection",
    "toTexRegister",
    "getFreeVertexVectorTemp",
    "getFreeVertexConstant",
    "getFreeVarying",
    "viewDirFragment",
    "_depthPass",
    "_iGetDepthMap",
    "_iGetProjection",
    "copyRawDataTo",
    "awayjs-methodmaterials/lib/methods/DiffuseWrapMethod",
    "DiffuseWrapMethod",
    "wrapFactor",
    "_wrapDataRegister",
    "_wrapFactor",
    "awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod",
    "EffectMethodBase_1",
    "EffectAlphaMaskMethod",
    "EffectMethodBase",
    "../methods/EffectMethodBase",
    "awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod",
    "EffectColorMatrixMethod",
    "matrix",
    "_matrix",
    "colorMultReg",
    "colorOffsetReg",
    "awayjs-methodmaterials/lib/methods/EffectColorTransformMethod",
    "EffectColorTransformMethod",
    "_colorTransform",
    "colorOffsReg",
    "inv",
    "redMultiplier",
    "greenMultiplier",
    "blueMultiplier",
    "alphaMultiplier",
    "redOffset",
    "greenOffset",
    "blueOffset",
    "alphaOffset",
    "awayjs-methodmaterials/lib/methods/EffectEnvMapMethod",
    "EffectEnvMapMethod",
    "envMap",
    "_envMap",
    "_mask",
    "dataRegister",
    "temp2",
    "awayjs-methodmaterials/lib/methods/EffectFogMethod",
    "EffectFogMethod",
    "minDistance",
    "maxDistance",
    "fogColor",
    "_minDistance",
    "_maxDistance",
    "_fogColor",
    "_fogR",
    "_fogG",
    "_fogB",
    "fogData",
    "projectionFragment",
    "awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod",
    "EffectFresnelEnvMapMethod",
    "_fresnelPower",
    "_normalReflectance",
    "viewDirReg",
    "normalReg",
    "awayjs-methodmaterials/lib/methods/EffectLightMapMethod",
    "EffectLightMapMethod",
    "awayjs-methodmaterials/lib/methods/EffectMethodBase",
    "AbstractMethodError_1",
    "AbstractMethodError",
    "awayjs-core/lib/errors/AbstractMethodError",
    "awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod",
    "EffectRefractionEnvMapMethod",
    "refractionIndex",
    "dispersionR",
    "dispersionG",
    "dispersionB",
    "_dispersionR",
    "_dispersionG",
    "_dispersionB",
    "_useDispersion",
    "_refractionIndex",
    "useDispersion",
    "data2",
    "refractionDir",
    "refractionColor",
    "awayjs-methodmaterials/lib/methods/EffectRimLightMethod",
    "EffectRimLightMethod",
    "strength",
    "power",
    "blend",
    "_power",
    "dataRegister2",
    "MIX",
    "awayjs-methodmaterials/lib/methods/LightingMethodBase",
    "awayjs-methodmaterials/lib/methods/NormalBasicMethod",
    "normalDependencies",
    "iOutputsTangentNormals",
    "bnm",
    "awayjs-methodmaterials/lib/methods/NormalHeightMapMethod",
    "NormalHeightMapMethod",
    "heightMap",
    "worldWidth",
    "worldHeight",
    "worldDepth",
    "_worldXYRatio",
    "_worldXZRatio",
    "image2D",
    "width",
    "height",
    "dataReg",
    "dataReg2",
    "../methods/NormalBasicMethod",
    "awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod",
    "NormalSimpleWaterMethod",
    "normalMap",
    "secondaryNormalMap",
    "_water1OffsetX",
    "_water1OffsetY",
    "_water2OffsetX",
    "_water2OffsetY",
    "_secondaryNormalMap",
    "awayjs-methodmaterials/lib/methods/ShadingMethodBase",
    "AssetBase_1",
    "_textures",
    "_owners",
    "_counts",
    "iUsesTangentSpace",
    "len",
    "addTexture",
    "removeTexture",
    "dispatchEvent",
    "AssetBase",
    "awayjs-core/lib/library/AssetBase",
    "awayjs-methodmaterials/lib/methods/ShadowCascadeMethod",
    "DirectionalLight_1",
    "ShadowMapMethodBase_1",
    "ShadowCascadeMethod",
    "shadowMethodBase",
    "castingLight",
    "_baseMethod",
    "_pCastingLight",
    "DirectionalLight",
    "_cascadeShadowMapper",
    "shadowMapper",
    "INVALIDATE",
    "onCascadeChange",
    "tempVO",
    "depthMap",
    "fragmentData",
    "vertexData",
    "_cascadeProjections",
    "_depthMapCoordVaryings",
    "initProjectionsRegs",
    "numCascades",
    "globalPositionVertex",
    "planeDistanceReg",
    "planeDistances",
    "inQuad",
    "uvCoord",
    "uvProjection",
    "_iGetCascadeFragmentCode",
    "vertexIndex",
    "depth",
    "_pEpsilon",
    "k",
    "getDepthProjections",
    "fragmentIndex",
    "_pAlpha",
    "nearPlaneDistances",
    "_iNearPlaneDistances",
    "iActivateForCascade",
    "ShadowMapMethodBase",
    "../data/MethodVO",
    "../methods/ShadowMapMethodBase",
    "awayjs-display/lib/display/DirectionalLight",
    "awayjs-methodmaterials/lib/methods/ShadowDitheredMethod",
    "BitmapImage2D_1",
    "ShadowMethodBase_1",
    "ShadowDitheredMethod",
    "numSamples",
    "range",
    "_depthMapSize",
    "_grainUsages",
    "_grainTexture",
    "initGrainTexture",
    "_numSamples",
    "_range",
    "_grainBitmapImage2D",
    "BitmapImage2D",
    "vec",
    "step",
    "g",
    "Math",
    "random",
    "floor",
    "setArray",
    "rect",
    "_pGetPlanarFragmentCode",
    "customDataReg",
    "getSampleCode",
    "uvReg",
    "projectionReg",
    "_pDepthMapCoordReg",
    "addSample",
    "decodeRegister",
    "depthProjection",
    "targetRegister",
    "ShadowMethodBase",
    "../methods/ShadowMethodBase",
    "awayjs-core/lib/image/BitmapImage2D",
    "awayjs-methodmaterials/lib/methods/ShadowFilteredMethod",
    "ShadowFilteredMethod",
    "size",
    "depthCol",
    "predicate",
    "awayjs-methodmaterials/lib/methods/ShadowHardMethod",
    "ShadowHardMethod",
    "_pGetPointFragmentCode",
    "epsReg",
    "posReg",
    "depthSampleCol",
    "lightDir",
    "globalPositionVarying",
    "awayjs-methodmaterials/lib/methods/ShadowMapMethodBase",
    "shadowsEnabled",
    "_pShadowMapper",
    "awayjs-methodmaterials/lib/methods/ShadowMethodBase",
    "PointLight_1",
    "_pUsePoint",
    "PointLight",
    "_pGetPointVertexCode",
    "pGetPlanarVertexCode",
    "depthMapProj",
    "iDepthProjection",
    "pow",
    "fallOff",
    "pos",
    "scenePosition",
    "x",
    "y",
    "z",
    "awayjs-display/lib/display/PointLight",
    "awayjs-methodmaterials/lib/methods/ShadowNearMethod",
    "ShadowNearMethod",
    "fadeRatio",
    "_fadeRatio",
    "_nearShadowMapper",
    "epsilon",
    "getFreeFragmentSingleTemp",
    "near",
    "projection",
    "far",
    "coverageRatio",
    "awayjs-methodmaterials/lib/methods/ShadowSoftMethod",
    "PoissonLookup_1",
    "ShadowSoftMethod",
    "_offsets",
    "PoissonLookup",
    "getDistribution",
    "texRange",
    "offsets",
    "numRegs",
    "reg",
    "awayjs-core/lib/geom/PoissonLookup",
    "awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod",
    "SpecularAnisotropicMethod",
    "tangentVarying",
    "_pSpecularTexData",
    "_pSpecularDataRegister",
    "../methods/SpecularBasicMethod",
    "awayjs-methodmaterials/lib/methods/SpecularBasicMethod",
    "_gloss",
    "_iSpecularR",
    "_iSpecularG",
    "_iSpecularB",
    "updateSpecular",
    "bsm",
    "spec",
    "gloss",
    "awayjs-methodmaterials/lib/methods/SpecularCelMethod",
    "SpecularCompositeMethod_1",
    "SpecularCelMethod",
    "specularCutOff",
    "_specularCutOff",
    "clampSpecular",
    "SpecularCompositeMethod",
    "../methods/SpecularCompositeMethod",
    "awayjs-methodmaterials/lib/methods/SpecularCompositeMethod",
    "awayjs-methodmaterials/lib/methods/SpecularFresnelMethod",
    "SpecularFresnelMethod",
    "basedOnSurface",
    "modulateSpecular",
    "_incidentLight",
    "awayjs-methodmaterials/lib/methods/SpecularPhongMethod",
    "SpecularPhongMethod",
    "awayjs-methodmaterials/lib/methods",
    "AmbientEnvMapMethod_1",
    "CurveBasicMethod_1",
    "DiffuseCelMethod_1",
    "DiffuseDepthMethod_1",
    "DiffuseGradientMethod_1",
    "DiffuseLightMapMethod_1",
    "DiffuseSubSurfaceMethod_1",
    "DiffuseWrapMethod_1",
    "EffectAlphaMaskMethod_1",
    "EffectColorMatrixMethod_1",
    "EffectColorTransformMethod_1",
    "EffectEnvMapMethod_1",
    "EffectFogMethod_1",
    "EffectFresnelEnvMapMethod_1",
    "EffectLightMapMethod_1",
    "EffectRefractionEnvMapMethod_1",
    "EffectRimLightMethod_1",
    "NormalHeightMapMethod_1",
    "NormalSimpleWaterMethod_1",
    "ShadowCascadeMethod_1",
    "ShadowDitheredMethod_1",
    "ShadowFilteredMethod_1",
    "ShadowHardMethod_1",
    "ShadowNearMethod_1",
    "ShadowSoftMethod_1",
    "SpecularAnisotropicMethod_1",
    "SpecularCelMethod_1",
    "SpecularFresnelMethod_1",
    "SpecularPhongMethod_1",
    "./methods/AmbientEnvMapMethod",
    "./methods/CurveBasicMethod",
    "./methods/DiffuseCelMethod",
    "./methods/DiffuseCompositeMethod",
    "./methods/DiffuseDepthMethod",
    "./methods/DiffuseGradientMethod",
    "./methods/DiffuseLightMapMethod",
    "./methods/DiffuseSubSurfaceMethod",
    "./methods/DiffuseWrapMethod",
    "./methods/EffectAlphaMaskMethod",
    "./methods/EffectColorMatrixMethod",
    "./methods/EffectColorTransformMethod",
    "./methods/EffectEnvMapMethod",
    "./methods/EffectFogMethod",
    "./methods/EffectFresnelEnvMapMethod",
    "./methods/EffectLightMapMethod",
    "./methods/EffectMethodBase",
    "./methods/EffectRefractionEnvMapMethod",
    "./methods/EffectRimLightMethod",
    "./methods/LightingMethodBase",
    "./methods/NormalHeightMapMethod",
    "./methods/NormalSimpleWaterMethod",
    "./methods/ShadingMethodBase",
    "./methods/ShadowCascadeMethod",
    "./methods/ShadowDitheredMethod",
    "./methods/ShadowFilteredMethod",
    "./methods/ShadowHardMethod",
    "./methods/ShadowMapMethodBase",
    "./methods/ShadowMethodBase",
    "./methods/ShadowNearMethod",
    "./methods/ShadowSoftMethod",
    "./methods/SpecularAnisotropicMethod",
    "./methods/SpecularCelMethod",
    "./methods/SpecularCompositeMethod",
    "./methods/SpecularFresnelMethod",
    "./methods/SpecularPhongMethod",
    "awayjs-methodmaterials/lib/surfaces/GL_MethodMaterialSurface",
    "BlendMode_1",
    "StaticLightPicker_1",
    "GL_SurfaceBase_1",
    "MethodPassMode_1",
    "MethodPass_1",
    "material",
    "elementsClass",
    "pool",
    "_material",
    "lightPicker",
    "numLightProbes",
    "numDirectionalLights",
    "numPointLights",
    "numCastingDirectionalLights",
    "numCastingPointLights",
    "_pUpdateRender",
    "initPasses",
    "setBlendAndCompareModes",
    "_pClearPasses",
    "mode",
    "_casterLightPass",
    "_pAddPass",
    "_nonCasterLightPasses",
    "_pass",
    "numEffectMethods",
    "initEffectPass",
    "removeEffectPass",
    "shadowMethod",
    "initCasterLightPass",
    "removeCasterLightPass",
    "numNonCasters",
    "initNonCasterLightPasses",
    "removeNonCasterLightPasses",
    "forceSeparateMVP",
    "Boolean",
    "setBlendMode",
    "BlendMode",
    "NORMAL",
    "depthCompareMode",
    "firstAdditiveIndex",
    "_pRequiresBlending",
    "MethodPassMode",
    "EFFECTS",
    "LAYER",
    "alphaBlending",
    "colorTransform",
    "SUPER_SHADER",
    "preserveAlpha",
    "MethodPass",
    "LIGHTING",
    "_elementsClass",
    "_stage",
    "StaticLightPicker",
    "diffuseMethod",
    "ambientMethod",
    "normalMethod",
    "specularMethod",
    "_pRemovePass",
    "numDirLights",
    "dirLightOffset",
    "pointLightOffset",
    "probeOffset",
    "includeCasters",
    "directionalLightsOffset",
    "pointLightsOffset",
    "lightProbesOffset",
    "effectMethod",
    "max",
    "removeEffectMethodAt",
    "GL_SurfaceBase",
    "../MethodMaterialMode",
    "../surfaces/passes/MethodPass",
    "../surfaces/passes/MethodPassMode",
    "awayjs-core/lib/image/BlendMode",
    "awayjs-display/lib/materials/lightpickers/StaticLightPicker",
    "awayjs-renderergl/lib/surfaces/GL_SurfaceBase",
    "awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode",
    "awayjs-methodmaterials/lib/surfaces/passes/MethodPass",
    "LightSources_1",
    "LightingShader_1",
    "ShaderBase_1",
    "PassBase_1",
    "render",
    "renderOwner",
    "_maxLights",
    "_includeCasters",
    "_iMethodVOs",
    "_numEffectDependencies",
    "_onLightsChangeDelegate",
    "onLightsChange",
    "_onMethodInvalidatedDelegate",
    "onMethodInvalidated",
    "_shader",
    "_updateShader",
    "_updateLights",
    "_lightPicker",
    "enableLightFallOff",
    "diffuseLightSources",
    "specularLightSources",
    "LightingShader",
    "ShaderBase",
    "_iInitConstantData",
    "colorTransformMethod",
    "_iColorTransformMethodVO",
    "_removeDependency",
    "_addDependency",
    "effectsDependency",
    "hasEffectMethod",
    "getDependencyForMethod",
    "_iNormalMethodVO",
    "_iAmbientMethodVO",
    "_iShadowMethodVO",
    "_iDiffuseMethodVO",
    "_iSpecularMethodVO",
    "_iActivate",
    "viewProjection",
    "_iDeactivate",
    "_iIncludeDependencies",
    "usesFragmentAnimation",
    "useAlphaPremultiplied",
    "usesBlending",
    "setupAndCountDependencies",
    "usesTangentSpace",
    "outputsNormals",
    "outputsTangentNormals",
    "usesProbes",
    "viewDirDependencies",
    "globalPosDependencies",
    "usesLights",
    "usesGlobalPosFragment",
    "projectionDependencies",
    "tangentDependencies",
    "_iGetPreLightingVertexCode",
    "_iGetPreLightingFragmentCode",
    "shadedTarget",
    "_iGetPerLightDiffuseFragmentCode",
    "diffuseColorReg",
    "_iGetPerLightSpecularFragmentCode",
    "specularColorReg",
    "_iGetPerProbeDiffuseFragmentCode",
    "texReg",
    "weightReg",
    "_iGetPerProbeSpecularFragmentCode",
    "_iGetPostLightingVertexCode",
    "_iGetPostLightingFragmentCode",
    "_iGetNormalVertexCode",
    "_iGetNormalFragmentCode",
    "removeVertexTempUsage",
    "_iGetVertexCode",
    "sharedReg",
    "alphaReg",
    "_iUsesShadows",
    "castingDirectionalLights",
    "castingPointLights",
    "_iUsesSpecular",
    "_iUsesDiffuse",
    "numDirectionalLightsOld",
    "numPointLightsOld",
    "numLightProbesOld",
    "calculateNumDirectionalLights",
    "calculateNumPointLights",
    "calculateNumProbes",
    "min",
    "numFree",
    "numChannels",
    "LightSources",
    "PROBES",
    "PassBase",
    "../../data/MethodVO",
    "../../methods/EffectColorTransformMethod",
    "../../surfaces/passes/MethodPassMode",
    "awayjs-display/lib/materials/LightSources",
    "awayjs-renderergl/lib/shaders/LightingShader",
    "awayjs-renderergl/lib/shaders/ShaderBase",
    "awayjs-renderergl/lib/surfaces/passes/PassBase",
    "awayjs-methodmaterials/lib/surfaces/passes/SingleObjectDepthPass",
    "Matrix3D_1",
    "SingleObjectDepthPass",
    "_textureSize",
    "_polyOffset",
    "Float32Array",
    "_projectionTexturesInvalid",
    "key",
    "updateProjectionTextures",
    "_projections",
    "renderableGL",
    "id",
    "_iRender",
    "context",
    "light",
    "lights",
    "allPickedLights",
    "rId",
    "Matrix3D",
    "iGetObjectProjectionMatrix",
    "sourceEntity",
    "sceneTransform",
    "setRenderTarget",
    "clear",
    "elementsGL",
    "awayjs-core/lib/geom/Matrix3D",
    "awayjs-methodmaterials/lib/surfaces",
    "SingleObjectDepthPass_1",
    "GL_MethodMaterialSurface_1",
    "./surfaces/GL_MethodMaterialSurface",
    "./surfaces/passes/MethodPass",
    "./surfaces/passes/MethodPassMode",
    "./surfaces/passes/SingleObjectDepthPass"
  ],
  "mappings": "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",
  "file": "awayjs-methodmaterials.min.js",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\nvar data = require(\"./lib/data\");\nexports.data = data;\nvar methods = require(\"./lib/methods\");\nexports.methods = methods;\nvar surfaces = require(\"./lib/surfaces\");\nexports.surfaces = surfaces;\nvar MethodMaterial_1 = require(\"./lib/MethodMaterial\");\nexports.MethodMaterial = MethodMaterial_1.MethodMaterial;\nvar MethodMaterialMode_1 = require(\"./lib/MethodMaterialMode\");\nexports.MethodMaterialMode = MethodMaterialMode_1.MethodMaterialMode;\nvar SurfacePool_1 = require(\"awayjs-renderergl/lib/surfaces/SurfacePool\");\nSurfacePool_1.SurfacePool.registerAbstraction(surfaces.GL_MethodMaterialSurface, MethodMaterial_1.MethodMaterial);\n\n},{\"./lib/MethodMaterial\":\"awayjs-methodmaterials/lib/MethodMaterial\",\"./lib/MethodMaterialMode\":\"awayjs-methodmaterials/lib/MethodMaterialMode\",\"./lib/data\":\"awayjs-methodmaterials/lib/data\",\"./lib/methods\":\"awayjs-methodmaterials/lib/methods\",\"./lib/surfaces\":\"awayjs-methodmaterials/lib/surfaces\",\"awayjs-renderergl/lib/surfaces/SurfacePool\":undefined}],\"awayjs-methodmaterials/lib/MethodMaterialMode\":[function(require,module,exports){\n\"use strict\";\nvar MethodMaterialMode = (function () {\n    function MethodMaterialMode() {\n    }\n    /**\n     *\n     */\n    MethodMaterialMode.SINGLE_PASS = \"singlePass\";\n    /**\n     *\n     */\n    MethodMaterialMode.MULTI_PASS = \"multiPass\";\n    return MethodMaterialMode;\n}());\nexports.MethodMaterialMode = MethodMaterialMode;\n\n},{}],\"awayjs-methodmaterials/lib/MethodMaterial\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Image2D_1 = require(\"awayjs-core/lib/image/Image2D\");\nvar MaterialBase_1 = require(\"awayjs-display/lib/materials/MaterialBase\");\nvar Single2DTexture_1 = require(\"awayjs-display/lib/textures/Single2DTexture\");\nvar ContextGLCompareMode_1 = require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\nvar MethodMaterialMode_1 = require(\"./MethodMaterialMode\");\nvar AmbientBasicMethod_1 = require(\"./methods/AmbientBasicMethod\");\nvar DiffuseBasicMethod_1 = require(\"./methods/DiffuseBasicMethod\");\nvar NormalBasicMethod_1 = require(\"./methods/NormalBasicMethod\");\nvar SpecularBasicMethod_1 = require(\"./methods/SpecularBasicMethod\");\n/**\n * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,\n * using material methods to define their appearance.\n */\nvar MethodMaterial = (function (_super) {\n    __extends(MethodMaterial, _super);\n    function MethodMaterial(imageColor, alpha) {\n        if (imageColor === void 0) { imageColor = null; }\n        if (alpha === void 0) { alpha = 1; }\n        _super.call(this, imageColor, alpha);\n        this._effectMethods = new Array();\n        this._ambientMethod = new AmbientBasicMethod_1.AmbientBasicMethod();\n        this._diffuseMethod = new DiffuseBasicMethod_1.DiffuseBasicMethod();\n        this._normalMethod = new NormalBasicMethod_1.NormalBasicMethod();\n        this._specularMethod = new SpecularBasicMethod_1.SpecularBasicMethod();\n        this._depthCompareMode = ContextGLCompareMode_1.ContextGLCompareMode.LESS_EQUAL;\n        this._mode = MethodMaterialMode_1.MethodMaterialMode.SINGLE_PASS;\n        //add default methods owners\n        this._ambientMethod.iAddOwner(this);\n        this._diffuseMethod.iAddOwner(this);\n        this._normalMethod.iAddOwner(this);\n        this._specularMethod.iAddOwner(this);\n        //set a texture if an image is present\n        if (imageColor instanceof Image2D_1.Image2D)\n            this._ambientMethod.texture = new Single2DTexture_1.Single2DTexture();\n    }\n    Object.defineProperty(MethodMaterial.prototype, \"assetType\", {\n        /**\n         *\n         */\n        get: function () {\n            return MethodMaterial.assetType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"mode\", {\n        get: function () {\n            return this._mode;\n        },\n        set: function (value) {\n            if (this._mode == value)\n                return;\n            this._mode = value;\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"depthCompareMode\", {\n        /**\n         * The depth compare mode used to render the renderables using this material.\n         *\n         * @see away.stagegl.ContextGLCompareMode\n         */\n        get: function () {\n            return this._depthCompareMode;\n        },\n        set: function (value) {\n            if (this._depthCompareMode == value)\n                return;\n            this._depthCompareMode = value;\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"diffuseTexture\", {\n        /**\n         * The texture object to use for the ambient colour.\n         */\n        get: function () {\n            return this._diffuseMethod.texture;\n        },\n        set: function (value) {\n            this._diffuseMethod.texture = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"ambientMethod\", {\n        /**\n         * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n         */\n        get: function () {\n            return this._ambientMethod;\n        },\n        set: function (value) {\n            if (this._ambientMethod == value)\n                return;\n            if (this._ambientMethod)\n                this._ambientMethod.iRemoveOwner(this);\n            this._ambientMethod = value;\n            if (this._ambientMethod)\n                this._ambientMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"shadowMethod\", {\n        /**\n         * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n         */\n        get: function () {\n            return this._shadowMethod;\n        },\n        set: function (value) {\n            if (this._shadowMethod == value)\n                return;\n            if (this._shadowMethod)\n                this._shadowMethod.iRemoveOwner(this);\n            this._shadowMethod = value;\n            if (this._shadowMethod)\n                this._shadowMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"diffuseMethod\", {\n        /**\n         * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n         */\n        get: function () {\n            return this._diffuseMethod;\n        },\n        set: function (value) {\n            if (this._diffuseMethod == value)\n                return;\n            if (this._diffuseMethod)\n                this._diffuseMethod.iRemoveOwner(this);\n            this._diffuseMethod = value;\n            if (this._diffuseMethod)\n                this._diffuseMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"specularMethod\", {\n        /**\n         * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n         */\n        get: function () {\n            return this._specularMethod;\n        },\n        set: function (value) {\n            if (this._specularMethod == value)\n                return;\n            if (this._specularMethod)\n                this._specularMethod.iRemoveOwner(this);\n            this._specularMethod = value;\n            if (this._specularMethod)\n                this._specularMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"normalMethod\", {\n        /**\n         * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n         */\n        get: function () {\n            return this._normalMethod;\n        },\n        set: function (value) {\n            if (this._normalMethod == value)\n                return;\n            if (this._normalMethod)\n                this._normalMethod.iRemoveOwner(this);\n            this._normalMethod = value;\n            if (this._normalMethod)\n                this._normalMethod.iAddOwner(this);\n            this.invalidate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodMaterial.prototype, \"numEffectMethods\", {\n        get: function () {\n            return this._effectMethods.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n     * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n     * methods added prior.\n     */\n    MethodMaterial.prototype.addEffectMethod = function (method) {\n        method.iAddOwner(this);\n        this._effectMethods.push(method);\n        this.invalidate();\n    };\n    /**\n     * Returns the method added at the given index.\n     * @param index The index of the method to retrieve.\n     * @return The method at the given index.\n     */\n    MethodMaterial.prototype.getEffectMethodAt = function (index) {\n        return this._effectMethods[index];\n    };\n    /**\n     * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n     * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n     * etc. The method will be applied to the result of the methods with a lower index.\n     */\n    MethodMaterial.prototype.addEffectMethodAt = function (method, index) {\n        method.iAddOwner(this);\n        this._effectMethods.splice(index, 0, method);\n        this.invalidate();\n    };\n    /**\n     * Removes an effect method from the material.\n     * @param method The method to be removed.\n     */\n    MethodMaterial.prototype.removeEffectMethod = function (method) {\n        method.iRemoveOwner(this);\n        this._effectMethods.splice(this._effectMethods.indexOf(method), 1);\n        this.invalidate();\n    };\n    MethodMaterial.assetType = \"[materials MethodMaterial]\";\n    return MethodMaterial;\n}(MaterialBase_1.MaterialBase));\nexports.MethodMaterial = MethodMaterial;\n\n},{\"./MethodMaterialMode\":\"awayjs-methodmaterials/lib/MethodMaterialMode\",\"./methods/AmbientBasicMethod\":\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\",\"./methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\",\"./methods/NormalBasicMethod\":\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\",\"./methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\",\"awayjs-core/lib/image/Image2D\":undefined,\"awayjs-display/lib/materials/MaterialBase\":undefined,\"awayjs-display/lib/textures/Single2DTexture\":undefined,\"awayjs-stagegl/lib/base/ContextGLCompareMode\":undefined}],\"awayjs-methodmaterials/lib/data/MethodVO\":[function(require,module,exports){\n\"use strict\";\n/**\n * MethodVO contains data for a given shader object for the use within a single material.\n * This allows shader methods to be shared across materials while their non-public state differs.\n */\nvar MethodVO = (function () {\n    /**\n     * Creates a new MethodVO object.\n     */\n    function MethodVO(method, pass) {\n        this.useMethod = true;\n        this.method = method;\n        this.pass = pass;\n    }\n    /**\n     * Resets the values of the value object to their \"unused\" state.\n     */\n    MethodVO.prototype.reset = function () {\n        this.method.iReset();\n        this.vertexConstantsIndex = -1;\n        this.secondaryVertexConstantsIndex = -1;\n        this.fragmentConstantsIndex = -1;\n        this.secondaryFragmentConstantsIndex = -1;\n        this.needsProjection = false;\n        this.needsView = false;\n        this.needsNormals = false;\n        this.needsTangents = false;\n        this.needsGlobalVertexPos = false;\n        this.needsGlobalFragmentPos = false;\n    };\n    return MethodVO;\n}());\nexports.MethodVO = MethodVO;\n\n},{}],\"awayjs-methodmaterials/lib/data\":[function(require,module,exports){\n\"use strict\";\nvar MethodVO_1 = require(\"./data/MethodVO\");\nexports.MethodVO = MethodVO_1.MethodVO;\n\n},{\"./data/MethodVO\":\"awayjs-methodmaterials/lib/data/MethodVO\"}],\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar ShadingMethodBase_1 = require(\"../methods/ShadingMethodBase\");\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nvar AmbientBasicMethod = (function (_super) {\n    __extends(AmbientBasicMethod, _super);\n    /**\n     * Creates a new AmbientBasicMethod object.\n     */\n    function AmbientBasicMethod() {\n        _super.call(this);\n        this._alpha = 1;\n        this._colorR = 1;\n        this._colorG = 1;\n        this._colorB = 1;\n        this._strength = 1;\n    }\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, this._texture));\n            methodVO.textureGL = null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.iInitConstants = function (shader, methodVO) {\n        if (!methodVO.textureGL) {\n            this._color = shader.numLights ? 0xFFFFFF : methodVO.pass._surface.style.color;\n            this.updateColor();\n        }\n    };\n    Object.defineProperty(AmbientBasicMethod.prototype, \"strength\", {\n        /**\n         * The strength of the ambient reflection of the surface.\n         */\n        get: function () {\n            return this._strength;\n        },\n        set: function (value) {\n            if (this._strength == value)\n                return;\n            this._strength = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AmbientBasicMethod.prototype, \"alpha\", {\n        /**\n         * The alpha component of the surface.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            if (this._alpha == value)\n                return;\n            this._alpha = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AmbientBasicMethod.prototype, \"texture\", {\n        /**\n         * The texture to use to define the diffuse reflection color per texel.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.copyFrom = function (method) {\n        var m = method;\n        var b = m;\n    };\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (methodVO.textureGL) {\n            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n            if (shader.alphaThreshold > 0) {\n                var cutOffReg = registerCache.getFreeFragmentConstant();\n                methodVO.fragmentConstantsIndex = cutOffReg.index * 4;\n                code += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n                    \"kil \" + targetReg + \".w\\n\" +\n                    \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n            }\n        }\n        else {\n            var ambientInputRegister = registerCache.getFreeFragmentConstant();\n            methodVO.fragmentConstantsIndex = ambientInputRegister.index * 4;\n            code += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n        }\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    AmbientBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (methodVO.textureGL) {\n            methodVO.textureGL.activate(methodVO.pass._render);\n            if (shader.alphaThreshold > 0)\n                shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n        }\n        else {\n            var index = methodVO.fragmentConstantsIndex;\n            var data = shader.fragmentConstantData;\n            data[index] = this._colorR;\n            data[index + 1] = this._colorG;\n            data[index + 2] = this._colorB;\n            data[index + 3] = this._alpha;\n        }\n    };\n    AmbientBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (methodVO.textureGL)\n            methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Updates the ambient color data used by the render state.\n     */\n    AmbientBasicMethod.prototype.updateColor = function () {\n        this._colorR = ((this._color >> 16) & 0xff) / 0xff * this._strength;\n        this._colorG = ((this._color >> 8) & 0xff) / 0xff * this._strength;\n        this._colorB = (this._color & 0xff) / 0xff * this._strength;\n    };\n    return AmbientBasicMethod;\n}(ShadingMethodBase_1.ShadingMethodBase));\nexports.AmbientBasicMethod = AmbientBasicMethod;\n\n},{\"../methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\",\"awayjs-core/lib/events/AssetEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar AmbientBasicMethod_1 = require(\"../methods/AmbientBasicMethod\");\n/**\n * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to\n * approximate global lighting rather than lights.\n */\nvar AmbientEnvMapMethod = (function (_super) {\n    __extends(AmbientEnvMapMethod, _super);\n    /**\n     * Creates a new <code>AmbientEnvMapMethod</code> object.\n     *\n     * @param envMap The cube environment map to use for the ambient lighting.\n     */\n    function AmbientEnvMapMethod() {\n        _super.call(this);\n    }\n    /**\n     * @inheritDoc\n     */\n    AmbientEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, this._texture));\n            methodVO.textureGL = null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    AmbientEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        return (this._texture) ? methodVO.textureGL._iGetFragmentCode(targetReg, regCache, sharedRegisters, sharedRegisters.normalFragment) : \"\";\n    };\n    return AmbientEnvMapMethod;\n}(AmbientBasicMethod_1.AmbientBasicMethod));\nexports.AmbientEnvMapMethod = AmbientEnvMapMethod;\n\n},{\"../methods/AmbientBasicMethod\":\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\",\"awayjs-core/lib/events/AssetEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/CurveBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar ShadingMethodBase_1 = require(\"../methods/ShadingMethodBase\");\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nvar CurveBasicMethod = (function (_super) {\n    __extends(CurveBasicMethod, _super);\n    /**\n     * Creates a new AmbientBasicMethod object.\n     */\n    function CurveBasicMethod() {\n        _super.call(this);\n        this._color = 0xffffff;\n        this._alpha = 1;\n        this._colorR = 1;\n        this._colorG = 1;\n        this._colorB = 1;\n        this._ambient = 1;\n    }\n    /**\n     * @inheritDoc\n     */\n    CurveBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, this._texture));\n            methodVO.textureGL = null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    CurveBasicMethod.prototype.iInitConstants = function (shader, methodVO) {\n        if (!methodVO.textureGL) {\n            this._color = methodVO.pass._surface.style.color;\n            this.updateColor();\n        }\n    };\n    Object.defineProperty(CurveBasicMethod.prototype, \"ambient\", {\n        /**\n         * The strength of the ambient reflection of the surface.\n         */\n        get: function () {\n            return this._ambient;\n        },\n        set: function (value) {\n            if (this._ambient == value)\n                return;\n            this._ambient = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CurveBasicMethod.prototype, \"alpha\", {\n        /**\n         * The alpha component of the surface.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            if (this._alpha == value)\n                return;\n            this._alpha = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CurveBasicMethod.prototype, \"texture\", {\n        /**\n         * The texture to use to define the diffuse reflection color per texel.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    CurveBasicMethod.prototype.copyFrom = function (method) {\n        var m = method;\n        var b = m;\n    };\n    /**\n     * @inheritDoc\n     */\n    /*\n    public iGeVertexCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string {\n        var code:string = \"\";\n        code = \"mov \" + sharedRegisters.uvVarying + \" \" + registerCache.uv +  \" \\n\";\n    }*/\n    CurveBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var ambientInputRegister;\n        if (methodVO.textureGL) {\n            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n            if (shader.alphaThreshold > 0) {\n                var cutOffReg = registerCache.getFreeFragmentConstant();\n                methodVO.fragmentConstantsIndex = cutOffReg.index * 4;\n                code += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n                    \"kil \" + targetReg + \".w\\n\" +\n                    \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n            }\n        }\n        else {\n            ambientInputRegister = registerCache.getFreeFragmentConstant();\n            methodVO.fragmentConstantsIndex = ambientInputRegister.index * 4;\n            code += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n        }\n        code = \"mov \" + targetReg + \", \" + sharedRegisters.uvVarying + \"\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    CurveBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (methodVO.textureGL) {\n            methodVO.textureGL.activate(methodVO.pass._render);\n            if (shader.alphaThreshold > 0)\n                shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n        }\n        else {\n            var index = methodVO.fragmentConstantsIndex;\n            var data = shader.fragmentConstantData;\n            data[index] = this._colorR;\n            data[index + 1] = this._colorG;\n            data[index + 2] = this._colorB;\n            data[index + 3] = this._alpha;\n        }\n    };\n    CurveBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (methodVO.textureGL)\n            methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Updates the ambient color data used by the render state.\n     */\n    CurveBasicMethod.prototype.updateColor = function () {\n        this._colorR = ((this._color >> 16) & 0xff) / 0xff * this._ambient;\n        this._colorG = ((this._color >> 8) & 0xff) / 0xff * this._ambient;\n        this._colorB = (this._color & 0xff) / 0xff * this._ambient;\n    };\n    return CurveBasicMethod;\n}(ShadingMethodBase_1.ShadingMethodBase));\nexports.CurveBasicMethod = CurveBasicMethod;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = CurveBasicMethod;\n\n},{\"../methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\",\"awayjs-core/lib/events/AssetEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar LightingMethodBase_1 = require(\"../methods/LightingMethodBase\");\n/**\n * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.\n */\nvar DiffuseBasicMethod = (function (_super) {\n    __extends(DiffuseBasicMethod, _super);\n    /**\n     * Creates a new DiffuseBasicMethod object.\n     */\n    function DiffuseBasicMethod() {\n        _super.call(this);\n        this._multiply = true;\n        this._ambientColorR = 1;\n        this._ambientColorG = 1;\n        this._ambientColorB = 1;\n        this._color = 0xffffff;\n        this._colorR = 1;\n        this._colorG = 1;\n        this._colorB = 1;\n    }\n    DiffuseBasicMethod.prototype.iIsUsed = function (shader) {\n        if (!shader.numLights)\n            return false;\n        return true;\n    };\n    Object.defineProperty(DiffuseBasicMethod.prototype, \"multiply\", {\n        /**\n         * Set internally if diffuse color component multiplies or replaces the ambient color\n         */\n        get: function () {\n            return this._multiply;\n        },\n        set: function (value) {\n            if (this._multiply == value)\n                return;\n            this._multiply = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DiffuseBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, null));\n            methodVO.textureGL = null;\n        }\n        if (shader.numLights > 0) {\n            shader.usesCommonData = true;\n            methodVO.needsNormals = true;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iInitConstants = function (shader, methodVO) {\n        if (shader.numLights > 0) {\n            this._ambientColor = methodVO.pass._surface.style.color;\n            this.updateAmbientColor();\n        }\n        else {\n            this._ambientColor = null;\n        }\n    };\n    Object.defineProperty(DiffuseBasicMethod.prototype, \"color\", {\n        /**\n         * The color of the diffuse reflection when not using a texture.\n         */\n        get: function () {\n            return this._color;\n        },\n        set: function (value) {\n            if (this._color == value)\n                return;\n            this._color = value;\n            this.updateColor();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseBasicMethod.prototype, \"texture\", {\n        /**\n         * The texture to use to define the diffuse reflection color per texel.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.dispose = function () {\n        this._texture = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.copyFrom = function (method) {\n        var diff = method;\n        this.texture = diff.texture;\n        this.multiply = diff.multiply;\n        this.color = diff.color;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._pTotalLightColorReg = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = \"\";\n        this._pIsFirstLight = true;\n        registerCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        code += \"dp3 \" + t + \".x, \" + lightDirReg + \", \" + sharedRegisters.normalFragment + \"\\n\" +\n            \"max \" + t + \".w, \" + t + \".x, \" + sharedRegisters.commons + \".y\\n\";\n        if (shader.usesLightFallOff)\n            code += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += \"mul \" + t + \", \" + t + \".w, \" + lightColReg + \"\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        code += \"tex \" + t + \", \" + sharedRegisters.normalFragment + \", \" + cubeMapReg + \" <cube,linear,miplinear>\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \".xyz, \" + weightRegister + \"\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var diffuseColor;\n        var cutOffReg;\n        // incorporate input from ambient\n        if (sharedRegisters.shadowTarget)\n            code += this.pApplyShadow(shader, methodVO, registerCache, sharedRegisters);\n        registerCache.addFragmentTempUsages(diffuseColor = registerCache.getFreeFragmentVectorTemp(), 1);\n        var ambientColorRegister = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = ambientColorRegister.index * 4;\n        if (this._texture) {\n            code += methodVO.textureGL._iGetFragmentCode(diffuseColor, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n        }\n        else {\n            var diffuseInputRegister = registerCache.getFreeFragmentConstant();\n            code += \"mov \" + diffuseColor + \", \" + diffuseInputRegister + \"\\n\";\n        }\n        code += \"sat \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n            \"mul \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\";\n        if (this._multiply) {\n            code += \"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + ambientColorRegister + \"\\n\" +\n                \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\";\n        }\n        else if (this._texture) {\n            code += \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + ambientColorRegister + \"\\n\" +\n                \"mul \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"sub \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"add \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; //add diffuse color and ambient color\n        }\n        else {\n            code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"sub \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\" +\n                \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; // multiply by target which could be texture or white\n        }\n        registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n        registerCache.removeFragmentTempUsage(diffuseColor);\n        return code;\n    };\n    /**\n     * Generate the code that applies the calculated shadow to the diffuse light\n     * @param methodVO The MethodVO object for which the compilation is currently happening.\n     * @param regCache The register cache the compiler is currently using for the register management.\n     */\n    DiffuseBasicMethod.prototype.pApplyShadow = function (shader, methodVO, regCache, sharedRegisters) {\n        return \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (this._texture) {\n            methodVO.textureGL.activate(methodVO.pass._render);\n        }\n        else {\n            var index = methodVO.fragmentConstantsIndex;\n            var data = shader.fragmentConstantData;\n            if (this._multiply) {\n                data[index + 4] = this._colorR * this._ambientColorR;\n                data[index + 5] = this._colorG * this._ambientColorG;\n                data[index + 6] = this._colorB * this._ambientColorB;\n            }\n            else {\n                data[index + 4] = this._colorR;\n                data[index + 5] = this._colorG;\n                data[index + 6] = this._colorB;\n            }\n            data[index + 7] = 1;\n        }\n    };\n    /**\n     * Updates the diffuse color data used by the render state.\n     */\n    DiffuseBasicMethod.prototype.updateColor = function () {\n        this._colorR = ((this._color >> 16) & 0xff) / 0xff;\n        this._colorG = ((this._color >> 8) & 0xff) / 0xff;\n        this._colorB = (this._color & 0xff) / 0xff;\n    };\n    /**\n     * Updates the ambient color data used by the render state.\n     */\n    DiffuseBasicMethod.prototype.updateAmbientColor = function () {\n        this._ambientColorR = ((this._ambientColor >> 16) & 0xff) / 0xff;\n        this._ambientColorG = ((this._ambientColor >> 8) & 0xff) / 0xff;\n        this._ambientColorB = (this._ambientColor & 0xff) / 0xff;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (this._texture)\n            methodVO.textureGL._setRenderState(renderable);\n        //TODO move this to Activate (ambientR/G/B currently calc'd in render state)\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = shader.ambientR * this._ambientColorR;\n        data[index + 1] = shader.ambientG * this._ambientColorG;\n        data[index + 2] = shader.ambientB * this._ambientColorB;\n        data[index + 3] = 1;\n    };\n    return DiffuseBasicMethod;\n}(LightingMethodBase_1.LightingMethodBase));\nexports.DiffuseBasicMethod = DiffuseBasicMethod;\n\n},{\"../methods/LightingMethodBase\":\"awayjs-methodmaterials/lib/methods/LightingMethodBase\",\"awayjs-core/lib/events/AssetEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/DiffuseCelMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseCompositeMethod_1 = require(\"../methods/DiffuseCompositeMethod\");\n/**\n * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.\n */\nvar DiffuseCelMethod = (function (_super) {\n    __extends(DiffuseCelMethod, _super);\n    /**\n     * Creates a new DiffuseCelMethod object.\n     * @param levels The amount of shadow gradations.\n     * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.\n     */\n    function DiffuseCelMethod(levels, baseMethod) {\n        var _this = this;\n        if (levels === void 0) { levels = 3; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this, null, baseMethod);\n        this._smoothness = .1;\n        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.clampDiffuse(shader, methodVO, targetReg, registerCache, sharedRegisters); };\n        this._levels = levels;\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseCelMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        data[index + 1] = 1;\n        data[index + 2] = 0;\n    };\n    Object.defineProperty(DiffuseCelMethod.prototype, \"levels\", {\n        /**\n         * The amount of shadow gradations.\n         */\n        get: function () {\n            return this._levels;\n        },\n        set: function (value /*uint*/) {\n            this._levels = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseCelMethod.prototype, \"smoothness\", {\n        /**\n         * The smoothness of the edge between 2 shading levels.\n         */\n        get: function () {\n            return this._smoothness;\n        },\n        set: function (value) {\n            this._smoothness = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseCelMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._dataReg = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        this._dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;\n        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCelMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var data = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        data[index] = this._levels;\n        data[index + 3] = this._smoothness;\n    };\n    /**\n     * Snaps the diffuse shading of the wrapped method to one of the levels.\n     * @param vo The MethodVO used to compile the current shader.\n     * @param t The register containing the diffuse strength in the \"w\" component.\n     * @param regCache The register cache used for the shader compilation.\n     * @param sharedRegisters The shared register data for this shader.\n     * @return The AGAL fragment code for the method.\n     */\n    DiffuseCelMethod.prototype.clampDiffuse = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".x\\n\" +\n            \"frc \" + targetReg + \".z, \" + targetReg + \".w\\n\" +\n            \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n            \"mov \" + targetReg + \".x, \" + this._dataReg + \".x\\n\" +\n            \"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + this._dataReg + \".y\\n\" +\n            \"rcp \" + targetReg + \".x,\" + targetReg + \".x\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n            // previous clamped strength\n            \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".x\\n\" +\n            // fract/epsilon (so 0 - epsilon will become 0 - 1)\n            \"div \" + targetReg + \".z, \" + targetReg + \".z, \" + this._dataReg + \".w\\n\" +\n            \"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n            // 1-z\n            \"sub \" + targetReg + \".z, \" + this._dataReg + \".y, \" + targetReg + \".z\\n\" +\n            \"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + targetReg + \".z\\n\" +\n            \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\" +\n            \"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n    };\n    return DiffuseCelMethod;\n}(DiffuseCompositeMethod_1.DiffuseCompositeMethod));\nexports.DiffuseCelMethod = DiffuseCelMethod;\n\n},{\"../methods/DiffuseCompositeMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar DiffuseBasicMethod_1 = require(\"../methods/DiffuseBasicMethod\");\n/**\n * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the\n * calculated diffuse reflection strength.\n */\nvar DiffuseCompositeMethod = (function (_super) {\n    __extends(DiffuseCompositeMethod, _super);\n    /**\n     * Creates a new <code>DiffuseCompositeMethod</code> object.\n     *\n     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.\n     * @param baseMethod The base diffuse method on which this method's shading is based.\n     */\n    function DiffuseCompositeMethod(modulateMethod, baseMethod) {\n        var _this = this;\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this);\n        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };\n        this.pBaseMethod = baseMethod || new DiffuseBasicMethod_1.DiffuseBasicMethod();\n        this.pBaseMethod._iModulateMethod = modulateMethod;\n        this.pBaseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n    }\n    Object.defineProperty(DiffuseCompositeMethod.prototype, \"baseMethod\", {\n        /**\n         * The base diffuse method on which this method's shading is based.\n         */\n        get: function () {\n            return this.pBaseMethod;\n        },\n        set: function (value) {\n            if (this.pBaseMethod == value)\n                return;\n            this.pBaseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this.pBaseMethod = value;\n            this.pBaseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iInitVO = function (shader, methodVO) {\n        this.pBaseMethod.iInitVO(shader, methodVO);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iInitConstants = function (shader, methodVO) {\n        this.pBaseMethod.iInitConstants(shader, methodVO);\n    };\n    DiffuseCompositeMethod.prototype.iAddOwner = function (owner) {\n        _super.prototype.iAddOwner.call(this, owner);\n        this.pBaseMethod.iAddOwner(owner);\n    };\n    DiffuseCompositeMethod.prototype.iRemoveOwner = function (owner) {\n        _super.prototype.iRemoveOwner.call(this, owner);\n        this.pBaseMethod.iRemoveOwner(owner);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.dispose = function () {\n        this.pBaseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n        this.pBaseMethod.dispose();\n    };\n    Object.defineProperty(DiffuseCompositeMethod.prototype, \"texture\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this.pBaseMethod.texture;\n        },\n        /**\n         * @inheritDoc\n         */\n        set: function (value) {\n            this.pBaseMethod.texture = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseCompositeMethod.prototype, \"color\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this.pBaseMethod.color;\n        },\n        /**\n         * @inheritDoc\n         */\n        set: function (value) {\n            this.pBaseMethod.color = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseCompositeMethod.prototype, \"multiply\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this.pBaseMethod.multiply;\n        },\n        /**\n         * @inheritDoc\n         */\n        set: function (value) {\n            this.pBaseMethod.multiply = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this.pBaseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = this.pBaseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n        this._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        var code = this.pBaseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n        this._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        this.pBaseMethod.iActivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        this.pBaseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iDeactivate = function (shader, methodVO, stage) {\n        this.pBaseMethod.iDeactivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this.pBaseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return this.pBaseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iReset = function () {\n        this.pBaseMethod.iReset();\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseCompositeMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this.pBaseMethod.iCleanCompilationData();\n    };\n    /**\n     * Called when the base method's shader code is invalidated.\n     */\n    DiffuseCompositeMethod.prototype.onShaderInvalidated = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    return DiffuseCompositeMethod;\n}(DiffuseBasicMethod_1.DiffuseBasicMethod));\nexports.DiffuseCompositeMethod = DiffuseCompositeMethod;\n\n},{\"../methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\",\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/DiffuseDepthMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseBasicMethod_1 = require(\"../methods/DiffuseBasicMethod\");\n/**\n * DiffuseDepthMethod provides a debug method to visualise depth maps\n */\nvar DiffuseDepthMethod = (function (_super) {\n    __extends(DiffuseDepthMethod, _super);\n    /**\n     * Creates a new DiffuseBasicMethod object.\n     */\n    function DiffuseDepthMethod() {\n        _super.call(this);\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseDepthMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index] = 1.0;\n        data[index + 1] = 1 / 255.0;\n        data[index + 2] = 1 / 65025.0;\n        data[index + 3] = 1 / 16581375.0;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseDepthMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var temp;\n        var decReg;\n        if (!this._texture)\n            throw new Error(\"DiffuseDepthMethod requires texture!\");\n        // incorporate input from ambient\n        if (shader.numLights > 0) {\n            if (sharedRegisters.shadowTarget)\n                code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + sharedRegisters.shadowTarget + \".w\\n\";\n            code += \"add \" + targetReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \".xyz\\n\" +\n                \"sat \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n            registerCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);\n        }\n        else {\n            temp = targetReg;\n        }\n        decReg = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        code += methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n            \"dp4 \" + temp + \".x, \" + temp + \", \" + decReg + \"\\n\" +\n            \"mov \" + temp + \".yz, \" + temp + \".xx\t\t\t\\n\" +\n            \"mov \" + temp + \".w, \" + decReg + \".x\\n\" +\n            \"sub \" + temp + \".xyz, \" + decReg + \".xxx, \" + temp + \".xyz\\n\";\n        if (shader.numLights == 0)\n            return code;\n        code += \"mul \" + targetReg + \".xyz, \" + temp + \".xyz, \" + targetReg + \".xyz\\n\" +\n            \"mov \" + targetReg + \".w, \" + temp + \".w\\n\";\n        if (shader.numLights > 0)\n            registerCache.removeFragmentTempUsage(temp);\n        return code;\n    };\n    return DiffuseDepthMethod;\n}(DiffuseBasicMethod_1.DiffuseBasicMethod));\nexports.DiffuseDepthMethod = DiffuseDepthMethod;\n\n},{\"../methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseGradientMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseBasicMethod_1 = require(\"../methods/DiffuseBasicMethod\");\n/**\n * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient\n * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude\n * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate\n * scattered light within the skin attributing to the final colour)\n */\nvar DiffuseGradientMethod = (function (_super) {\n    __extends(DiffuseGradientMethod, _super);\n    /**\n     * Creates a new DiffuseGradientMethod object.\n     * @param gradient A texture that contains the light colour based on the angle. This can be used to change\n     * the light colour due to subsurface scattering when the surface faces away from the light.\n     */\n    function DiffuseGradientMethod(gradient) {\n        _super.call(this);\n        this._gradient = gradient;\n        if (this._gradient)\n            this.iAddTexture(this._gradient);\n    }\n    DiffuseGradientMethod.prototype.iInitVO = function (shader, methodVO) {\n        _super.prototype.iInitVO.call(this, shader, methodVO);\n        methodVO.secondaryTextureGL = shader.getAbstraction(this._gradient);\n    };\n    Object.defineProperty(DiffuseGradientMethod.prototype, \"gradient\", {\n        /**\n         * A texture that contains the light colour based on the angle. This can be used to change the light colour\n         * due to subsurface scattering when the surface faces away from the light.\n         */\n        get: function () {\n            return this._gradient;\n        },\n        set: function (value) {\n            if (this._gradient == value)\n                return;\n            if (this._gradient)\n                this.iRemoveTexture(this._gradient);\n            this._gradient = value;\n            if (this._gradient)\n                this.iAddTexture(this._gradient);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n        this._pIsFirstLight = true;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight)\n            t = this._pTotalLightColorReg;\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        code += \"dp3 \" + t + \".w, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n            \"mul \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n            \"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += methodVO.secondaryTextureGL._iGetFragmentCode(t, registerCache, sharedRegisters, t) +\n            //\t\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + t + \".w\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \".xyz, \" + lightColReg + \".xyz\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.pApplyShadow = function (shader, methodVO, regCache, sharedRegisters) {\n        var t = regCache.getFreeFragmentVectorTemp();\n        return \"mov \" + t + \", \" + sharedRegisters.shadowTarget + \".wwww\\n\" +\n            methodVO.secondaryTextureGL._iGetFragmentCode(t, regCache, sharedRegisters, sharedRegisters.uvVarying) +\n            \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseGradientMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);\n        if (shader.numLights > 0)\n            methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    return DiffuseGradientMethod;\n}(DiffuseBasicMethod_1.DiffuseBasicMethod));\nexports.DiffuseGradientMethod = DiffuseGradientMethod;\n\n},{\"../methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseCompositeMethod_1 = require(\"../methods/DiffuseCompositeMethod\");\n/**\n * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse\n * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather\n * than only the diffuse lighting value.\n */\nvar DiffuseLightMapMethod = (function (_super) {\n    __extends(DiffuseLightMapMethod, _super);\n    /**\n     * Creates a new DiffuseLightMapMethod method.\n     *\n     * @param lightMap The texture containing the light map.\n     * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n     * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n     * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n     */\n    function DiffuseLightMapMethod(lightMap, blendMode, useSecondaryUV, baseMethod) {\n        if (blendMode === void 0) { blendMode = \"multiply\"; }\n        if (useSecondaryUV === void 0) { useSecondaryUV = false; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this, null, baseMethod);\n        this._useSecondaryUV = useSecondaryUV;\n        this._lightMap = lightMap;\n        this.blendMode = blendMode;\n        if (this._lightMap)\n            this.iAddTexture(this._lightMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseLightMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.secondaryTextureGL = shader.getAbstraction(this._lightMap);\n        if (this._useSecondaryUV)\n            shader.secondaryUVDependencies++;\n        else\n            shader.uvDependencies++;\n    };\n    Object.defineProperty(DiffuseLightMapMethod.prototype, \"blendMode\", {\n        /**\n         * The blend mode with which the light map should be applied to the lighting result.\n         *\n         * @see DiffuseLightMapMethod.ADD\n         * @see DiffuseLightMapMethod.MULTIPLY\n         */\n        get: function () {\n            return this._blendMode;\n        },\n        set: function (value) {\n            if (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)\n                throw new Error(\"Unknown blendmode!\");\n            if (this._blendMode == value)\n                return;\n            this._blendMode = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseLightMapMethod.prototype, \"lightMap\", {\n        /**\n         * The texture containing the light map data.\n         */\n        get: function () {\n            return this._lightMap;\n        },\n        set: function (value) {\n            if (this._lightMap == value)\n                return;\n            if (this._lightMap)\n                this.iRemoveTexture(this._lightMap);\n            this._lightMap = value;\n            if (this._lightMap)\n                this.iAddTexture(this._lightMap);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseLightMapMethod.prototype, \"useSecondaryUV\", {\n        /**\n         * Indicates whether the secondary UV set should be used to map the light map.\n         */\n        get: function () {\n            return this._useSecondaryUV;\n        },\n        set: function (value) {\n            if (this._useSecondaryUV == value)\n                return;\n            this._useSecondaryUV = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseLightMapMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n        switch (this._blendMode) {\n            case DiffuseLightMapMethod.MULTIPLY:\n                code += \"mul \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n                break;\n            case DiffuseLightMapMethod.ADD:\n                code += \"add \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n                break;\n        }\n        code += _super.prototype.iGetFragmentPostLightingCode.call(this, shader, methodVO, targetReg, registerCache, sharedRegisters);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseLightMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseLightMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);\n        methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * Indicates the light map should be multiplied with the calculated shading result.\n     * This can be used to add pre-calculated shadows or occlusion.\n     */\n    DiffuseLightMapMethod.MULTIPLY = \"multiply\";\n    /**\n     * Indicates the light map should be added into the calculated shading result.\n     * This can be used to add pre-calculated lighting or global illumination.\n     */\n    DiffuseLightMapMethod.ADD = \"add\";\n    return DiffuseLightMapMethod;\n}(DiffuseCompositeMethod_1.DiffuseCompositeMethod));\nexports.DiffuseLightMapMethod = DiffuseLightMapMethod;\n\n},{\"../methods/DiffuseCompositeMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseCompositeMethod_1 = require(\"../methods/DiffuseCompositeMethod\");\n/**\n * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of\n * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.\n * It can be used for candle wax, ice, skin, ...\n */\nvar DiffuseSubSurfaceMethod = (function (_super) {\n    __extends(DiffuseSubSurfaceMethod, _super);\n    /**\n     * Creates a new <code>DiffuseSubSurfaceMethod</code> object.\n     *\n     * @param depthMapSize The size of the depth map used.\n     * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n     * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n     */\n    function DiffuseSubSurfaceMethod(depthMapSize, depthMapOffset, baseMethod) {\n        var _this = this;\n        if (depthMapSize === void 0) { depthMapSize = 512; }\n        if (depthMapOffset === void 0) { depthMapOffset = 15; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this, null, baseMethod);\n        this._translucency = 1;\n        this._scatterColor = 0xffffff;\n        this._scatterR = 1.0;\n        this._scatterG = 1.0;\n        this._scatterB = 1.0;\n        this.pBaseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.scatterLight(shader, methodVO, targetReg, registerCache, sharedRegisters); };\n        //this._passes = new Array<MaterialPassGLBase>();\n        //this._depthPass = new SingleObjectDepthPass();\n        //this._depthPass.textureSize = depthMapSize;\n        //this._depthPass.polyOffset = depthMapOffset;\n        //this._passes.push(this._depthPass);\n        this._scattering = 0.2;\n        this._translucency = 1;\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        var data = shader.vertexConstantData;\n        var index = methodVO.secondaryVertexConstantsIndex;\n        data[index] = .5;\n        data[index + 1] = -.5;\n        data[index + 2] = 0;\n        data[index + 3] = 1;\n        data = shader.fragmentConstantData;\n        index = methodVO.secondaryFragmentConstantsIndex;\n        data[index + 3] = 1.0;\n        data[index + 4] = 1.0;\n        data[index + 5] = 1 / 255;\n        data[index + 6] = 1 / 65025;\n        data[index + 7] = 1 / 16581375;\n        data[index + 10] = .5;\n        data[index + 11] = -.1;\n    };\n    DiffuseSubSurfaceMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._lightProjVarying = null;\n        this._propReg = null;\n        this._lightColorReg = null;\n        this._colorReg = null;\n        this._decReg = null;\n        this._targetReg = null;\n    };\n    Object.defineProperty(DiffuseSubSurfaceMethod.prototype, \"scattering\", {\n        /**\n         * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low\n         * values for skin.\n         */\n        get: function () {\n            return this._scattering;\n        },\n        set: function (value) {\n            this._scattering = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseSubSurfaceMethod.prototype, \"translucency\", {\n        /**\n         * The translucency of the object.\n         */\n        get: function () {\n            return this._translucency;\n        },\n        set: function (value) {\n            this._translucency = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DiffuseSubSurfaceMethod.prototype, \"scatterColor\", {\n        /**\n         * The colour of the \"insides\" of the object, ie: the colour the light becomes after leaving the object.\n         */\n        get: function () {\n            return this._scatterColor;\n        },\n        set: function (scatterColor /*uint*/) {\n            this._scatterColor = scatterColor;\n            this._scatterR = ((scatterColor >> 16) & 0xff) / 0xff;\n            this._scatterG = ((scatterColor >> 8) & 0xff) / 0xff;\n            this._scatterB = (scatterColor & 0xff) / 0xff;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = _super.prototype.iGetVertexCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n        var lightProjection;\n        var toTexRegister;\n        var temp = registerCache.getFreeVertexVectorTemp();\n        toTexRegister = registerCache.getFreeVertexConstant();\n        methodVO.secondaryVertexConstantsIndex = toTexRegister.index * 4;\n        this._lightProjVarying = registerCache.getFreeVarying();\n        lightProjection = registerCache.getFreeVertexConstant();\n        registerCache.getFreeVertexConstant();\n        registerCache.getFreeVertexConstant();\n        registerCache.getFreeVertexConstant();\n        code += \"m44 \" + temp + \", vt0, \" + lightProjection + \"\\n\" +\n            \"div \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xy\\n\" +\n            \"add \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xx\\n\" +\n            \"mov \" + this._lightProjVarying + \".xyz, \" + temp + \".xyz\\n\" +\n            \"mov \" + this._lightProjVarying + \".w, va0.w\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        this._colorReg = registerCache.getFreeFragmentConstant();\n        this._decReg = registerCache.getFreeFragmentConstant();\n        this._propReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._colorReg.index * 4;\n        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        this._pIsFirstLight = true;\n        this._lightColorReg = lightColReg;\n        return _super.prototype.iGetFragmentCodePerLight.call(this, shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = _super.prototype.iGetFragmentPostLightingCode.call(this, shader, methodVO, targetReg, registerCache, sharedRegisters);\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code += \"mul \" + temp + \".xyz, \" + this._lightColorReg + \".xyz, \" + this._targetReg + \".w\\n\" +\n            \"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + this._colorReg + \".xyz\\n\" +\n            \"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n        if (this._targetReg != sharedRegisters.viewDirFragment)\n            registerCache.removeFragmentTempUsage(targetReg);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._scatterR;\n        data[index + 1] = this._scatterG;\n        data[index + 2] = this._scatterB;\n        data[index + 8] = this._scattering;\n        data[index + 9] = this._translucency;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseSubSurfaceMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.secondaryTextureGL = shader.getAbstraction(this._depthPass._iGetDepthMap(renderable));\n        methodVO.secondaryTextureGL._setRenderState(renderable);\n        this._depthPass._iGetProjection(renderable).copyRawDataTo(shader.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);\n    };\n    /**\n     * Generates the code for this method\n     */\n    DiffuseSubSurfaceMethod.prototype.scatterLight = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        // only scatter first light\n        if (!this._pIsFirstLight)\n            return \"\";\n        this._pIsFirstLight = false;\n        var code = \"\";\n        if (sharedRegisters.viewDirFragment)\n            this._targetReg = sharedRegisters.viewDirFragment;\n        else\n            registerCache.addFragmentTempUsages(this._targetReg = registerCache.getFreeFragmentVectorTemp(), 1);\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._lightProjVarying) +\n            // reencode RGBA\n            \"dp4 \" + targetReg + \".z, \" + temp + \", \" + this._decReg + \"\\n\";\n        // currentDistanceToLight - closestDistanceToLight\n        code += \"sub \" + targetReg + \".z, \" + this._lightProjVarying + \".z, \" + targetReg + \".z\\n\" +\n            \"sub \" + targetReg + \".z, \" + this._propReg + \".x, \" + targetReg + \".z\\n\" +\n            \"mul \" + targetReg + \".z, \" + this._propReg + \".y, \" + targetReg + \".z\\n\" +\n            \"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n            // targetReg.x contains dot(lightDir, normal)\n            // modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)\n            \"neg \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n            \"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n            \"add \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n            \"mul \" + this._targetReg + \".w, \" + targetReg + \".z, \" + targetReg + \".y\\n\" +\n            // blend diffuse: d' = (1-s)*d + s*1\n            \"sub \" + targetReg + \".y, \" + this._colorReg + \".w, \" + this._targetReg + \".w\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n        return code;\n    };\n    return DiffuseSubSurfaceMethod;\n}(DiffuseCompositeMethod_1.DiffuseCompositeMethod));\nexports.DiffuseSubSurfaceMethod = DiffuseSubSurfaceMethod;\n\n},{\"../methods/DiffuseCompositeMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/DiffuseWrapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar DiffuseBasicMethod_1 = require(\"../methods/DiffuseBasicMethod\");\n/**\n * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be \"wrapped around\" the normally dark area, to some extent.\n * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.\n */\nvar DiffuseWrapMethod = (function (_super) {\n    __extends(DiffuseWrapMethod, _super);\n    /**\n     * Creates a new DiffuseWrapMethod object.\n     * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap\n     */\n    function DiffuseWrapMethod(wrapFactor) {\n        if (wrapFactor === void 0) { wrapFactor = .5; }\n        _super.call(this);\n        this.wrapFactor = wrapFactor;\n    }\n    /**\n     * @inheritDoc\n     */\n    DiffuseWrapMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._wrapDataRegister = null;\n    };\n    Object.defineProperty(DiffuseWrapMethod.prototype, \"wrapFactor\", {\n        /**\n         * A factor to indicate the amount by which the light is allowed to wrap.\n         */\n        get: function () {\n            return this._wrapFactor;\n        },\n        set: function (value) {\n            this._wrapFactor = value;\n            this._wrapFactor = 1 / (value + 1);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    DiffuseWrapMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n        this._pIsFirstLight = true;\n        this._wrapDataRegister = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index * 4;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseWrapMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        code += \"dp3 \" + t + \".x, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n            \"add \" + t + \".y, \" + t + \".x, \" + this._wrapDataRegister + \".x\\n\" +\n            \"mul \" + t + \".y, \" + t + \".y, \" + this._wrapDataRegister + \".y\\n\" +\n            \"sat \" + t + \".w, \" + t + \".y\\n\" +\n            \"mul \" + t + \".xz, \" + t + \".w, \" + lightDirReg + \".wz\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, lightDirReg, registerCache, sharedRegisters);\n        code += \"mul \" + t + \", \" + t + \".x, \" + lightColReg + \"\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    DiffuseWrapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._wrapFactor;\n        data[index + 1] = 1 / (this._wrapFactor + 1);\n    };\n    return DiffuseWrapMethod;\n}(DiffuseBasicMethod_1.DiffuseBasicMethod));\nexports.DiffuseWrapMethod = DiffuseWrapMethod;\n\n},{\"../methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used\n * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water\n * etc).\n */\nvar EffectAlphaMaskMethod = (function (_super) {\n    __extends(EffectAlphaMaskMethod, _super);\n    /**\n     * Creates a new EffectAlphaMaskMethod object.\n     *\n     * @param texture The texture to use as the alpha mask.\n     * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.\n     */\n    function EffectAlphaMaskMethod(texture, useSecondaryUV) {\n        if (useSecondaryUV === void 0) { useSecondaryUV = false; }\n        _super.call(this);\n        this._texture = texture;\n        this._useSecondaryUV = useSecondaryUV;\n        if (this._texture)\n            this.iAddTexture(this._texture);\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectAlphaMaskMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.textureGL = shader.getAbstraction(this._texture);\n        if (this._useSecondaryUV)\n            shader.secondaryUVDependencies++;\n        else\n            shader.uvDependencies++;\n    };\n    Object.defineProperty(EffectAlphaMaskMethod.prototype, \"useSecondaryUV\", {\n        /**\n         * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for\n         * instance to tile the main texture and normal map while providing untiled alpha, for example to define the\n         * transparency over a tiled water surface.\n         */\n        get: function () {\n            return this._useSecondaryUV;\n        },\n        set: function (value) {\n            if (this._useSecondaryUV == value)\n                return;\n            this._useSecondaryUV = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectAlphaMaskMethod.prototype, \"texture\", {\n        /**\n         * The texture to use as the alpha mask.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectAlphaMaskMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +\n            \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \".x\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectAlphaMaskMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    EffectAlphaMaskMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n    };\n    return EffectAlphaMaskMethod;\n}(EffectMethodBase_1.EffectMethodBase));\nexports.EffectAlphaMaskMethod = EffectAlphaMaskMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.\n */\nvar EffectColorMatrixMethod = (function (_super) {\n    __extends(EffectColorMatrixMethod, _super);\n    /**\n     * Creates a new EffectColorTransformMethod.\n     *\n     * @param matrix An array of 20 items for 4 x 5 color transform.\n     */\n    function EffectColorMatrixMethod(matrix) {\n        _super.call(this);\n        if (matrix.length != 20)\n            throw new Error(\"Matrix length must be 20!\");\n        this._matrix = matrix;\n    }\n    Object.defineProperty(EffectColorMatrixMethod.prototype, \"colorMatrix\", {\n        /**\n         * The 4 x 5 matrix to transform the color of the material.\n         */\n        get: function () {\n            return this._matrix;\n        },\n        set: function (value) {\n            this._matrix = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectColorMatrixMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var colorMultReg = registerCache.getFreeFragmentConstant();\n        registerCache.getFreeFragmentConstant();\n        registerCache.getFreeFragmentConstant();\n        registerCache.getFreeFragmentConstant();\n        var colorOffsetReg = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = colorMultReg.index * 4;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code += \"m44 \" + temp + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" +\n            \"add \" + targetReg + \", \" + temp + \", \" + colorOffsetReg + \"\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectColorMatrixMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var matrix = this._matrix;\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        // r\n        data[index] = matrix[0];\n        data[index + 1] = matrix[1];\n        data[index + 2] = matrix[2];\n        data[index + 3] = matrix[3];\n        // g\n        data[index + 4] = matrix[5];\n        data[index + 5] = matrix[6];\n        data[index + 6] = matrix[7];\n        data[index + 7] = matrix[8];\n        // b\n        data[index + 8] = matrix[10];\n        data[index + 9] = matrix[11];\n        data[index + 10] = matrix[12];\n        data[index + 11] = matrix[13];\n        // a\n        data[index + 12] = matrix[15];\n        data[index + 13] = matrix[16];\n        data[index + 14] = matrix[17];\n        data[index + 15] = matrix[18];\n        // rgba offset\n        data[index + 16] = matrix[4];\n        data[index + 17] = matrix[9];\n        data[index + 18] = matrix[14];\n        data[index + 19] = matrix[19];\n    };\n    return EffectColorMatrixMethod;\n}(EffectMethodBase_1.EffectMethodBase));\nexports.EffectColorMatrixMethod = EffectColorMatrixMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a\n * ColorTransform object.\n */\nvar EffectColorTransformMethod = (function (_super) {\n    __extends(EffectColorTransformMethod, _super);\n    /**\n     * Creates a new EffectColorTransformMethod.\n     */\n    function EffectColorTransformMethod() {\n        _super.call(this);\n    }\n    Object.defineProperty(EffectColorTransformMethod.prototype, \"colorTransform\", {\n        /**\n         * The ColorTransform object to transform the colour of the material with.\n         */\n        get: function () {\n            return this._colorTransform;\n        },\n        set: function (value) {\n            this._colorTransform = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectColorTransformMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var colorMultReg = registerCache.getFreeFragmentConstant();\n        var colorOffsReg = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = colorMultReg.index * 4;\n        //TODO: AGAL <> GLSL\n        code += \"mul \" + targetReg + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" + \"add \" + targetReg + \", \" + targetReg + \", \" + colorOffsReg + \"\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectColorTransformMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var inv = 1 / 0xff;\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._colorTransform.redMultiplier;\n        data[index + 1] = this._colorTransform.greenMultiplier;\n        data[index + 2] = this._colorTransform.blueMultiplier;\n        data[index + 3] = this._colorTransform.alphaMultiplier;\n        data[index + 4] = this._colorTransform.redOffset * inv;\n        data[index + 5] = this._colorTransform.greenOffset * inv;\n        data[index + 6] = this._colorTransform.blueOffset * inv;\n        data[index + 7] = this._colorTransform.alphaOffset * inv;\n    };\n    return EffectColorTransformMethod;\n}(EffectMethodBase_1.EffectMethodBase));\nexports.EffectColorTransformMethod = EffectColorTransformMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectEnvMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.\n */\nvar EffectEnvMapMethod = (function (_super) {\n    __extends(EffectEnvMapMethod, _super);\n    /**\n     * Creates an EffectEnvMapMethod object.\n     * @param envMap The environment map containing the reflected scene.\n     * @param alpha The reflectivity of the surface.\n     */\n    function EffectEnvMapMethod(envMap, alpha) {\n        if (alpha === void 0) { alpha = 1; }\n        _super.call(this);\n        this._envMap = envMap;\n        this._alpha = alpha;\n        if (this._envMap)\n            this.iAddTexture(this._envMap);\n    }\n    Object.defineProperty(EffectEnvMapMethod.prototype, \"mask\", {\n        /**\n         * An optional texture to modulate the reflectivity of the surface.\n         */\n        get: function () {\n            return this._mask;\n        },\n        set: function (value) {\n            if (value == this._mask)\n                return;\n            if (this._mask)\n                this.iRemoveTexture(this._mask);\n            this._mask = value;\n            if (this._mask)\n                this.iAddTexture(this._mask);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        methodVO.needsView = true;\n        if (this._envMap)\n            methodVO.textureGL = shader.getAbstraction(this._envMap);\n        if (this._mask) {\n            methodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n            shader.uvDependencies++;\n        }\n    };\n    Object.defineProperty(EffectEnvMapMethod.prototype, \"envMap\", {\n        /**\n         * The cubic environment map containing the reflected scene.\n         */\n        get: function () {\n            return this._envMap;\n        },\n        set: function (value) {\n            if (this._envMap == value)\n                return;\n            if (this._envMap)\n                this.iRemoveTexture(this._envMap);\n            this._envMap = value;\n            if (this._envMap)\n                this.iAddTexture(this._envMap);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectEnvMapMethod.prototype.dispose = function () {\n    };\n    Object.defineProperty(EffectEnvMapMethod.prototype, \"alpha\", {\n        /**\n         * The reflectivity of the surface.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            this._alpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;\n        methodVO.textureGL.activate(methodVO.pass._render);\n        if (this._mask)\n            methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    EffectEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n        if (this._mask)\n            methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var dataRegister = registerCache.getFreeFragmentConstant();\n        var code = \"\";\n        methodVO.fragmentConstantsIndex = dataRegister.index * 4;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var temp2 = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp2, 1);\n        // r = I - 2(I.N)*N\n        code += \"dp3 \" + temp + \".w, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n            \"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".xyz, \" + sharedRegisters.normalFragment + \".xyz, \" + temp + \".w\\n\" +\n            \"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n            \"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +\n            \"kil \" + temp2 + \".w\\n\" +\n            \"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n        if (this._mask) {\n            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n                \"mul \" + temp + \", \" + temp2 + \", \" + temp + \"\\n\";\n        }\n        code += \"mul \" + temp + \", \" + temp + \", \" + dataRegister + \".x\\n\" +\n            \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        registerCache.removeFragmentTempUsage(temp2);\n        return code;\n    };\n    return EffectEnvMapMethod;\n}(EffectMethodBase_1.EffectMethodBase));\nexports.EffectEnvMapMethod = EffectEnvMapMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectFogMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectFogMethod provides a method to add distance-based fog to a material.\n */\nvar EffectFogMethod = (function (_super) {\n    __extends(EffectFogMethod, _super);\n    /**\n     * Creates a new EffectFogMethod object.\n     * @param minDistance The distance from which the fog starts appearing.\n     * @param maxDistance The distance at which the fog is densest.\n     * @param fogColor The colour of the fog.\n     */\n    function EffectFogMethod(minDistance, maxDistance, fogColor) {\n        if (fogColor === void 0) { fogColor = 0x808080; }\n        _super.call(this);\n        this._minDistance = 0;\n        this._maxDistance = 1000;\n        this.minDistance = minDistance;\n        this.maxDistance = maxDistance;\n        this.fogColor = fogColor;\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectFogMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsProjection = true;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectFogMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index + 3] = 1;\n        data[index + 6] = 0;\n        data[index + 7] = 0;\n    };\n    Object.defineProperty(EffectFogMethod.prototype, \"minDistance\", {\n        /**\n         * The distance from which the fog starts appearing.\n         */\n        get: function () {\n            return this._minDistance;\n        },\n        set: function (value) {\n            this._minDistance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFogMethod.prototype, \"maxDistance\", {\n        /**\n         * The distance at which the fog is densest.\n         */\n        get: function () {\n            return this._maxDistance;\n        },\n        set: function (value) {\n            this._maxDistance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFogMethod.prototype, \"fogColor\", {\n        /**\n         * The colour of the fog.\n         */\n        get: function () {\n            return this._fogColor;\n        },\n        set: function (value /*uint*/) {\n            this._fogColor = value;\n            this._fogR = ((value >> 16) & 0xff) / 0xff;\n            this._fogG = ((value >> 8) & 0xff) / 0xff;\n            this._fogB = (value & 0xff) / 0xff;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectFogMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index] = this._fogR;\n        data[index + 1] = this._fogG;\n        data[index + 2] = this._fogB;\n        data[index + 4] = this._minDistance;\n        data[index + 5] = 1 / (this._maxDistance - this._minDistance);\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectFogMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var fogColor = registerCache.getFreeFragmentConstant();\n        var fogData = registerCache.getFreeFragmentConstant();\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var temp2 = registerCache.getFreeFragmentVectorTemp();\n        var code = \"\";\n        methodVO.fragmentConstantsIndex = fogColor.index * 4;\n        code += \"sub \" + temp2 + \".w, \" + sharedRegisters.projectionFragment + \".z, \" + fogData + \".x\\n\" +\n            \"mul \" + temp2 + \".w, \" + temp2 + \".w, \" + fogData + \".y\\n\" +\n            \"sat \" + temp2 + \".w, \" + temp2 + \".w\\n\" +\n            \"sub \" + temp + \", \" + fogColor + \", \" + targetReg + \"\\n\" +\n            \"mul \" + temp + \", \" + temp + \", \" + temp2 + \".w\\n\" +\n            \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\"; // fogRatio*(fogColor- col) + col\n        registerCache.removeFragmentTempUsage(temp);\n        return code;\n    };\n    return EffectFogMethod;\n}(EffectMethodBase_1.EffectMethodBase));\nexports.EffectFogMethod = EffectFogMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets\n * stronger as the viewing angle becomes more grazing.\n */\nvar EffectFresnelEnvMapMethod = (function (_super) {\n    __extends(EffectFresnelEnvMapMethod, _super);\n    /**\n     * Creates a new <code>EffectFresnelEnvMapMethod</code> object.\n     *\n     * @param envMap The environment map containing the reflected scene.\n     * @param alpha The reflectivity of the material.\n     */\n    function EffectFresnelEnvMapMethod(envMap, alpha) {\n        if (alpha === void 0) { alpha = 1; }\n        _super.call(this);\n        this._fresnelPower = 5;\n        this._normalReflectance = 0;\n        this._envMap = envMap;\n        this._alpha = alpha;\n        if (this._envMap)\n            this.iAddTexture(this._envMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectFresnelEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        methodVO.needsView = true;\n        methodVO.textureGL = shader.getAbstraction(this._envMap);\n        if (this._mask != null) {\n            methodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n            shader.uvDependencies++;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectFresnelEnvMapMethod.prototype.iInitConstants = function (shader, methodVO) {\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n    };\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"mask\", {\n        /**\n         * An optional texture to modulate the reflectivity of the surface.\n         */\n        get: function () {\n            return this._mask;\n        },\n        set: function (value) {\n            if (this._mask == value)\n                return;\n            if (this._mask)\n                this.iRemoveTexture(this._mask);\n            this._mask = value;\n            if (this._mask)\n                this.iAddTexture(this._mask);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"fresnelPower\", {\n        /**\n         * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n         */\n        get: function () {\n            return this._fresnelPower;\n        },\n        set: function (value) {\n            this._fresnelPower = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"envMap\", {\n        /**\n         * The cubic environment map containing the reflected scene.\n         */\n        get: function () {\n            return this._envMap;\n        },\n        set: function (value) {\n            if (this._envMap == value)\n                return;\n            if (this._envMap)\n                this.iRemoveTexture(this._envMap);\n            this._envMap = value;\n            if (this._envMap)\n                this.iAddTexture(this._envMap);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"alpha\", {\n        /**\n         * The reflectivity of the surface.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            this._alpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, \"normalReflectance\", {\n        /**\n         * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n         */\n        get: function () {\n            return this._normalReflectance;\n        },\n        set: function (value) {\n            this._normalReflectance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectFresnelEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index] = this._alpha;\n        data[index + 1] = this._normalReflectance;\n        data[index + 2] = this._fresnelPower;\n        methodVO.textureGL.activate(methodVO.pass._render);\n        if (this._mask)\n            methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    EffectFresnelEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n        if (this._mask)\n            methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectFresnelEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var dataRegister = registerCache.getFreeFragmentConstant();\n        var code = \"\";\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        var normalReg = sharedRegisters.normalFragment;\n        methodVO.fragmentConstantsIndex = dataRegister.index * 4;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var temp2 = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp2, 1);\n        // r = V - 2(V.N)*N\n        code += \"dp3 \" + temp + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n            \"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".xyz, \" + normalReg + \".xyz, \" + temp + \".w\\n\" +\n            \"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + viewDirReg + \".xyz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n            \"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +\n            \"kil \" + temp2 + \".w\\n\" +\n            \"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n        // calculate fresnel term\n        code += \"dp3 \" + viewDirReg + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n            \"sub \" + viewDirReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +\n            \"pow \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + dataRegister + \".z\\n\" +\n            \"sub \" + normalReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +\n            \"mul \" + normalReg + \".w, \" + dataRegister + \".y, \" + normalReg + \".w\\n\" +\n            \"add \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + normalReg + \".w\\n\" +\n            // total alpha\n            \"mul \" + viewDirReg + \".w, \" + dataRegister + \".x, \" + viewDirReg + \".w\\n\";\n        if (this._mask) {\n            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n                \"mul \" + viewDirReg + \".w, \" + temp2 + \".x, \" + viewDirReg + \".w\\n\";\n        }\n        // blend\n        code += \"mul \" + temp + \", \" + temp + \", \" + viewDirReg + \".w\\n\" +\n            \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        registerCache.removeFragmentTempUsage(temp2);\n        return code;\n    };\n    return EffectFresnelEnvMapMethod;\n}(EffectMethodBase_1.EffectMethodBase));\nexports.EffectFresnelEnvMapMethod = EffectFresnelEnvMapMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectLightMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.\n * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather\n * than the whole pixel colour.\n */\nvar EffectLightMapMethod = (function (_super) {\n    __extends(EffectLightMapMethod, _super);\n    /**\n     * Creates a new EffectLightMapMethod object.\n     *\n     * @param lightMap The texture containing the light map.\n     * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n     * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n     */\n    function EffectLightMapMethod(lightMap, blendMode, useSecondaryUV) {\n        if (blendMode === void 0) { blendMode = \"multiply\"; }\n        if (useSecondaryUV === void 0) { useSecondaryUV = false; }\n        _super.call(this);\n        if (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)\n            throw new Error(\"Unknown blendmode!\");\n        this._lightMap = lightMap;\n        this._blendMode = blendMode;\n        this._useSecondaryUV = useSecondaryUV;\n        if (this._lightMap)\n            this.iAddTexture(this._lightMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectLightMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.textureGL = shader.getAbstraction(this._lightMap);\n        if (this._useSecondaryUV)\n            shader.secondaryUVDependencies++;\n        else\n            shader.uvDependencies++;\n    };\n    Object.defineProperty(EffectLightMapMethod.prototype, \"blendMode\", {\n        /**\n         * The blend mode with which the light map should be applied to the lighting result.\n         *\n         * @see EffectLightMapMethod.ADD\n         * @see EffectLightMapMethod.MULTIPLY\n         */\n        get: function () {\n            return this._blendMode;\n        },\n        set: function (value) {\n            if (this._blendMode == value)\n                return;\n            if (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)\n                throw new Error(\"Unknown blendmode!\");\n            this._blendMode = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectLightMapMethod.prototype, \"lightMap\", {\n        /**\n         * The lightMap containing the light map.\n         */\n        get: function () {\n            return this._lightMap;\n        },\n        set: function (value) {\n            if (this._lightMap == value)\n                return;\n            if (this._lightMap)\n                this.iRemoveTexture(this._lightMap);\n            this._lightMap = value;\n            if (this._lightMap)\n                this.iAddTexture(this._lightMap);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectLightMapMethod.prototype, \"useSecondaryUV\", {\n        /**\n         * Indicates whether the secondary UV set should be used to map the light map.\n         */\n        get: function () {\n            return this._useSecondaryUV;\n        },\n        set: function (value) {\n            if (this._useSecondaryUV == value)\n                return;\n            this._useSecondaryUV = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectLightMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        code = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n        switch (this._blendMode) {\n            case EffectLightMapMethod.MULTIPLY:\n                code += \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n                break;\n            case EffectLightMapMethod.ADD:\n                code += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n                break;\n        }\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectLightMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    EffectLightMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Indicates the light map should be multiplied with the calculated shading result.\n     */\n    EffectLightMapMethod.MULTIPLY = \"multiply\";\n    /**\n     * Indicates the light map should be added into the calculated shading result.\n     */\n    EffectLightMapMethod.ADD = \"add\";\n    return EffectLightMapMethod;\n}(EffectMethodBase_1.EffectMethodBase));\nexports.EffectLightMapMethod = EffectLightMapMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AbstractMethodError_1 = require(\"awayjs-core/lib/errors/AbstractMethodError\");\nvar ShadingMethodBase_1 = require(\"../methods/ShadingMethodBase\");\n/**\n * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,\n * and are in essence post-process effects on the materials.\n */\nvar EffectMethodBase = (function (_super) {\n    __extends(EffectMethodBase, _super);\n    function EffectMethodBase() {\n        _super.call(this);\n    }\n    Object.defineProperty(EffectMethodBase.prototype, \"assetType\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return EffectMethodBase.assetType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param regCache The register cache used during the compilation.\n     * @param targetReg The register that will be containing the method's output.\n     * @private\n     */\n    EffectMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        throw new AbstractMethodError_1.AbstractMethodError();\n    };\n    EffectMethodBase.assetType = \"[asset EffectMethod]\";\n    return EffectMethodBase;\n}(ShadingMethodBase_1.ShadingMethodBase));\nexports.EffectMethodBase = EffectMethodBase;\n\n},{\"../methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\",\"awayjs-core/lib/errors/AbstractMethodError\":undefined}],\"awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.\n */\nvar EffectRefractionEnvMapMethod = (function (_super) {\n    __extends(EffectRefractionEnvMapMethod, _super);\n    /**\n     * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015\n     *\n     * @param envMap The environment map containing the refracted scene.\n     * @param refractionIndex The refractive index of the material.\n     * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n     * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n     * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n     */\n    function EffectRefractionEnvMapMethod(envMap, refractionIndex, dispersionR, dispersionG, dispersionB) {\n        if (refractionIndex === void 0) { refractionIndex = .1; }\n        if (dispersionR === void 0) { dispersionR = 0; }\n        if (dispersionG === void 0) { dispersionG = 0; }\n        if (dispersionB === void 0) { dispersionB = 0; }\n        _super.call(this);\n        this._dispersionR = 0;\n        this._dispersionG = 0;\n        this._dispersionB = 0;\n        this._alpha = 1;\n        this._envMap = envMap;\n        this._dispersionR = dispersionR;\n        this._dispersionG = dispersionG;\n        this._dispersionB = dispersionB;\n        this._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n        this._refractionIndex = refractionIndex;\n        if (this._envMap)\n            this.iAddTexture(this._envMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectRefractionEnvMapMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index + 4] = 1;\n        data[index + 5] = 0;\n        data[index + 7] = 1;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectRefractionEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        methodVO.needsView = true;\n        methodVO.textureGL = shader.getAbstraction(this._envMap);\n    };\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"envMap\", {\n        /**\n         * The cube environment map to use for the refraction.\n         */\n        get: function () {\n            return this._envMap;\n        },\n        set: function (value) {\n            if (this._envMap == value)\n                return;\n            if (this._envMap)\n                this.iRemoveTexture(this._envMap);\n            this._envMap = value;\n            if (this._envMap)\n                this.iAddTexture(this._envMap);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"refractionIndex\", {\n        /**\n         * The refractive index of the material.\n         */\n        get: function () {\n            return this._refractionIndex;\n        },\n        set: function (value) {\n            this._refractionIndex = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"dispersionR\", {\n        /**\n         * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n         */\n        get: function () {\n            return this._dispersionR;\n        },\n        set: function (value) {\n            this._dispersionR = value;\n            var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n            if (this._useDispersion != useDispersion) {\n                this.iInvalidateShaderProgram();\n                this._useDispersion = useDispersion;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"dispersionG\", {\n        /**\n         * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n         */\n        get: function () {\n            return this._dispersionG;\n        },\n        set: function (value) {\n            this._dispersionG = value;\n            var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n            if (this._useDispersion != useDispersion) {\n                this.iInvalidateShaderProgram();\n                this._useDispersion = useDispersion;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"dispersionB\", {\n        /**\n         * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n         */\n        get: function () {\n            return this._dispersionB;\n        },\n        set: function (value) {\n            this._dispersionB = value;\n            var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n            if (this._useDispersion != useDispersion) {\n                this.iInvalidateShaderProgram();\n                this._useDispersion = useDispersion;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, \"alpha\", {\n        /**\n         * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual\n         * material. A value of 1 will make it appear fully transparent.\n         */\n        get: function () {\n            return this._alpha;\n        },\n        set: function (value) {\n            this._alpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectRefractionEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._dispersionR + this._refractionIndex;\n        if (this._useDispersion) {\n            data[index + 1] = this._dispersionG + this._refractionIndex;\n            data[index + 2] = this._dispersionB + this._refractionIndex;\n        }\n        data[index + 3] = this._alpha;\n        methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    EffectRefractionEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectRefractionEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        // todo: data2.x could use common reg, so only 1 reg is used\n        var data = registerCache.getFreeFragmentConstant();\n        var data2 = registerCache.getFreeFragmentConstant();\n        var code = \"\";\n        var refractionDir;\n        var refractionColor;\n        var temp;\n        methodVO.fragmentConstantsIndex = data.index * 4;\n        refractionDir = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(refractionDir, 1);\n        refractionColor = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(refractionColor, 1);\n        temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        var normalReg = sharedRegisters.normalFragment;\n        code += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n        code += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n            \"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n            \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n            \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n            \"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".x, \" + data + \".x, \" + temp + \".x\\n\" +\n            \"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n            \"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n            \"mul \" + refractionDir + \", \" + data + \".x, \" + viewDirReg + \"\\n\" +\n            \"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n            \"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(refractionColor, registerCache, sharedRegisters, refractionDir) +\n            \"sub \" + refractionColor + \".w, \" + refractionColor + \".w, fc0.x\t\\n\" +\n            \"kil \" + refractionColor + \".w\\n\";\n        if (this._useDispersion) {\n            // GREEN\n            code += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n                \"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n                \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n                \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n                \"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".x, \" + data + \".y, \" + temp + \".x\\n\" +\n                \"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n                \"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n                \"mul \" + refractionDir + \", \" + data + \".y, \" + viewDirReg + \"\\n\" +\n                \"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n                \"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n                methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n                \"mov \" + refractionColor + \".y, \" + temp + \".y\\n\";\n            // BLUE\n            code += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n                \"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n                \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n                \"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n                \"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n                \"mul \" + temp + \".x, \" + data + \".z, \" + temp + \".x\\n\" +\n                \"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n                \"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n                \"mul \" + refractionDir + \", \" + data + \".z, \" + viewDirReg + \"\\n\" +\n                \"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n                \"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n                methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n                \"mov \" + refractionColor + \".z, \" + temp + \".z\\n\";\n        }\n        code += \"sub \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + targetReg + \".xyz\\n\" +\n            \"mul \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + data + \".w\\n\" +\n            \"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + refractionColor + \".xyz\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        registerCache.removeFragmentTempUsage(refractionDir);\n        registerCache.removeFragmentTempUsage(refractionColor);\n        // restore\n        code += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n        return code;\n    };\n    return EffectRefractionEnvMapMethod;\n}(EffectMethodBase_1.EffectMethodBase));\nexports.EffectRefractionEnvMapMethod = EffectRefractionEnvMapMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/EffectRimLightMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar EffectMethodBase_1 = require(\"../methods/EffectMethodBase\");\n/**\n * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.\n */\nvar EffectRimLightMethod = (function (_super) {\n    __extends(EffectRimLightMethod, _super);\n    /**\n     * Creates a new <code>EffectRimLightMethod</code> object.\n     *\n     * @param color The colour of the rim light.\n     * @param strength The strength of the rim light.\n     * @param power The power of the rim light. Higher values will result in a higher edge fall-off.\n     * @param blend The blend mode with which to add the light to the object.\n     */\n    function EffectRimLightMethod(color, strength, power, blend) {\n        if (color === void 0) { color = 0xffffff; }\n        if (strength === void 0) { strength = .4; }\n        if (power === void 0) { power = 2; }\n        if (blend === void 0) { blend = \"mix\"; }\n        _super.call(this);\n        this._blendMode = blend;\n        this._strength = strength;\n        this._power = power;\n        this.color = color;\n    }\n    /**\n     * @inheritDoc\n     */\n    EffectRimLightMethod.prototype.iInitConstants = function (shader, methodVO) {\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectRimLightMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = true;\n        methodVO.needsView = true;\n    };\n    Object.defineProperty(EffectRimLightMethod.prototype, \"blendMode\", {\n        /**\n         * The blend mode with which to add the light to the object.\n         *\n         * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.\n         * EffectRimLightMethod.ADD adds the rim light with the material's colour.\n         * EffectRimLightMethod.MIX provides normal alpha blending.\n         */\n        get: function () {\n            return this._blendMode;\n        },\n        set: function (value) {\n            if (this._blendMode == value)\n                return;\n            this._blendMode = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRimLightMethod.prototype, \"color\", {\n        /**\n         * The color of the rim light.\n         */\n        get: function () {\n            return this._color;\n        },\n        set: function (value /*uint*/) {\n            this._color = value;\n            this._colorR = ((value >> 16) & 0xff) / 0xff;\n            this._colorG = ((value >> 8) & 0xff) / 0xff;\n            this._colorB = (value & 0xff) / 0xff;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRimLightMethod.prototype, \"strength\", {\n        /**\n         * The strength of the rim light.\n         */\n        get: function () {\n            return this._strength;\n        },\n        set: function (value) {\n            this._strength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(EffectRimLightMethod.prototype, \"power\", {\n        /**\n         * The power of the rim light. Higher values will result in a higher edge fall-off.\n         */\n        get: function () {\n            return this._power;\n        },\n        set: function (value) {\n            this._power = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    EffectRimLightMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._colorR;\n        data[index + 1] = this._colorG;\n        data[index + 2] = this._colorB;\n        data[index + 4] = this._strength;\n        data[index + 5] = this._power;\n    };\n    /**\n     * @inheritDoc\n     */\n    EffectRimLightMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var dataRegister = registerCache.getFreeFragmentConstant();\n        var dataRegister2 = registerCache.getFreeFragmentConstant();\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        var code = \"\";\n        methodVO.fragmentConstantsIndex = dataRegister.index * 4;\n        code += \"dp3 \" + temp + \".x, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n            \"sat \" + temp + \".x, \" + temp + \".x\\n\" +\n            \"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n            \"pow \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".y\\n\" +\n            \"mul \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".x\\n\" +\n            \"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n            \"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".x\\n\" +\n            \"sub \" + temp + \".w, \" + dataRegister + \".w, \" + temp + \".x\\n\";\n        if (this._blendMode == EffectRimLightMethod.ADD) {\n            code += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n                \"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n        }\n        else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {\n            code += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n                \"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n        }\n        else {\n            code += \"sub \" + temp + \".xyz, \" + dataRegister + \".xyz, \" + targetReg + \".xyz\\n\" +\n                \"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n                \"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n        }\n        return code;\n    };\n    EffectRimLightMethod.ADD = \"add\";\n    EffectRimLightMethod.MULTIPLY = \"multiply\";\n    EffectRimLightMethod.MIX = \"mix\";\n    return EffectRimLightMethod;\n}(EffectMethodBase_1.EffectMethodBase));\nexports.EffectRimLightMethod = EffectRimLightMethod;\n\n},{\"../methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\"}],\"awayjs-methodmaterials/lib/methods/LightingMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodBase_1 = require(\"../methods/ShadingMethodBase\");\n/**\n * LightingMethodBase provides an abstract base method for shading methods that uses lights.\n * Used for diffuse and specular shaders only.\n */\nvar LightingMethodBase = (function (_super) {\n    __extends(LightingMethodBase, _super);\n    /**\n     * Creates a new LightingMethodBase.\n     */\n    function LightingMethodBase() {\n        _super.call(this);\n    }\n    /**\n     * Get the fragment shader code that will be needed before any per-light code is added.\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param regCache The register cache used during the compilation.\n     * @private\n     */\n    LightingMethodBase.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    /**\n     * Get the fragment shader code that will generate the code relevant to a single light.\n     *\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param lightDirReg The register containing the light direction vector.\n     * @param lightColReg The register containing the light colour.\n     * @param regCache The register cache used during the compilation.\n     */\n    LightingMethodBase.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    /**\n     * Get the fragment shader code that will generate the code relevant to a single light probe object.\n     *\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param cubeMapReg The register containing the cube map for the current probe\n     * @param weightRegister A string representation of the register + component containing the current weight\n     * @param regCache The register cache providing any necessary registers to the shader\n     */\n    LightingMethodBase.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    /**\n     * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n     *\n     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n     * @param regCache The register cache used during the compilation.\n     * @param targetReg The register containing the final shading output.\n     * @private\n     */\n    LightingMethodBase.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    return LightingMethodBase;\n}(ShadingMethodBase_1.ShadingMethodBase));\nexports.LightingMethodBase = LightingMethodBase;\n\n},{\"../methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodBase_1 = require(\"../methods/ShadingMethodBase\");\n/**\n * NormalBasicMethod is the default method for standard tangent-space normal mapping.\n */\nvar NormalBasicMethod = (function (_super) {\n    __extends(NormalBasicMethod, _super);\n    /**\n     * Creates a new NormalBasicMethod object.\n     */\n    function NormalBasicMethod(texture) {\n        if (texture === void 0) { texture = null; }\n        _super.call(this);\n        this._texture = texture;\n        if (this._texture)\n            this.iAddTexture(this._texture);\n    }\n    NormalBasicMethod.prototype.iIsUsed = function (shader) {\n        if (this._texture && shader.normalDependencies)\n            return true;\n        return false;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n    };\n    /**\n     * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.\n     */\n    NormalBasicMethod.prototype.iOutputsTangentNormals = function () {\n        return true;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.copyFrom = function (method) {\n        var s = method;\n        var bnm = method;\n        if (bnm.texture != null)\n            this.texture = bnm.texture;\n    };\n    Object.defineProperty(NormalBasicMethod.prototype, \"texture\", {\n        /**\n         * A texture to modulate the direction of the surface for each texel (normal map). The default normal method expects\n         * tangent-space normal maps, but others could expect object-space maps.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.dispose = function () {\n        if (this._texture)\n            this._texture = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (this._texture)\n            methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    NormalBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (this._texture)\n            methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (this._texture)\n            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n        code += \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\\n\" +\n            \"nrm \" + targetReg + \".xyz, \" + targetReg + \"\\n\";\n        return code;\n    };\n    return NormalBasicMethod;\n}(ShadingMethodBase_1.ShadingMethodBase));\nexports.NormalBasicMethod = NormalBasicMethod;\n\n},{\"../methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/NormalHeightMapMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar NormalBasicMethod_1 = require(\"../methods/NormalBasicMethod\");\n/**\n * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.\n */\nvar NormalHeightMapMethod = (function (_super) {\n    __extends(NormalHeightMapMethod, _super);\n    /**\n     * Creates a new NormalHeightMapMethod method.\n     *\n     * @param heightMap The texture containing the height data. 0 means low, 1 means high.\n     * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.\n     * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.\n     * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.\n     */\n    function NormalHeightMapMethod(heightMap, worldWidth, worldHeight, worldDepth) {\n        _super.call(this);\n        this.texture = heightMap;\n        this._worldXYRatio = worldWidth / worldHeight;\n        this._worldXZRatio = worldDepth / worldHeight;\n    }\n    /**\n     * @inheritDoc\n     */\n    NormalHeightMapMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = 1 / this.texture.image2D.width;\n        data[index + 1] = 1 / this.texture.image2D.height;\n        data[index + 2] = 0;\n        data[index + 3] = 1;\n        data[index + 4] = this._worldXYRatio;\n        data[index + 5] = this._worldXZRatio;\n    };\n    Object.defineProperty(NormalHeightMapMethod.prototype, \"tangentSpace\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    NormalHeightMapMethod.prototype.copyFrom = function (method) {\n        _super.prototype.copyFrom.call(this, method);\n        this._worldXYRatio = method._worldXYRatio;\n        this._worldXZRatio = method._worldXZRatio;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalHeightMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var dataReg = registerCache.getFreeFragmentConstant();\n        var dataReg2 = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = dataReg.index * 4;\n        code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n            \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".xzzz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n            \"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + temp + \".x\\n\" +\n            \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".zyzz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n            \"sub \" + targetReg + \".z, \" + targetReg + \".z, \" + temp + \".x\\n\" +\n            \"mov \" + targetReg + \".y, \" + dataReg + \".w\\n\" +\n            \"mul \" + targetReg + \".xz, \" + targetReg + \".xz, \" + dataReg2 + \".xy\\n\" +\n            \"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        return code;\n    };\n    return NormalHeightMapMethod;\n}(NormalBasicMethod_1.NormalBasicMethod));\nexports.NormalHeightMapMethod = NormalHeightMapMethod;\n\n},{\"../methods/NormalBasicMethod\":\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar NormalBasicMethod_1 = require(\"../methods/NormalBasicMethod\");\n/**\n * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.\n */\nvar NormalSimpleWaterMethod = (function (_super) {\n    __extends(NormalSimpleWaterMethod, _super);\n    /**\n     * Creates a new NormalSimpleWaterMethod object.\n     * @param waveMap1 A normal map containing one layer of a wave structure.\n     * @param waveMap2 A normal map containing a second layer of a wave structure.\n     */\n    function NormalSimpleWaterMethod(normalMap, secondaryNormalMap) {\n        if (normalMap === void 0) { normalMap = null; }\n        if (secondaryNormalMap === void 0) { secondaryNormalMap = null; }\n        _super.call(this, normalMap);\n        this._water1OffsetX = 0;\n        this._water1OffsetY = 0;\n        this._water2OffsetX = 0;\n        this._water2OffsetY = 0;\n        this._secondaryNormalMap = secondaryNormalMap;\n        if (this._secondaryNormalMap)\n            this.iAddTexture(this._secondaryNormalMap);\n    }\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = .5;\n        data[index + 1] = 0;\n        data[index + 2] = 0;\n        data[index + 3] = 1;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iInitVO = function (shader, methodVO) {\n        _super.prototype.iInitVO.call(this, shader, methodVO);\n        if (this._secondaryNormalMap) {\n            methodVO.secondaryTextureGL = shader.getAbstraction(this._secondaryNormalMap);\n            shader.uvDependencies++;\n        }\n    };\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"water1OffsetX\", {\n        /**\n         * The translation of the first wave layer along the X-axis.\n         */\n        get: function () {\n            return this._water1OffsetX;\n        },\n        set: function (value) {\n            this._water1OffsetX = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"water1OffsetY\", {\n        /**\n         * The translation of the first wave layer along the Y-axis.\n         */\n        get: function () {\n            return this._water1OffsetY;\n        },\n        set: function (value) {\n            this._water1OffsetY = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"water2OffsetX\", {\n        /**\n         * The translation of the second wave layer along the X-axis.\n         */\n        get: function () {\n            return this._water2OffsetX;\n        },\n        set: function (value) {\n            this._water2OffsetX = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"water2OffsetY\", {\n        /**\n         * The translation of the second wave layer along the Y-axis.\n         */\n        get: function () {\n            return this._water2OffsetY;\n        },\n        set: function (value) {\n            this._water2OffsetY = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NormalSimpleWaterMethod.prototype, \"secondaryNormalMap\", {\n        /**\n         * A second normal map that will be combined with the first to create a wave-like animation pattern.\n         */\n        get: function () {\n            return this._secondaryNormalMap;\n        },\n        set: function (value) {\n            if (this._secondaryNormalMap == value)\n                return;\n            if (this._secondaryNormalMap)\n                this.iRemoveTexture(this._secondaryNormalMap);\n            this._secondaryNormalMap = value;\n            if (this._secondaryNormalMap)\n                this.iAddTexture(this._secondaryNormalMap);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this._secondaryNormalMap = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index + 4] = this._water1OffsetX;\n        data[index + 5] = this._water1OffsetY;\n        data[index + 6] = this._water2OffsetX;\n        data[index + 7] = this._water2OffsetY;\n        if (this._secondaryNormalMap)\n            methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);\n        if (this._secondaryNormalMap)\n            methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    NormalSimpleWaterMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var dataReg = registerCache.getFreeFragmentConstant();\n        var dataReg2 = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = dataReg.index * 4;\n        code += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".xyxy\\n\";\n        if (this.texture)\n            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, temp);\n        code += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".zwzw\\n\";\n        if (this._secondaryNormalMap)\n            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp);\n        code += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\t\t\\n\" +\n            \"mul \" + targetReg + \", \" + targetReg + \", \" + dataReg + \".x\t\\n\" +\n            \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\t\\n\" +\n            \"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\t\t\t\t\t\t\t\\n\";\n        return code;\n    };\n    return NormalSimpleWaterMethod;\n}(NormalBasicMethod_1.NormalBasicMethod));\nexports.NormalSimpleWaterMethod = NormalSimpleWaterMethod;\n\n},{\"../methods/NormalBasicMethod\":\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetBase_1 = require(\"awayjs-core/lib/library/AssetBase\");\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\n/**\n * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile\n * the final shading program.\n */\nvar ShadingMethodBase = (function (_super) {\n    __extends(ShadingMethodBase, _super);\n    /**\n     * Create a new ShadingMethodBase object.\n     */\n    function ShadingMethodBase() {\n        _super.call(this);\n        this._textures = new Array();\n        this._owners = new Array();\n        this._counts = new Array();\n    }\n    Object.defineProperty(ShadingMethodBase.prototype, \"assetType\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return ShadingMethodBase.assetType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ShadingMethodBase.prototype.iIsUsed = function (shader) {\n        return true;\n    };\n    /**\n     * Initializes the properties for a MethodVO, including register and texture indices.\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iInitVO = function (shader, methodVO) {\n    };\n    /**\n     * Initializes unchanging shader constants using the data from a MethodVO.\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iInitConstants = function (shader, methodVO) {\n    };\n    /**\n     * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.\n     */\n    ShadingMethodBase.prototype.iUsesTangentSpace = function () {\n        return true;\n    };\n    /**\n     * Cleans up any resources used by the current object.\n     */\n    ShadingMethodBase.prototype.dispose = function () {\n    };\n    ShadingMethodBase.prototype.iAddOwner = function (owner) {\n        //a method can be used more than once in the same material, so we check for this\n        var index = this._owners.indexOf(owner);\n        if (index != -1) {\n            this._counts[index]++;\n        }\n        else {\n            this._owners.push(owner);\n            this._counts.push(1);\n            //add textures\n            var len = this._textures.length;\n            for (var i = 0; i < len; i++)\n                owner.addTexture(this._textures[i]);\n        }\n    };\n    ShadingMethodBase.prototype.iRemoveOwner = function (owner) {\n        var index = this._owners.indexOf(owner);\n        if (this._counts[index] != 1) {\n            this._counts[index]--;\n        }\n        else {\n            this._owners.splice(index, 1);\n            this._counts.splice(index, 1);\n            //remove textures\n            var len = this._textures.length;\n            for (var i = 0; i < len; i++)\n                owner.removeTexture(this._textures[i]);\n        }\n    };\n    /**\n     *\n     */\n    ShadingMethodBase.prototype.iAddTexture = function (texture) {\n        this._textures.push(texture);\n        var len = this._owners.length;\n        for (var i = 0; i < len; i++)\n            this._owners[i].addTexture(texture);\n    };\n    /**\n     *\n     */\n    ShadingMethodBase.prototype.iRemoveTexture = function (texture) {\n        this._textures.splice(this._textures.indexOf(texture), 1);\n        var len = this._owners.length;\n        for (var i = 0; i < len; i++)\n            this._owners[i].removeTexture(texture);\n    };\n    /**\n     * Resets the compilation state of the method.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iReset = function () {\n        this.iCleanCompilationData();\n    };\n    /**\n     * Resets the method's state for compilation.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iCleanCompilationData = function () {\n    };\n    /**\n     * Get the vertex shader code for this method.\n     * @param vo The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return \"\";\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadingMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return null;\n    };\n    /**\n     * Sets the render state for this method.\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param stage The Stage object currently used for rendering.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iActivate = function (shader, methodVO, stage) {\n    };\n    /**\n     * Sets the render state for a single renderable.\n     *\n     * @param vo The MethodVO object linking this method with the pass currently being compiled.\n     * @param renderable The renderable currently being rendered.\n     * @param stage The Stage object currently used for rendering.\n     * @param camera The camera from which the scene is currently rendered.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n    };\n    /**\n     * Clears the render state for this method.\n     * @param vo The MethodVO object linking this method with the pass currently being compiled.\n     * @param stage The Stage object currently used for rendering.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iDeactivate = function (shader, methodVO, stage) {\n    };\n    /**\n     * Marks the shader program as invalid, so it will be recompiled before the next render.\n     *\n     * @internal\n     */\n    ShadingMethodBase.prototype.iInvalidateShaderProgram = function () {\n        this.dispatchEvent(new ShadingMethodEvent_1.ShadingMethodEvent(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED));\n    };\n    /**\n     * Copies the state from a ShadingMethodBase object into the current object.\n     */\n    ShadingMethodBase.prototype.copyFrom = function (method) {\n    };\n    ShadingMethodBase.assetType = \"[asset ShadingMethod]\";\n    return ShadingMethodBase;\n}(AssetBase_1.AssetBase));\nexports.ShadingMethodBase = ShadingMethodBase;\n\n},{\"awayjs-core/lib/library/AssetBase\":undefined,\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/ShadowCascadeMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar DirectionalLight_1 = require(\"awayjs-display/lib/display/DirectionalLight\");\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar MethodVO_1 = require(\"../data/MethodVO\");\nvar ShadowMapMethodBase_1 = require(\"../methods/ShadowMapMethodBase\");\n/**\n * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.\n * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.\n *\n * @see away.lights.CascadeShadowMapper\n */\nvar ShadowCascadeMethod = (function (_super) {\n    __extends(ShadowCascadeMethod, _super);\n    /**\n     * Creates a new ShadowCascadeMethod object.\n     *\n     * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n     */\n    function ShadowCascadeMethod(shadowMethodBase) {\n        var _this = this;\n        _super.call(this, shadowMethodBase.castingLight);\n        this._baseMethod = shadowMethodBase;\n        if (!(this._pCastingLight instanceof DirectionalLight_1.DirectionalLight))\n            throw new Error(\"ShadowCascadeMethod is only compatible with DirectionalLight\");\n        this._cascadeShadowMapper = this._pCastingLight.shadowMapper;\n        if (!this._cascadeShadowMapper)\n            throw new Error(\"ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.\");\n        this._cascadeShadowMapper.addEventListener(AssetEvent_1.AssetEvent.INVALIDATE, function (event) { return _this.onCascadeChange(event); });\n        this._baseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, function (event) { return _this.onShaderInvalidated(event); });\n    }\n    Object.defineProperty(ShadowCascadeMethod.prototype, \"baseMethod\", {\n        /**\n         * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction\n         * with a DirectionalShadowMapper.\n         *\n         * @see ShadowHardMethod\n         * @see ShadowSoftMethod\n         */\n        get: function () {\n            return this._baseMethod;\n        },\n        set: function (value) {\n            var _this = this;\n            if (this._baseMethod == value)\n                return;\n            this._baseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, function (event) { return _this.onShaderInvalidated(event); });\n            this._baseMethod = value;\n            this._baseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, function (event) { return _this.onShaderInvalidated(event); });\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iInitVO = function (shader, methodVO) {\n        var tempVO = new MethodVO_1.MethodVO(this._baseMethod, methodVO.pass);\n        this._baseMethod.iInitVO(shader, tempVO);\n        methodVO.needsGlobalVertexPos = true;\n        methodVO.needsProjection = true;\n        methodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var fragmentData = shader.fragmentConstantData;\n        var vertexData = shader.vertexConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        fragmentData[index] = 1.0;\n        fragmentData[index + 1] = 1 / 255.0;\n        fragmentData[index + 2] = 1 / 65025.0;\n        fragmentData[index + 3] = 1 / 16581375.0;\n        fragmentData[index + 6] = .5;\n        fragmentData[index + 7] = -.5;\n        index = methodVO.vertexConstantsIndex;\n        vertexData[index] = .5;\n        vertexData[index + 1] = -.5;\n        vertexData[index + 2] = 0;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._cascadeProjections = null;\n        this._depthMapCoordVaryings = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = \"\";\n        var dataReg = registerCache.getFreeVertexConstant();\n        this.initProjectionsRegs(registerCache);\n        methodVO.vertexConstantsIndex = dataReg.index * 4;\n        var temp = registerCache.getFreeVertexVectorTemp();\n        for (var i = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n            code += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + this._cascadeProjections[i] + \"\\n\" +\n                \"add \" + this._depthMapCoordVaryings[i] + \", \" + temp + \", \" + dataReg + \".zzwz\\n\";\n        }\n        return code;\n    };\n    /**\n     * Creates the registers for the cascades' projection coordinates.\n     */\n    ShadowCascadeMethod.prototype.initProjectionsRegs = function (registerCache) {\n        this._cascadeProjections = new Array(this._cascadeShadowMapper.numCascades);\n        this._depthMapCoordVaryings = new Array(this._cascadeShadowMapper.numCascades);\n        for (var i = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n            this._depthMapCoordVaryings[i] = registerCache.getFreeVarying();\n            this._cascadeProjections[i] = registerCache.getFreeVertexConstant();\n            registerCache.getFreeVertexConstant();\n            registerCache.getFreeVertexConstant();\n            registerCache.getFreeVertexConstant();\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var numCascades = this._cascadeShadowMapper.numCascades;\n        var decReg = registerCache.getFreeFragmentConstant();\n        var dataReg = registerCache.getFreeFragmentConstant();\n        var planeDistanceReg = registerCache.getFreeFragmentConstant();\n        var planeDistances = Array(planeDistanceReg + \".x\", planeDistanceReg + \".y\", planeDistanceReg + \".z\", planeDistanceReg + \".w\");\n        var code;\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        var inQuad = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(inQuad, 1);\n        var uvCoord = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(uvCoord, 1);\n        // assume lowest partition is selected, will be overwritten later otherwise\n        code = \"mov \" + uvCoord + \", \" + this._depthMapCoordVaryings[numCascades - 1] + \"\\n\";\n        for (var i = numCascades - 2; i >= 0; --i) {\n            var uvProjection = this._depthMapCoordVaryings[i];\n            // calculate if in texturemap (result == 0 or 1, only 1 for a single partition)\n            code += \"slt \" + inQuad + \".z, \" + sharedRegisters.projectionFragment + \".z, \" + planeDistances[i] + \"\\n\"; // z = x > minX, w = y > minY\n            var temp = registerCache.getFreeFragmentVectorTemp();\n            // linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)\n            code += \"sub \" + temp + \", \" + uvProjection + \", \" + uvCoord + \"\\n\" +\n                \"mul \" + temp + \", \" + temp + \", \" + inQuad + \".z\\n\" +\n                \"add \" + uvCoord + \", \" + uvCoord + \", \" + temp + \"\\n\";\n        }\n        registerCache.removeFragmentTempUsage(inQuad);\n        code += \"div \" + uvCoord + \", \" + uvCoord + \", \" + uvCoord + \".w\\n\" +\n            \"mul \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zw\\n\" +\n            \"add \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zz\\n\";\n        code += this._baseMethod._iGetCascadeFragmentCode(shader, methodVO, decReg, uvCoord, targetReg, registerCache, sharedRegisters) +\n            \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + dataReg + \".y\\n\";\n        registerCache.removeFragmentTempUsage(uvCoord);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        methodVO.textureGL.activate(methodVO.pass._render);\n        var vertexData = shader.vertexConstantData;\n        var vertexIndex = methodVO.vertexConstantsIndex;\n        shader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1 / (this._cascadeShadowMapper.depth * this._pEpsilon);\n        var numCascades = this._cascadeShadowMapper.numCascades;\n        vertexIndex += 4;\n        for (var k = 0; k < numCascades; ++k) {\n            this._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);\n            vertexIndex += 16;\n        }\n        var fragmentData = shader.fragmentConstantData;\n        var fragmentIndex = methodVO.fragmentConstantsIndex;\n        fragmentData[fragmentIndex + 5] = 1 - this._pAlpha;\n        var nearPlaneDistances = this._cascadeShadowMapper._iNearPlaneDistances;\n        fragmentIndex += 8;\n        for (var i = 0; i < numCascades; ++i)\n            fragmentData[fragmentIndex + i] = nearPlaneDistances[i];\n        this._baseMethod.iActivateForCascade(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowCascadeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n    };\n    /**\n     * Called when the shadow mappers cascade configuration changes.\n     */\n    ShadowCascadeMethod.prototype.onCascadeChange = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    /**\n     * Called when the base method's shader code is invalidated.\n     */\n    ShadowCascadeMethod.prototype.onShaderInvalidated = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    return ShadowCascadeMethod;\n}(ShadowMapMethodBase_1.ShadowMapMethodBase));\nexports.ShadowCascadeMethod = ShadowCascadeMethod;\n\n},{\"../data/MethodVO\":\"awayjs-methodmaterials/lib/data/MethodVO\",\"../methods/ShadowMapMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\",\"awayjs-core/lib/events/AssetEvent\":undefined,\"awayjs-display/lib/display/DirectionalLight\":undefined,\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/ShadowDitheredMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar BitmapImage2D_1 = require(\"awayjs-core/lib/image/BitmapImage2D\");\nvar Single2DTexture_1 = require(\"awayjs-display/lib/textures/Single2DTexture\");\nvar ShadowMethodBase_1 = require(\"../methods/ShadowMethodBase\");\n/**\n * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.\n */\nvar ShadowDitheredMethod = (function (_super) {\n    __extends(ShadowDitheredMethod, _super);\n    /**\n     * Creates a new ShadowDitheredMethod object.\n     * @param castingLight The light casting the shadows\n     * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.\n     */\n    function ShadowDitheredMethod(castingLight, numSamples, range) {\n        if (numSamples === void 0) { numSamples = 4; }\n        if (range === void 0) { range = 1; }\n        _super.call(this, castingLight);\n        this._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;\n        this.numSamples = numSamples;\n        this.range = range;\n        ++ShadowDitheredMethod._grainUsages;\n        if (!ShadowDitheredMethod._grainTexture)\n            this.initGrainTexture();\n    }\n    Object.defineProperty(ShadowDitheredMethod.prototype, \"numSamples\", {\n        /**\n         * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the\n         * complexity of the shader.\n         */\n        get: function () {\n            return this._numSamples;\n        },\n        set: function (value /*int*/) {\n            if (value < 1)\n                value = 1;\n            else if (value > 24)\n                value = 24;\n            if (this._numSamples == value)\n                return;\n            this._numSamples = value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iInitVO = function (shader, methodVO) {\n        _super.prototype.iInitVO.call(this, shader, methodVO);\n        methodVO.needsProjection = true;\n        methodVO.secondaryTextureGL = shader.getAbstraction(ShadowDitheredMethod._grainTexture);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        fragmentData[index + 8] = 1 / this._numSamples;\n    };\n    Object.defineProperty(ShadowDitheredMethod.prototype, \"range\", {\n        /**\n         * The range in the shadow map in which to distribute the samples.\n         */\n        get: function () {\n            return this._range * 2;\n        },\n        set: function (value) {\n            this._range = value / 2;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates a texture containing the dithering noise texture.\n     */\n    ShadowDitheredMethod.prototype.initGrainTexture = function () {\n        ShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D_1.BitmapImage2D(64, 64, false);\n        var vec = new Array();\n        var len = 4096;\n        var step = 1 / (this._depthMapSize * this._range);\n        var r, g;\n        for (var i = 0; i < len; ++i) {\n            r = 2 * (Math.random() - .5);\n            g = 2 * (Math.random() - .5);\n            if (r < 0)\n                r -= step;\n            else\n                r += step;\n            if (g < 0)\n                g -= step;\n            else\n                g += step;\n            if (r > 1)\n                r = 1;\n            else if (r < -1)\n                r = -1;\n            if (g > 1)\n                g = 1;\n            else if (g < -1)\n                g = -1;\n            vec[i] = (Math.floor((r * .5 + .5) * 0xff) << 16) | (Math.floor((g * .5 + .5) * 0xff) << 8);\n        }\n        ShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);\n        ShadowDitheredMethod._grainTexture = new Single2DTexture_1.Single2DTexture(ShadowDitheredMethod._grainBitmapImage2D);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.dispose = function () {\n        if (--ShadowDitheredMethod._grainUsages == 0) {\n            ShadowDitheredMethod._grainTexture.dispose();\n            ShadowDitheredMethod._grainBitmapImage2D.dispose();\n            ShadowDitheredMethod._grainTexture = null;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        data[index + 9] = (stage.width - 1) / 63;\n        data[index + 10] = (stage.height - 1) / 63;\n        data[index + 11] = 2 * this._range / this._depthMapSize;\n        methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);\n        methodVO.secondaryTextureGL._setRenderState(renderable);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        var decReg = regCache.getFreeFragmentConstant();\n        var dataReg = regCache.getFreeFragmentConstant();\n        var customDataReg = regCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        return this.getSampleCode(shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);\n    };\n    /**\n     * Get the actual shader code for shadow mapping\n     * @param regCache The register cache managing the registers.\n     * @param depthMapRegister The texture register containing the depth map.\n     * @param decReg The register containing the depth map decoding data.\n     * @param targetReg The target register to add the shadow coverage.\n     */\n    ShadowDitheredMethod.prototype.getSampleCode = function (shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters) {\n        var code = \"\";\n        var numSamples = this._numSamples;\n        var uvReg = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(uvReg, 1);\n        var temp = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(temp, 1);\n        var projectionReg = sharedRegisters.projectionFragment;\n        code += \"div \" + uvReg + \", \" + projectionReg + \", \" + projectionReg + \".w\\n\" +\n            \"mul \" + uvReg + \".xy, \" + uvReg + \".xy, \" + customDataReg + \".yz\\n\";\n        while (numSamples > 0) {\n            if (numSamples == this._numSamples) {\n                code += methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, uvReg);\n            }\n            else {\n                code += \"mov \" + temp + \", \" + uvReg + \".zwxy \\n\" +\n                    methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, temp);\n            }\n            // keep grain in uvReg.zw\n            code += \"sub \" + uvReg + \".zw, \" + uvReg + \".xy, fc0.xx\\n\" +\n                \"mul \" + uvReg + \".zw, \" + uvReg + \".zw, \" + customDataReg + \".w\\n\"; // (tex unpack scale and tex scale in one)\n            if (numSamples == this._numSamples) {\n                // first sample\n                code += \"add \" + uvReg + \".xy, \" + uvReg + \".zw, \" + this._pDepthMapCoordReg + \".xy\\n\" +\n                    methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n                    \"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n                    \"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n            }\n            else {\n                code += this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            }\n            if (numSamples > 4)\n                code += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 1)\n                code += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 5)\n                code += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 2) {\n                code += \"neg \" + uvReg + \".w, \" + uvReg + \".w\\n\"; // will be rotated 90 degrees when being accessed as wz\n                code += \"add \" + uvReg + \".xy, \" + uvReg + \".wz, \" + this._pDepthMapCoordReg + \".xy\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            }\n            if (numSamples > 6)\n                code += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 3)\n                code += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            if (numSamples > 7)\n                code += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n            numSamples -= 8;\n        }\n        regCache.removeFragmentTempUsage(temp);\n        regCache.removeFragmentTempUsage(uvReg);\n        code += \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + customDataReg + \".x\\n\"; // average\n        return code;\n    };\n    /**\n     * Adds the code for another tap to the shader code.\n     * @param uvReg The uv register for the tap.\n     * @param depthMapRegister The texture register containing the depth map.\n     * @param decReg The register containing the depth map decoding data.\n     * @param targetReg The target register to add the tap comparison result.\n     * @param regCache The register cache managing the registers.\n     * @return\n     */\n    ShadowDitheredMethod.prototype.addSample = function (shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters) {\n        var temp = regCache.getFreeFragmentVectorTemp();\n        return methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n            \"slt \" + temp + \".z, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" +\n            \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \".z\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n        var data = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        data[index] = 1 / this._numSamples;\n        data[index + 1] = (stage.width - 1) / 63;\n        data[index + 2] = (stage.height - 1) / 63;\n        data[index + 3] = 2 * this._range / this._depthMapSize;\n        methodVO.secondaryTextureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowDitheredMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        this._pDepthMapCoordReg = depthProjection;\n        var dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;\n        return this.getSampleCode(shader, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);\n    };\n    return ShadowDitheredMethod;\n}(ShadowMethodBase_1.ShadowMethodBase));\nexports.ShadowDitheredMethod = ShadowDitheredMethod;\n\n},{\"../methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\",\"awayjs-core/lib/image/BitmapImage2D\":undefined,\"awayjs-display/lib/textures/Single2DTexture\":undefined}],\"awayjs-methodmaterials/lib/methods/ShadowFilteredMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadowMethodBase_1 = require(\"../methods/ShadowMethodBase\");\n/**\n * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison\n * results of neighbouring pixels.\n */\nvar ShadowFilteredMethod = (function (_super) {\n    __extends(ShadowFilteredMethod, _super);\n    /**\n     * Creates a new DiffuseBasicMethod object.\n     *\n     * @param castingLight The light casting the shadow\n     */\n    function ShadowFilteredMethod(castingLight) {\n        _super.call(this, castingLight);\n    }\n    /**\n     * @inheritDoc\n     */\n    ShadowFilteredMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        fragmentData[index + 8] = .5;\n        var size = this.castingLight.shadowMapper.depthMapSize;\n        fragmentData[index + 9] = size;\n        fragmentData[index + 10] = 1 / size;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowFilteredMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        var code = \"\";\n        var decReg = regCache.getFreeFragmentConstant();\n        regCache.getFreeFragmentConstant();\n        var customDataReg = regCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        var depthCol = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(depthCol, 1);\n        var uvReg = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(uvReg, 1);\n        code += \"mov \" + uvReg + \", \" + this._pDepthMapCoordReg + \"\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +\n            \"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +\n            \"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n            \"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n            \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n            \"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n            \"add \" + targetReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n            \"mov \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x\\n\" +\n            \"add \" + uvReg + \".y, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".z\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +\n            \"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +\n            // recalculate fraction, since we ran out of registers :(\n            \"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n            \"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n            \"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n            \"add \" + uvReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n            \"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".y\\n\" +\n            \"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n            \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + targetReg + \".w\\n\" +\n            \"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n            \"add \" + targetReg + \".w, \" + targetReg + \".w, \" + uvReg + \".w\\n\";\n        regCache.removeFragmentTempUsage(depthCol);\n        regCache.removeFragmentTempUsage(uvReg);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowFilteredMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n        var size = this.castingLight.shadowMapper.depthMapSize;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = size;\n        data[index + 1] = 1 / size;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowFilteredMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        var code;\n        var dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(temp, 1);\n        var predicate = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(predicate, 1);\n        code = methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + predicate + \".x, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n            \"add \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + predicate + \".z, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n            \"add \" + depthProjection + \".y, \" + depthProjection + \".y, \" + dataReg + \".y\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + predicate + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n            \"sub \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + predicate + \".y, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n            \"mul \" + temp + \".xy, \" + depthProjection + \".xy, \" + dataReg + \".x\\n\" +\n            \"frc \" + temp + \".xy, \" + temp + \".xy\\n\" +\n            // some strange register juggling to prevent agal bugging out\n            \"sub \" + depthProjection + \", \" + predicate + \".xyzw, \" + predicate + \".zwxy\\n\" +\n            \"mul \" + depthProjection + \", \" + depthProjection + \", \" + temp + \".x\\n\" +\n            \"add \" + predicate + \".xy, \" + predicate + \".xy, \" + depthProjection + \".zw\\n\" +\n            \"sub \" + predicate + \".y, \" + predicate + \".y, \" + predicate + \".x\\n\" +\n            \"mul \" + predicate + \".y, \" + predicate + \".y, \" + temp + \".y\\n\" +\n            \"add \" + targetRegister + \".w, \" + predicate + \".x, \" + predicate + \".y\\n\";\n        registerCache.removeFragmentTempUsage(temp);\n        registerCache.removeFragmentTempUsage(predicate);\n        return code;\n    };\n    return ShadowFilteredMethod;\n}(ShadowMethodBase_1.ShadowMethodBase));\nexports.ShadowFilteredMethod = ShadowFilteredMethod;\n\n},{\"../methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\"}],\"awayjs-methodmaterials/lib/methods/ShadowHardMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadowMethodBase_1 = require(\"../methods/ShadowMethodBase\");\n/**\n * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.\n */\nvar ShadowHardMethod = (function (_super) {\n    __extends(ShadowHardMethod, _super);\n    /**\n     * Creates a new ShadowHardMethod object.\n     */\n    function ShadowHardMethod(castingLight) {\n        _super.call(this, castingLight);\n    }\n    /**\n     * @inheritDoc\n     */\n    ShadowHardMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        var code = \"\";\n        var decReg = regCache.getFreeFragmentConstant();\n        regCache.getFreeFragmentConstant();\n        var depthCol = regCache.getFreeFragmentVectorTemp();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        code += methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n            \"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n            \"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\"; // 0 if in shadow\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowHardMethod.prototype._pGetPointFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        var code = \"\";\n        var decReg = regCache.getFreeFragmentConstant();\n        var epsReg = regCache.getFreeFragmentConstant();\n        var posReg = regCache.getFreeFragmentConstant();\n        var depthSampleCol = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(depthSampleCol, 1);\n        var lightDir = regCache.getFreeFragmentVectorTemp();\n        regCache.addFragmentTempUsages(lightDir, 1);\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        code += \"sub \" + lightDir + \", \" + sharedRegisters.globalPositionVarying + \", \" + posReg + \"\\n\" +\n            \"dp3 \" + lightDir + \".w, \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n            \"mul \" + lightDir + \".w, \" + lightDir + \".w, \" + posReg + \".w\\n\" +\n            \"nrm \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n            methodVO.textureGL._iGetFragmentCode(depthSampleCol, regCache, sharedRegisters, lightDir) +\n            \"dp4 \" + depthSampleCol + \".z, \" + depthSampleCol + \", \" + decReg + \"\\n\" +\n            \"add \" + targetReg + \".w, \" + lightDir + \".w, \" + epsReg + \".x\\n\" +\n            \"slt \" + targetReg + \".w, \" + targetReg + \".w, \" + depthSampleCol + \".z\\n\"; // 0 if in shadow\n        regCache.removeFragmentTempUsage(lightDir);\n        regCache.removeFragmentTempUsage(depthSampleCol);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowHardMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + targetRegister + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowHardMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n    };\n    return ShadowHardMethod;\n}(ShadowMethodBase_1.ShadowMethodBase));\nexports.ShadowHardMethod = ShadowHardMethod;\n\n},{\"../methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\"}],\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodBase_1 = require(\"../methods/ShadingMethodBase\");\n/**\n * ShadowMapMethodBase provides an abstract base method for shadow map methods.\n */\nvar ShadowMapMethodBase = (function (_super) {\n    __extends(ShadowMapMethodBase, _super);\n    /**\n     * Creates a new ShadowMapMethodBase object.\n     * @param castingLight The light used to cast shadows.\n     */\n    function ShadowMapMethodBase(castingLight) {\n        _super.call(this);\n        this._pEpsilon = .02;\n        this._pAlpha = 1;\n        this._pCastingLight = castingLight;\n        castingLight.shadowsEnabled = true;\n        this._pShadowMapper = castingLight.shadowMapper;\n        this.iAddTexture(castingLight.shadowMapper.depthMap);\n    }\n    Object.defineProperty(ShadowMapMethodBase.prototype, \"assetType\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return ShadowMapMethodBase.assetType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowMapMethodBase.prototype, \"alpha\", {\n        /**\n         * The \"transparency\" of the shadows. This allows making shadows less strong.\n         */\n        get: function () {\n            return this._pAlpha;\n        },\n        set: function (value) {\n            this._pAlpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowMapMethodBase.prototype, \"castingLight\", {\n        /**\n         * The light casting the shadows.\n         */\n        get: function () {\n            return this._pCastingLight;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowMapMethodBase.prototype, \"epsilon\", {\n        /**\n         * A small value to counter floating point precision errors when comparing values in the shadow map with the\n         * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.\n         */\n        get: function () {\n            return this._pEpsilon;\n        },\n        set: function (value) {\n            this._pEpsilon = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ShadowMapMethodBase.assetType = \"[asset ShadowMapMethod]\";\n    return ShadowMapMethodBase;\n}(ShadingMethodBase_1.ShadingMethodBase));\nexports.ShadowMapMethodBase = ShadowMapMethodBase;\n\n},{\"../methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\"}],\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AbstractMethodError_1 = require(\"awayjs-core/lib/errors/AbstractMethodError\");\nvar PointLight_1 = require(\"awayjs-display/lib/display/PointLight\");\nvar ShadowMapMethodBase_1 = require(\"../methods/ShadowMapMethodBase\");\n/**\n * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.\n */\nvar ShadowMethodBase = (function (_super) {\n    __extends(ShadowMethodBase, _super);\n    /**\n     * Creates a new ShadowMethodBase object.\n     * @param castingLight The light used to cast shadows.\n     */\n    function ShadowMethodBase(castingLight) {\n        _super.call(this, castingLight);\n        this._pUsePoint = (castingLight instanceof PointLight_1.PointLight);\n    }\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsView = true;\n        methodVO.needsGlobalVertexPos = true;\n        methodVO.needsGlobalFragmentPos = this._pUsePoint;\n        methodVO.needsNormals = shader.numLights > 0;\n        methodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iInitConstants = function (shader, methodVO) {\n        var fragmentData = shader.fragmentConstantData;\n        var vertexData = shader.vertexConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        fragmentData[index] = 1.0;\n        fragmentData[index + 1] = 1 / 255.0;\n        fragmentData[index + 2] = 1 / 65025.0;\n        fragmentData[index + 3] = 1 / 16581375.0;\n        fragmentData[index + 6] = 0;\n        fragmentData[index + 7] = 1;\n        if (this._pUsePoint) {\n            fragmentData[index + 8] = 0;\n            fragmentData[index + 9] = 0;\n            fragmentData[index + 10] = 0;\n            fragmentData[index + 11] = 1;\n        }\n        index = methodVO.vertexConstantsIndex;\n        if (index != -1) {\n            vertexData[index] = .5;\n            vertexData[index + 1] = .5;\n            vertexData[index + 2] = 0.0;\n            vertexData[index + 3] = 1.0;\n        }\n    };\n    Object.defineProperty(ShadowMethodBase.prototype, \"_iDepthMapCoordReg\", {\n        /**\n         * Wrappers that override the vertex shader need to set this explicitly\n         */\n        get: function () {\n            return this._pDepthMapCoordReg;\n        },\n        set: function (value) {\n            this._pDepthMapCoordReg = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._pDepthMapCoordReg = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iGetVertexCode = function (shader, methodVO, regCache, sharedRegisters) {\n        return this._pUsePoint ? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters) : this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);\n    };\n    /**\n     * Gets the vertex code for shadow mapping with a point light.\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     */\n    ShadowMethodBase.prototype._pGetPointVertexCode = function (methodVO, regCache, sharedRegisters) {\n        methodVO.vertexConstantsIndex = -1;\n        return \"\";\n    };\n    /**\n     * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).\n     *\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     */\n    ShadowMethodBase.prototype.pGetPlanarVertexCode = function (methodVO, regCache, sharedRegisters) {\n        var code = \"\";\n        var temp = regCache.getFreeVertexVectorTemp();\n        var dataReg = regCache.getFreeVertexConstant();\n        var depthMapProj = regCache.getFreeVertexConstant();\n        regCache.getFreeVertexConstant();\n        regCache.getFreeVertexConstant();\n        regCache.getFreeVertexConstant();\n        this._pDepthMapCoordReg = regCache.getFreeVarying();\n        methodVO.vertexConstantsIndex = dataReg.index * 4;\n        // todo: can epsilon be applied here instead of fragment shader?\n        code += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + depthMapProj + \"\\n\" +\n            \"div \" + temp + \", \" + temp + \", \" + temp + \".w\\n\" +\n            \"mul \" + temp + \".xy, \" + temp + \".xy, \" + dataReg + \".xy\\n\" +\n            \"add \" + this._pDepthMapCoordReg + \", \" + temp + \", \" + dataReg + \".xxwz\\n\";\n        //\"sub \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".w\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = this._pUsePoint ? this._pGetPointFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n        code += \"add \" + targetReg + \".w, \" + targetReg + \".w, fc\" + (methodVO.fragmentConstantsIndex / 4 + 1) + \".y\\n\" +\n            \"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n        return code;\n    };\n    /**\n     * Gets the fragment code for shadow mapping with a planar shadow map.\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     * @param targetReg The register to contain the shadow coverage\n     * @return\n     */\n    ShadowMethodBase.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        throw new AbstractMethodError_1.AbstractMethodError();\n    };\n    /**\n     * Gets the fragment code for shadow mapping with a point light.\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     * @param targetReg The register to contain the shadow coverage\n     * @return\n     */\n    ShadowMethodBase.prototype._pGetPointFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        throw new AbstractMethodError_1.AbstractMethodError();\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (!this._pUsePoint)\n            this._pShadowMapper.iDepthProjection.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);\n        methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Gets the fragment code for combining this method with a cascaded shadow map method.\n     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n     * @param regCache The register cache used during the compilation.\n     * @param decodeRegister The register containing the data to decode the shadow map depth value.\n     * @param depthTexture The texture containing the shadow map.\n     * @param depthProjection The projection of the fragment relative to the light.\n     * @param targetRegister The register to contain the shadow coverage\n     * @return\n     */\n    ShadowMethodBase.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        throw new Error(\"This shadow method is incompatible with cascade shadows\");\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowMethodBase.prototype.iActivate = function (shader, methodVO, stage) {\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex;\n        if (this._pUsePoint)\n            fragmentData[index + 4] = -Math.pow(1 / (this._pCastingLight.fallOff * this._pEpsilon), 2);\n        else\n            shader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1 / (this._pShadowMapper.depth * this._pEpsilon);\n        fragmentData[index + 5] = 1 - this._pAlpha;\n        if (this._pUsePoint) {\n            var pos = this._pCastingLight.scenePosition;\n            fragmentData[index + 8] = pos.x;\n            fragmentData[index + 9] = pos.y;\n            fragmentData[index + 10] = pos.z;\n            // used to decompress distance\n            var f = this._pCastingLight.fallOff;\n            fragmentData[index + 11] = 1 / (2 * f * f);\n        }\n        methodVO.textureGL.activate(methodVO.pass._render);\n    };\n    /**\n     * Sets the method state for cascade shadow mapping.\n     */\n    ShadowMethodBase.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n        throw new Error(\"This shadow method is incompatible with cascade shadows\");\n    };\n    return ShadowMethodBase;\n}(ShadowMapMethodBase_1.ShadowMapMethodBase));\nexports.ShadowMethodBase = ShadowMethodBase;\n\n},{\"../methods/ShadowMapMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\",\"awayjs-core/lib/errors/AbstractMethodError\":undefined,\"awayjs-display/lib/display/PointLight\":undefined}],\"awayjs-methodmaterials/lib/methods/ShadowNearMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar ShadowMethodBase_1 = require(\"../methods/ShadowMethodBase\");\n// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work\n/**\n * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize\n * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.\n *\n * @see away.lights.NearDirectionalShadowMapper\n */\nvar ShadowNearMethod = (function (_super) {\n    __extends(ShadowNearMethod, _super);\n    /**\n     * Creates a new ShadowNearMethod object.\n     * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n     * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n     */\n    function ShadowNearMethod(baseMethod, fadeRatio) {\n        var _this = this;\n        if (fadeRatio === void 0) { fadeRatio = .1; }\n        _super.call(this, baseMethod.castingLight);\n        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };\n        this._baseMethod = baseMethod;\n        this._fadeRatio = fadeRatio;\n        this._nearShadowMapper = this._pCastingLight.shadowMapper;\n        if (!this._nearShadowMapper)\n            throw new Error(\"ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.\");\n        this._baseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n    }\n    Object.defineProperty(ShadowNearMethod.prototype, \"baseMethod\", {\n        /**\n         * The base shadow map method on which this method's shading is based.\n         */\n        get: function () {\n            return this._baseMethod;\n        },\n        set: function (value) {\n            if (this._baseMethod == value)\n                return;\n            this._baseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this._baseMethod = value;\n            this._baseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        this._baseMethod.iInitConstants(shader, methodVO);\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        fragmentData[index + 2] = 0;\n        fragmentData[index + 3] = 1;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iInitVO = function (shader, methodVO) {\n        this._baseMethod.iInitVO(shader, methodVO);\n        methodVO.needsProjection = true;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.dispose = function () {\n        this._baseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n    };\n    Object.defineProperty(ShadowNearMethod.prototype, \"alpha\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.alpha;\n        },\n        set: function (value) {\n            this._baseMethod.alpha = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowNearMethod.prototype, \"epsilon\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.epsilon;\n        },\n        set: function (value) {\n            this._baseMethod.epsilon = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowNearMethod.prototype, \"fadeRatio\", {\n        /**\n         * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n         */\n        get: function () {\n            return this._fadeRatio;\n        },\n        set: function (value) {\n            this._fadeRatio = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = this._baseMethod.iGetFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n        var dataReg = registerCache.getFreeFragmentConstant();\n        var temp = registerCache.getFreeFragmentSingleTemp();\n        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;\n        code += \"abs \" + temp + \", \" + sharedRegisters.projectionFragment + \".w\\n\" +\n            \"sub \" + temp + \", \" + temp + \", \" + dataReg + \".x\\n\" +\n            \"mul \" + temp + \", \" + temp + \", \" + dataReg + \".y\\n\" +\n            \"sat \" + temp + \", \" + temp + \"\\n\" +\n            \"sub \" + temp + \", \" + dataReg + \".w,\" + temp + \"\\n\" +\n            \"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \"\\n\" +\n            \"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        this._baseMethod.iActivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iDeactivate = function (shader, methodVO, stage) {\n        this._baseMethod.iDeactivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        // todo: move this to activate (needs camera)\n        var near = camera.projection.near;\n        var d = camera.projection.far - near;\n        var maxDistance = this._nearShadowMapper.coverageRatio;\n        var minDistance = maxDistance * (1 - this._fadeRatio);\n        maxDistance = near + maxDistance * d;\n        minDistance = near + minDistance * d;\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        fragmentData[index] = minDistance;\n        fragmentData[index + 1] = 1 / (maxDistance - minDistance);\n        this._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iReset = function () {\n        this._baseMethod.iReset();\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowNearMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._baseMethod.iCleanCompilationData();\n    };\n    /**\n     * Called when the base method's shader code is invalidated.\n     */\n    ShadowNearMethod.prototype.onShaderInvalidated = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    return ShadowNearMethod;\n}(ShadowMethodBase_1.ShadowMethodBase));\nexports.ShadowNearMethod = ShadowNearMethod;\n\n},{\"../methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\",\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/ShadowSoftMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar PoissonLookup_1 = require(\"awayjs-core/lib/geom/PoissonLookup\");\nvar ShadowMethodBase_1 = require(\"../methods/ShadowMethodBase\");\n/**\n * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.\n */\nvar ShadowSoftMethod = (function (_super) {\n    __extends(ShadowSoftMethod, _super);\n    /**\n     * Creates a new DiffuseBasicMethod object.\n     *\n     * @param castingLight The light casting the shadows\n     * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.\n     */\n    function ShadowSoftMethod(castingLight, numSamples, range) {\n        if (numSamples === void 0) { numSamples = 5; }\n        if (range === void 0) { range = 1; }\n        _super.call(this, castingLight);\n        this._range = 1;\n        this.numSamples = numSamples;\n        this.range = range;\n    }\n    Object.defineProperty(ShadowSoftMethod.prototype, \"numSamples\", {\n        /**\n         * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the\n         * complexity of the shader.\n         */\n        get: function () {\n            return this._numSamples;\n        },\n        set: function (value /*int*/) {\n            this._numSamples = value;\n            if (this._numSamples < 1)\n                this._numSamples = 1;\n            else if (this._numSamples > 32)\n                this._numSamples = 32;\n            this._offsets = PoissonLookup_1.PoissonLookup.getDistribution(this._numSamples);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ShadowSoftMethod.prototype, \"range\", {\n        /**\n         * The range in the shadow map in which to distribute the samples.\n         */\n        get: function () {\n            return this._range;\n        },\n        set: function (value) {\n            this._range = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype.iInitConstants = function (shader, methodVO) {\n        _super.prototype.iInitConstants.call(this, shader, methodVO);\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1 / this._numSamples;\n        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var texRange = .5 * this._range / this._pCastingLight.shadowMapper.depthMapSize;\n        var data = shader.fragmentConstantData;\n        var index = methodVO.fragmentConstantsIndex + 10;\n        var len = this._numSamples << 1;\n        for (var i = 0; i < len; ++i)\n            data[index + i] = this._offsets[i] * texRange;\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {\n        // todo: move some things to super\n        var decReg = regCache.getFreeFragmentConstant();\n        regCache.getFreeFragmentConstant();\n        var dataReg = regCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = decReg.index * 4;\n        return this.getSampleCode(shader, methodVO, decReg, targetReg, regCache, sharedRegisters, dataReg);\n    };\n    /**\n     * Adds the code for another tap to the shader code.\n     * @param uv The uv register for the tap.\n     * @param texture The texture register containing the depth map.\n     * @param decode The register containing the depth map decoding data.\n     * @param target The target register to add the tap comparison result.\n     * @param regCache The register cache managing the registers.\n     * @return\n     */\n    ShadowSoftMethod.prototype.addSample = function (shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg) {\n        var temp = registerCache.getFreeFragmentVectorTemp();\n        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n            \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n            \"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" +\n            \"add \" + targetRegister + \".w, \" + targetRegister + \".w, \" + uvReg + \".w\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var texRange = this._range / this._pCastingLight.shadowMapper.depthMapSize;\n        var data = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var len = this._numSamples << 1;\n        data[index] = 1 / this._numSamples;\n        data[index + 1] = 0;\n        index += 2;\n        for (var i = 0; i < len; ++i)\n            data[index + i] = this._offsets[i] * texRange;\n        if (len % 4 == 0) {\n            data[index + len] = 0;\n            data[index + len + 1] = 0;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    ShadowSoftMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {\n        this._pDepthMapCoordReg = depthProjection;\n        var dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;\n        return this.getSampleCode(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg);\n    };\n    /**\n     * Get the actual shader code for shadow mapping\n     * @param regCache The register cache managing the registers.\n     * @param depthTexture The texture register containing the depth map.\n     * @param decodeRegister The register containing the depth map decoding data.\n     * @param targetReg The target register to add the shadow coverage.\n     * @param dataReg The register containing additional data.\n     */\n    ShadowSoftMethod.prototype.getSampleCode = function (shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg) {\n        var code;\n        var uvReg = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(uvReg, 1);\n        var offsets = new Array(dataReg + \".zw\");\n        var numRegs = this._numSamples >> 1;\n        for (var i = 0; i < numRegs; ++i) {\n            var reg = registerCache.getFreeFragmentConstant();\n            offsets.push(reg + \".xy\");\n            offsets.push(reg + \".zw\");\n        }\n        for (i = 0; i < this._numSamples; ++i) {\n            if (i == 0) {\n                var temp = registerCache.getFreeFragmentVectorTemp();\n                code = \"add \" + uvReg + \", \" + this._pDepthMapCoordReg + \", \" + dataReg + \".zwyy\\n\" +\n                    methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n                    \"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n                    \"slt \" + targetRegister + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow;\n            }\n            else {\n                code += \"add \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + offsets[i] + \"\\n\" +\n                    this.addSample(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg);\n            }\n        }\n        registerCache.removeFragmentTempUsage(uvReg);\n        code += \"mul \" + targetRegister + \".w, \" + targetRegister + \".w, \" + dataReg + \".x\\n\"; // average\n        return code;\n    };\n    return ShadowSoftMethod;\n}(ShadowMethodBase_1.ShadowMethodBase));\nexports.ShadowSoftMethod = ShadowSoftMethod;\n\n},{\"../methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\",\"awayjs-core/lib/geom/PoissonLookup\":undefined}],\"awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar SpecularBasicMethod_1 = require(\"../methods/SpecularBasicMethod\");\n/**\n * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for\n * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.\n * The tangent vectors are used as the surface groove directions.\n */\nvar SpecularAnisotropicMethod = (function (_super) {\n    __extends(SpecularAnisotropicMethod, _super);\n    /**\n     * Creates a new SpecularAnisotropicMethod object.\n     */\n    function SpecularAnisotropicMethod() {\n        _super.call(this);\n    }\n    /**\n     * @inheritDoc\n     */\n    SpecularAnisotropicMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsTangents = true;\n        methodVO.needsView = true;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularAnisotropicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        if (this._pIsFirstLight)\n            t = this._pTotalLightColorReg;\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        // (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k\n        code += \"nrm \" + t + \".xyz, \" + sharedRegisters.tangentVarying + \".xyz\\n\" +\n            \"dp3 \" + t + \".w, \" + t + \".xyz, \" + lightDirReg + \".xyz\\n\" +\n            \"dp3 \" + t + \".z, \" + t + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\";\n        // (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k\n        code += \"sin \" + t + \".x, \" + t + \".w\\n\" +\n            \"sin \" + t + \".y, \" + t + \".z\\n\" +\n            // (t.x * t.y - cos(t.w)*cos(t.z)) ^ k\n            \"mul \" + t + \".x, \" + t + \".x, \" + t + \".y\\n\" +\n            // (t.x - cos(t.w)*cos(t.z)) ^ k\n            \"cos \" + t + \".z, \" + t + \".z\\n\" +\n            \"cos \" + t + \".w, \" + t + \".w\\n\" +\n            // (t.x - t.w*t.z) ^ k\n            \"mul \" + t + \".w, \" + t + \".w, \" + t + \".z\\n\" +\n            // (t.x - t.w) ^ k\n            \"sub \" + t + \".w, \" + t + \".x, \" + t + \".w\\n\";\n        if (this.texture) {\n            // apply gloss modulation from texture\n            code += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n                \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n        }\n        else\n            code += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n        // attenuate\n        code += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    return SpecularAnisotropicMethod;\n}(SpecularBasicMethod_1.SpecularBasicMethod));\nexports.SpecularAnisotropicMethod = SpecularAnisotropicMethod;\n\n},{\"../methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\"}],\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar LightingMethodBase_1 = require(\"../methods/LightingMethodBase\");\n/**\n * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated\n * version of Phong specularity).\n */\nvar SpecularBasicMethod = (function (_super) {\n    __extends(SpecularBasicMethod, _super);\n    /**\n     * Creates a new SpecularBasicMethod object.\n     */\n    function SpecularBasicMethod() {\n        _super.call(this);\n        this._gloss = 50;\n        this._strength = 1;\n        this._color = 0xffffff;\n        this._iSpecularR = 1;\n        this._iSpecularG = 1;\n        this._iSpecularB = 1;\n    }\n    SpecularBasicMethod.prototype.iIsUsed = function (shader) {\n        if (!shader.numLights)\n            return false;\n        return true;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iInitVO = function (shader, methodVO) {\n        methodVO.needsNormals = shader.numLights > 0;\n        methodVO.needsView = shader.numLights > 0;\n        if (this._texture) {\n            methodVO.textureGL = shader.getAbstraction(this._texture);\n            shader.uvDependencies++;\n        }\n        else if (methodVO.textureGL) {\n            methodVO.textureGL.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, null));\n            methodVO.textureGL = null;\n        }\n    };\n    Object.defineProperty(SpecularBasicMethod.prototype, \"gloss\", {\n        /**\n         * The glossiness of the material (sharpness of the specular highlight).\n         */\n        get: function () {\n            return this._gloss;\n        },\n        set: function (value) {\n            this._gloss = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularBasicMethod.prototype, \"strength\", {\n        /**\n         * The overall strength of the specular highlights.\n         */\n        get: function () {\n            return this._strength;\n        },\n        set: function (value) {\n            if (value == this._strength)\n                return;\n            this._strength = value;\n            this.updateSpecular();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularBasicMethod.prototype, \"color\", {\n        /**\n         * The colour of the specular reflection of the surface.\n         */\n        get: function () {\n            return this._color;\n        },\n        set: function (value) {\n            if (this._color == value)\n                return;\n            // specular is now either enabled or disabled\n            if (this._color == 0 || value == 0)\n                this.iInvalidateShaderProgram();\n            this._color = value;\n            this.updateSpecular();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularBasicMethod.prototype, \"texture\", {\n        /**\n         * A texture that defines the strength of specular reflections for each texel in the red channel,\n         * and the gloss factor (sharpness) in the green channel. You can use Specular2DTexture if you want to easily set\n         * specular and gloss maps from grayscale images, but correctly authored images are preferred.\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture == value)\n                return;\n            if (this._texture)\n                this.iRemoveTexture(this._texture);\n            this._texture = value;\n            if (this._texture)\n                this.iAddTexture(this._texture);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.copyFrom = function (method) {\n        var m = method;\n        var bsm = method;\n        var spec = bsm; //SpecularBasicMethod(method);\n        this.texture = spec.texture;\n        this.strength = spec.strength;\n        this.color = spec.color;\n        this.gloss = spec.gloss;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._pTotalLightColorReg = null;\n        this._pSpecularTexData = null;\n        this._pSpecularDataRegister = null;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        var code = \"\";\n        this._pIsFirstLight = true;\n        this._pSpecularDataRegister = registerCache.getFreeFragmentConstant();\n        methodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index * 4;\n        if (this._texture) {\n            this._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(this._pSpecularTexData, 1);\n            code += methodVO.textureGL._iGetFragmentCode(this._pSpecularTexData, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n        }\n        this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n        registerCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        var normalReg = sharedRegisters.normalFragment;\n        // blinn-phong half vector model\n        code += \"add \" + t + \", \" + lightDirReg + \", \" + viewDirReg + \"\\n\" +\n            \"nrm \" + t + \".xyz, \" + t + \"\\n\" +\n            \"dp3 \" + t + \".w, \" + normalReg + \", \" + t + \"\\n\" +\n            \"sat \" + t + \".w, \" + t + \".w\\n\";\n        if (this._texture) {\n            // apply gloss modulation from texture\n            code += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n                \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n        }\n        else {\n            code += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n        }\n        // attenuate\n        if (shader.usesLightFallOff)\n            code += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += \"mul \" + t + \".xyz, \" + lightColReg + \", \" + t + \".w\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        // write in temporary if not first light, so we can add to total diffuse colour\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        var normalReg = sharedRegisters.normalFragment;\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        code += \"dp3 \" + t + \".w, \" + normalReg + \", \" + viewDirReg + \"\\n\" +\n            \"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n            \"mul \" + t + \", \" + t + \".w, \" + normalReg + \"\\n\" +\n            \"sub \" + t + \", \" + t + \", \" + viewDirReg + \"\\n\" +\n            \"tex \" + t + \", \" + t + \", \" + cubeMapReg + \" <cube,\" + \"linear\" + \",miplinear>\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \", \" + weightRegister + \"\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (sharedRegisters.shadowTarget)\n            code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n        if (this._texture) {\n            // apply strength modulation from texture\n            code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularTexData + \".x\\n\";\n            registerCache.removeFragmentTempUsage(this._pSpecularTexData);\n        }\n        // apply material's specular reflection\n        code += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularDataRegister + \"\\n\" +\n            \"add \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\";\n        registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        if (this._texture)\n            methodVO.textureGL.activate(methodVO.pass._render);\n        var index = methodVO.fragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._iSpecularR;\n        data[index + 1] = this._iSpecularG;\n        data[index + 2] = this._iSpecularB;\n        data[index + 3] = this._gloss;\n    };\n    SpecularBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        if (this._texture)\n            methodVO.textureGL._setRenderState(renderable);\n    };\n    /**\n     * Updates the specular color data used by the render state.\n     */\n    SpecularBasicMethod.prototype.updateSpecular = function () {\n        this._iSpecularR = ((this._color >> 16) & 0xff) / 0xff * this._strength;\n        this._iSpecularG = ((this._color >> 8) & 0xff) / 0xff * this._strength;\n        this._iSpecularB = (this._color & 0xff) / 0xff * this._strength;\n    };\n    return SpecularBasicMethod;\n}(LightingMethodBase_1.LightingMethodBase));\nexports.SpecularBasicMethod = SpecularBasicMethod;\n\n},{\"../methods/LightingMethodBase\":\"awayjs-methodmaterials/lib/methods/LightingMethodBase\",\"awayjs-core/lib/events/AssetEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/SpecularCelMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar SpecularCompositeMethod_1 = require(\"../methods/SpecularCompositeMethod\");\n/**\n * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.\n */\nvar SpecularCelMethod = (function (_super) {\n    __extends(SpecularCelMethod, _super);\n    /**\n     * Creates a new SpecularCelMethod object.\n     * @param specularCutOff The threshold at which the specular highlight should be shown.\n     * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.\n     */\n    function SpecularCelMethod(specularCutOff, baseMethod) {\n        var _this = this;\n        if (specularCutOff === void 0) { specularCutOff = .5; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this, null, baseMethod);\n        this._smoothness = .1;\n        this._specularCutOff = .1;\n        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.clampSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters); };\n        this._specularCutOff = specularCutOff;\n    }\n    Object.defineProperty(SpecularCelMethod.prototype, \"smoothness\", {\n        /**\n         * The smoothness of the highlight edge.\n         */\n        get: function () {\n            return this._smoothness;\n        },\n        set: function (value) {\n            this._smoothness = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularCelMethod.prototype, \"specularCutOff\", {\n        /**\n         * The threshold at which the specular highlight should be shown.\n         */\n        get: function () {\n            return this._specularCutOff;\n        },\n        set: function (value) {\n            this._specularCutOff = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularCelMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        var data = shader.fragmentConstantData;\n        data[index] = this._smoothness;\n        data[index + 1] = this._specularCutOff;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCelMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._dataReg = null;\n    };\n    /**\n     * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff\n     * @param vo The MethodVO used to compile the current shader.\n     * @param t The register containing the specular strength in the \"w\" component, and either the half-vector or the reflection vector in \"xyz\".\n     * @param regCache The register cache used for the shader compilation.\n     * @param sharedRegisters The shared register data for this shader.\n     * @return The AGAL fragment code for the method.\n     */\n    SpecularCelMethod.prototype.clampSpecular = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n            \"div \" + targetReg + \".y, \" + targetReg + \".y, \" + this._dataReg + \".x\\n\" +\n            \"sat \" + targetReg + \".y, \" + targetReg + \".y\\n\" +\n            \"sge \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        this._dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;\n        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n    };\n    return SpecularCelMethod;\n}(SpecularCompositeMethod_1.SpecularCompositeMethod));\nexports.SpecularCelMethod = SpecularCelMethod;\n\n},{\"../methods/SpecularCompositeMethod\":\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar SpecularBasicMethod_1 = require(\"../methods/SpecularBasicMethod\");\n/**\n * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the\n * calculated specular reflection strength.\n */\nvar SpecularCompositeMethod = (function (_super) {\n    __extends(SpecularCompositeMethod, _super);\n    /**\n     * Creates a new <code>SpecularCompositeMethod</code> object.\n     *\n     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.\n     * @param baseMethod The base specular method on which this method's shading is based.\n     */\n    function SpecularCompositeMethod(modulateMethod, baseMethod) {\n        var _this = this;\n        if (baseMethod === void 0) { baseMethod = null; }\n        _super.call(this);\n        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };\n        this._baseMethod = baseMethod || new SpecularBasicMethod_1.SpecularBasicMethod();\n        this._baseMethod._iModulateMethod = modulateMethod;\n        this._baseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n    }\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iInitVO = function (shader, methodVO) {\n        this._baseMethod.iInitVO(shader, methodVO);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iInitConstants = function (shader, methodVO) {\n        this._baseMethod.iInitConstants(shader, methodVO);\n    };\n    SpecularCompositeMethod.prototype.iAddOwner = function (owner) {\n        _super.prototype.iAddOwner.call(this, owner);\n        this._baseMethod.iAddOwner(owner);\n    };\n    SpecularCompositeMethod.prototype.iRemoveOwner = function (owner) {\n        _super.prototype.iRemoveOwner.call(this, owner);\n        this._baseMethod.iRemoveOwner(owner);\n    };\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"baseMethod\", {\n        /**\n         * The base specular method on which this method's shading is based.\n         */\n        get: function () {\n            return this._baseMethod;\n        },\n        set: function (value) {\n            if (this._baseMethod == value)\n                return;\n            this._baseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this._baseMethod = value;\n            this._baseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"gloss\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.gloss;\n        },\n        set: function (value) {\n            this._baseMethod.gloss = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"strength\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.strength;\n        },\n        set: function (value) {\n            this._baseMethod.strength = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"color\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.color;\n        },\n        /**\n         * @inheritDoc\n         */\n        set: function (value) {\n            this._baseMethod.color = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.dispose = function () {\n        this._baseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n        this._baseMethod.dispose();\n    };\n    Object.defineProperty(SpecularCompositeMethod.prototype, \"texture\", {\n        /**\n         * @inheritDoc\n         */\n        get: function () {\n            return this._baseMethod.texture;\n        },\n        set: function (value) {\n            this._baseMethod.texture = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        this._baseMethod.iActivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {\n        this._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iDeactivate = function (shader, methodVO, stage) {\n        this._baseMethod.iDeactivate(shader, methodVO, stage);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     * @return\n     */\n    SpecularCompositeMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        return this._baseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iReset = function () {\n        this._baseMethod.iReset();\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularCompositeMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._baseMethod.iCleanCompilationData();\n    };\n    /**\n     * Called when the base method's shader code is invalidated.\n     */\n    SpecularCompositeMethod.prototype.onShaderInvalidated = function (event) {\n        this.iInvalidateShaderProgram();\n    };\n    return SpecularCompositeMethod;\n}(SpecularBasicMethod_1.SpecularBasicMethod));\nexports.SpecularCompositeMethod = SpecularCompositeMethod;\n\n},{\"../methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\",\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined}],\"awayjs-methodmaterials/lib/methods/SpecularFresnelMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar SpecularCompositeMethod_1 = require(\"../methods/SpecularCompositeMethod\");\n/**\n * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.\n */\nvar SpecularFresnelMethod = (function (_super) {\n    __extends(SpecularFresnelMethod, _super);\n    /**\n     * Creates a new SpecularFresnelMethod object.\n     * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n     * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.\n     */\n    function SpecularFresnelMethod(basedOnSurface, baseMethod) {\n        var _this = this;\n        if (basedOnSurface === void 0) { basedOnSurface = true; }\n        if (baseMethod === void 0) { baseMethod = null; }\n        // may want to offer diff speculars\n        _super.call(this, null, baseMethod);\n        this._fresnelPower = 5;\n        this._normalReflectance = .028; // default value for skin\n        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.modulateSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters); };\n        this._incidentLight = !basedOnSurface;\n    }\n    /**\n     * @inheritDoc\n     */\n    SpecularFresnelMethod.prototype.iInitConstants = function (shader, methodVO) {\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        shader.fragmentConstantData[index + 2] = 1;\n        shader.fragmentConstantData[index + 3] = 0;\n    };\n    Object.defineProperty(SpecularFresnelMethod.prototype, \"basedOnSurface\", {\n        /**\n         * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n         */\n        get: function () {\n            return !this._incidentLight;\n        },\n        set: function (value) {\n            if (this._incidentLight != value)\n                return;\n            this._incidentLight = !value;\n            this.iInvalidateShaderProgram();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecularFresnelMethod.prototype, \"fresnelPower\", {\n        /**\n         * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n         */\n        get: function () {\n            return this._fresnelPower;\n        },\n        set: function (value) {\n            this._fresnelPower = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularFresnelMethod.prototype.iCleanCompilationData = function () {\n        _super.prototype.iCleanCompilationData.call(this);\n        this._dataReg = null;\n    };\n    Object.defineProperty(SpecularFresnelMethod.prototype, \"normalReflectance\", {\n        /**\n         * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n         */\n        get: function () {\n            return this._normalReflectance;\n        },\n        set: function (value) {\n            this._normalReflectance = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SpecularFresnelMethod.prototype.iActivate = function (shader, methodVO, stage) {\n        _super.prototype.iActivate.call(this, shader, methodVO, stage);\n        var fragmentData = shader.fragmentConstantData;\n        var index = methodVO.secondaryFragmentConstantsIndex;\n        fragmentData[index] = this._normalReflectance;\n        fragmentData[index + 1] = this._fresnelPower;\n    };\n    /**\n     * @inheritDoc\n     */\n    SpecularFresnelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {\n        this._dataReg = registerCache.getFreeFragmentConstant();\n        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;\n        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);\n    };\n    /**\n     * Applies the fresnel effect to the specular strength.\n     *\n     * @param vo The MethodVO object containing the method data for the currently compiled material pass.\n     * @param target The register containing the specular strength in the \"w\" component, and the half-vector/reflection vector in \"xyz\".\n     * @param regCache The register cache used for the shader compilation.\n     * @param sharedRegisters The shared registers created by the compiler.\n     * @return The AGAL fragment code for the method.\n     */\n    SpecularFresnelMethod.prototype.modulateSpecular = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {\n        var code;\n        code = \"dp3 \" + targetReg + \".y, \" + sharedRegisters.viewDirFragment + \".xyz, \" + (this._incidentLight ? targetReg : sharedRegisters.normalFragment) + \".xyz\\n\" +\n            \"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +\n            \"pow \" + targetReg + \".x, \" + targetReg + \".y, \" + this._dataReg + \".y\\n\" +\n            \"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +\n            \"mul \" + targetReg + \".y, \" + this._dataReg + \".x, \" + targetReg + \".y\\n\" +\n            \"add \" + targetReg + \".y, \" + targetReg + \".x, \" + targetReg + \".y\\n\" +\n            \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n        return code;\n    };\n    return SpecularFresnelMethod;\n}(SpecularCompositeMethod_1.SpecularCompositeMethod));\nexports.SpecularFresnelMethod = SpecularFresnelMethod;\n\n},{\"../methods/SpecularCompositeMethod\":\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\"}],\"awayjs-methodmaterials/lib/methods/SpecularPhongMethod\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar SpecularBasicMethod_1 = require(\"../methods/SpecularBasicMethod\");\n/**\n * SpecularPhongMethod provides a specular method that provides Phong highlights.\n */\nvar SpecularPhongMethod = (function (_super) {\n    __extends(SpecularPhongMethod, _super);\n    /**\n     * Creates a new SpecularPhongMethod object.\n     */\n    function SpecularPhongMethod() {\n        _super.call(this);\n    }\n    /**\n     * @inheritDoc\n     */\n    SpecularPhongMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {\n        var code = \"\";\n        var t;\n        if (this._pIsFirstLight) {\n            t = this._pTotalLightColorReg;\n        }\n        else {\n            t = registerCache.getFreeFragmentVectorTemp();\n            registerCache.addFragmentTempUsages(t, 1);\n        }\n        var viewDirReg = sharedRegisters.viewDirFragment;\n        var normalReg = sharedRegisters.normalFragment;\n        // phong model\n        code += \"dp3 \" + t + \".w, \" + lightDirReg + \", \" + normalReg + \"\\n\" +\n            //find the reflected light vector R\n            \"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n            \"mul \" + t + \".xyz, \" + normalReg + \", \" + t + \".w\\n\" +\n            \"sub \" + t + \".xyz, \" + t + \", \" + lightDirReg + \"\\n\" +\n            //smooth the edge as incidence angle approaches 90\n            \"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".w\\n\" +\n            \"sat \" + t + \".w, \" + t + \".w\\n\" +\n            \"mul \" + t + \".xyz, \" + t + \", \" + t + \".w\\n\" +\n            //find the dot product between R and V\n            \"dp3 \" + t + \".w, \" + t + \", \" + viewDirReg + \"\\n\" +\n            \"sat \" + t + \".w, \" + t + \".w\\n\";\n        if (this.texture) {\n            // apply gloss modulation from texture\n            code += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n                \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n        }\n        else\n            code += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n        // attenuate\n        if (shader.usesLightFallOff)\n            code += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n        if (this._iModulateMethod != null)\n            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n        code += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n        if (!this._pIsFirstLight) {\n            code += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n            registerCache.removeFragmentTempUsage(t);\n        }\n        this._pIsFirstLight = false;\n        return code;\n    };\n    return SpecularPhongMethod;\n}(SpecularBasicMethod_1.SpecularBasicMethod));\nexports.SpecularPhongMethod = SpecularPhongMethod;\n\n},{\"../methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\"}],\"awayjs-methodmaterials/lib/methods\":[function(require,module,exports){\n\"use strict\";\nvar AmbientBasicMethod_1 = require(\"./methods/AmbientBasicMethod\");\nexports.AmbientBasicMethod = AmbientBasicMethod_1.AmbientBasicMethod;\nvar AmbientEnvMapMethod_1 = require(\"./methods/AmbientEnvMapMethod\");\nexports.AmbientEnvMapMethod = AmbientEnvMapMethod_1.AmbientEnvMapMethod;\nvar CurveBasicMethod_1 = require(\"./methods/CurveBasicMethod\");\nexports.CurveBasicMethod = CurveBasicMethod_1.CurveBasicMethod;\nvar DiffuseBasicMethod_1 = require(\"./methods/DiffuseBasicMethod\");\nexports.DiffuseBasicMethod = DiffuseBasicMethod_1.DiffuseBasicMethod;\nvar DiffuseCelMethod_1 = require(\"./methods/DiffuseCelMethod\");\nexports.DiffuseCelMethod = DiffuseCelMethod_1.DiffuseCelMethod;\nvar DiffuseCompositeMethod_1 = require(\"./methods/DiffuseCompositeMethod\");\nexports.DiffuseCompositeMethod = DiffuseCompositeMethod_1.DiffuseCompositeMethod;\nvar DiffuseDepthMethod_1 = require(\"./methods/DiffuseDepthMethod\");\nexports.DiffuseDepthMethod = DiffuseDepthMethod_1.DiffuseDepthMethod;\nvar DiffuseGradientMethod_1 = require(\"./methods/DiffuseGradientMethod\");\nexports.DiffuseGradientMethod = DiffuseGradientMethod_1.DiffuseGradientMethod;\nvar DiffuseLightMapMethod_1 = require(\"./methods/DiffuseLightMapMethod\");\nexports.DiffuseLightMapMethod = DiffuseLightMapMethod_1.DiffuseLightMapMethod;\nvar DiffuseSubSurfaceMethod_1 = require(\"./methods/DiffuseSubSurfaceMethod\");\nexports.DiffuseSubSurfaceMethod = DiffuseSubSurfaceMethod_1.DiffuseSubSurfaceMethod;\nvar DiffuseWrapMethod_1 = require(\"./methods/DiffuseWrapMethod\");\nexports.DiffuseWrapMethod = DiffuseWrapMethod_1.DiffuseWrapMethod;\nvar EffectAlphaMaskMethod_1 = require(\"./methods/EffectAlphaMaskMethod\");\nexports.EffectAlphaMaskMethod = EffectAlphaMaskMethod_1.EffectAlphaMaskMethod;\nvar EffectColorMatrixMethod_1 = require(\"./methods/EffectColorMatrixMethod\");\nexports.EffectColorMatrixMethod = EffectColorMatrixMethod_1.EffectColorMatrixMethod;\nvar EffectColorTransformMethod_1 = require(\"./methods/EffectColorTransformMethod\");\nexports.EffectColorTransformMethod = EffectColorTransformMethod_1.EffectColorTransformMethod;\nvar EffectEnvMapMethod_1 = require(\"./methods/EffectEnvMapMethod\");\nexports.EffectEnvMapMethod = EffectEnvMapMethod_1.EffectEnvMapMethod;\nvar EffectFogMethod_1 = require(\"./methods/EffectFogMethod\");\nexports.EffectFogMethod = EffectFogMethod_1.EffectFogMethod;\nvar EffectFresnelEnvMapMethod_1 = require(\"./methods/EffectFresnelEnvMapMethod\");\nexports.EffectFresnelEnvMapMethod = EffectFresnelEnvMapMethod_1.EffectFresnelEnvMapMethod;\nvar EffectLightMapMethod_1 = require(\"./methods/EffectLightMapMethod\");\nexports.EffectLightMapMethod = EffectLightMapMethod_1.EffectLightMapMethod;\nvar EffectMethodBase_1 = require(\"./methods/EffectMethodBase\");\nexports.EffectMethodBase = EffectMethodBase_1.EffectMethodBase;\nvar EffectRefractionEnvMapMethod_1 = require(\"./methods/EffectRefractionEnvMapMethod\");\nexports.EffectRefractionEnvMapMethod = EffectRefractionEnvMapMethod_1.EffectRefractionEnvMapMethod;\nvar EffectRimLightMethod_1 = require(\"./methods/EffectRimLightMethod\");\nexports.EffectRimLightMethod = EffectRimLightMethod_1.EffectRimLightMethod;\nvar LightingMethodBase_1 = require(\"./methods/LightingMethodBase\");\nexports.LightingMethodBase = LightingMethodBase_1.LightingMethodBase;\nvar NormalBasicMethod_1 = require(\"./methods/NormalBasicMethod\");\nexports.NormalBasicMethod = NormalBasicMethod_1.NormalBasicMethod;\nvar NormalHeightMapMethod_1 = require(\"./methods/NormalHeightMapMethod\");\nexports.NormalHeightMapMethod = NormalHeightMapMethod_1.NormalHeightMapMethod;\nvar NormalSimpleWaterMethod_1 = require(\"./methods/NormalSimpleWaterMethod\");\nexports.NormalSimpleWaterMethod = NormalSimpleWaterMethod_1.NormalSimpleWaterMethod;\nvar ShadingMethodBase_1 = require(\"./methods/ShadingMethodBase\");\nexports.ShadingMethodBase = ShadingMethodBase_1.ShadingMethodBase;\nvar ShadowCascadeMethod_1 = require(\"./methods/ShadowCascadeMethod\");\nexports.ShadowCascadeMethod = ShadowCascadeMethod_1.ShadowCascadeMethod;\nvar ShadowDitheredMethod_1 = require(\"./methods/ShadowDitheredMethod\");\nexports.ShadowDitheredMethod = ShadowDitheredMethod_1.ShadowDitheredMethod;\nvar ShadowFilteredMethod_1 = require(\"./methods/ShadowFilteredMethod\");\nexports.ShadowFilteredMethod = ShadowFilteredMethod_1.ShadowFilteredMethod;\nvar ShadowHardMethod_1 = require(\"./methods/ShadowHardMethod\");\nexports.ShadowHardMethod = ShadowHardMethod_1.ShadowHardMethod;\nvar ShadowMapMethodBase_1 = require(\"./methods/ShadowMapMethodBase\");\nexports.ShadowMapMethodBase = ShadowMapMethodBase_1.ShadowMapMethodBase;\nvar ShadowMethodBase_1 = require(\"./methods/ShadowMethodBase\");\nexports.ShadowMethodBase = ShadowMethodBase_1.ShadowMethodBase;\nvar ShadowNearMethod_1 = require(\"./methods/ShadowNearMethod\");\nexports.ShadowNearMethod = ShadowNearMethod_1.ShadowNearMethod;\nvar ShadowSoftMethod_1 = require(\"./methods/ShadowSoftMethod\");\nexports.ShadowSoftMethod = ShadowSoftMethod_1.ShadowSoftMethod;\nvar SpecularAnisotropicMethod_1 = require(\"./methods/SpecularAnisotropicMethod\");\nexports.SpecularAnisotropicMethod = SpecularAnisotropicMethod_1.SpecularAnisotropicMethod;\nvar SpecularBasicMethod_1 = require(\"./methods/SpecularBasicMethod\");\nexports.SpecularBasicMethod = SpecularBasicMethod_1.SpecularBasicMethod;\nvar SpecularCelMethod_1 = require(\"./methods/SpecularCelMethod\");\nexports.SpecularCelMethod = SpecularCelMethod_1.SpecularCelMethod;\nvar SpecularCompositeMethod_1 = require(\"./methods/SpecularCompositeMethod\");\nexports.SpecularCompositeMethod = SpecularCompositeMethod_1.SpecularCompositeMethod;\nvar SpecularFresnelMethod_1 = require(\"./methods/SpecularFresnelMethod\");\nexports.SpecularFresnelMethod = SpecularFresnelMethod_1.SpecularFresnelMethod;\nvar SpecularPhongMethod_1 = require(\"./methods/SpecularPhongMethod\");\nexports.SpecularPhongMethod = SpecularPhongMethod_1.SpecularPhongMethod;\n\n},{\"./methods/AmbientBasicMethod\":\"awayjs-methodmaterials/lib/methods/AmbientBasicMethod\",\"./methods/AmbientEnvMapMethod\":\"awayjs-methodmaterials/lib/methods/AmbientEnvMapMethod\",\"./methods/CurveBasicMethod\":\"awayjs-methodmaterials/lib/methods/CurveBasicMethod\",\"./methods/DiffuseBasicMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseBasicMethod\",\"./methods/DiffuseCelMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCelMethod\",\"./methods/DiffuseCompositeMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseCompositeMethod\",\"./methods/DiffuseDepthMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseDepthMethod\",\"./methods/DiffuseGradientMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseGradientMethod\",\"./methods/DiffuseLightMapMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseLightMapMethod\",\"./methods/DiffuseSubSurfaceMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseSubSurfaceMethod\",\"./methods/DiffuseWrapMethod\":\"awayjs-methodmaterials/lib/methods/DiffuseWrapMethod\",\"./methods/EffectAlphaMaskMethod\":\"awayjs-methodmaterials/lib/methods/EffectAlphaMaskMethod\",\"./methods/EffectColorMatrixMethod\":\"awayjs-methodmaterials/lib/methods/EffectColorMatrixMethod\",\"./methods/EffectColorTransformMethod\":\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\",\"./methods/EffectEnvMapMethod\":\"awayjs-methodmaterials/lib/methods/EffectEnvMapMethod\",\"./methods/EffectFogMethod\":\"awayjs-methodmaterials/lib/methods/EffectFogMethod\",\"./methods/EffectFresnelEnvMapMethod\":\"awayjs-methodmaterials/lib/methods/EffectFresnelEnvMapMethod\",\"./methods/EffectLightMapMethod\":\"awayjs-methodmaterials/lib/methods/EffectLightMapMethod\",\"./methods/EffectMethodBase\":\"awayjs-methodmaterials/lib/methods/EffectMethodBase\",\"./methods/EffectRefractionEnvMapMethod\":\"awayjs-methodmaterials/lib/methods/EffectRefractionEnvMapMethod\",\"./methods/EffectRimLightMethod\":\"awayjs-methodmaterials/lib/methods/EffectRimLightMethod\",\"./methods/LightingMethodBase\":\"awayjs-methodmaterials/lib/methods/LightingMethodBase\",\"./methods/NormalBasicMethod\":\"awayjs-methodmaterials/lib/methods/NormalBasicMethod\",\"./methods/NormalHeightMapMethod\":\"awayjs-methodmaterials/lib/methods/NormalHeightMapMethod\",\"./methods/NormalSimpleWaterMethod\":\"awayjs-methodmaterials/lib/methods/NormalSimpleWaterMethod\",\"./methods/ShadingMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadingMethodBase\",\"./methods/ShadowCascadeMethod\":\"awayjs-methodmaterials/lib/methods/ShadowCascadeMethod\",\"./methods/ShadowDitheredMethod\":\"awayjs-methodmaterials/lib/methods/ShadowDitheredMethod\",\"./methods/ShadowFilteredMethod\":\"awayjs-methodmaterials/lib/methods/ShadowFilteredMethod\",\"./methods/ShadowHardMethod\":\"awayjs-methodmaterials/lib/methods/ShadowHardMethod\",\"./methods/ShadowMapMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMapMethodBase\",\"./methods/ShadowMethodBase\":\"awayjs-methodmaterials/lib/methods/ShadowMethodBase\",\"./methods/ShadowNearMethod\":\"awayjs-methodmaterials/lib/methods/ShadowNearMethod\",\"./methods/ShadowSoftMethod\":\"awayjs-methodmaterials/lib/methods/ShadowSoftMethod\",\"./methods/SpecularAnisotropicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularAnisotropicMethod\",\"./methods/SpecularBasicMethod\":\"awayjs-methodmaterials/lib/methods/SpecularBasicMethod\",\"./methods/SpecularCelMethod\":\"awayjs-methodmaterials/lib/methods/SpecularCelMethod\",\"./methods/SpecularCompositeMethod\":\"awayjs-methodmaterials/lib/methods/SpecularCompositeMethod\",\"./methods/SpecularFresnelMethod\":\"awayjs-methodmaterials/lib/methods/SpecularFresnelMethod\",\"./methods/SpecularPhongMethod\":\"awayjs-methodmaterials/lib/methods/SpecularPhongMethod\"}],\"awayjs-methodmaterials/lib/surfaces/GL_MethodMaterialSurface\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar BlendMode_1 = require(\"awayjs-core/lib/image/BlendMode\");\nvar StaticLightPicker_1 = require(\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\");\nvar ContextGLCompareMode_1 = require(\"awayjs-stagegl/lib/base/ContextGLCompareMode\");\nvar GL_SurfaceBase_1 = require(\"awayjs-renderergl/lib/surfaces/GL_SurfaceBase\");\nvar MethodMaterialMode_1 = require(\"../MethodMaterialMode\");\nvar MethodPassMode_1 = require(\"../surfaces/passes/MethodPassMode\");\nvar MethodPass_1 = require(\"../surfaces/passes/MethodPass\");\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nvar GL_MethodMaterialSurface = (function (_super) {\n    __extends(GL_MethodMaterialSurface, _super);\n    /**\n     * Creates a new CompiledPass object.\n     *\n     * @param material The material to which this pass belongs.\n     */\n    function GL_MethodMaterialSurface(material, elementsClass, pool) {\n        _super.call(this, material, elementsClass, pool);\n        this._material = material;\n    }\n    Object.defineProperty(GL_MethodMaterialSurface.prototype, \"numLights\", {\n        /**\n         * The maximum total number of lights provided by the light picker.\n         */\n        get: function () {\n            return this._material.lightPicker ? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights + this._material.lightPicker.numCastingDirectionalLights + this._material.lightPicker.numCastingPointLights : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GL_MethodMaterialSurface.prototype, \"numNonCasters\", {\n        /**\n         * The amount of lights that don't cast shadows.\n         */\n        get: function () {\n            return this._material.lightPicker ? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    GL_MethodMaterialSurface.prototype._pUpdateRender = function () {\n        _super.prototype._pUpdateRender.call(this);\n        this.initPasses();\n        this.setBlendAndCompareModes();\n        this._pClearPasses();\n        if (this._material.mode == MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS) {\n            if (this._casterLightPass)\n                this._pAddPass(this._casterLightPass);\n            if (this._nonCasterLightPasses)\n                for (var i = 0; i < this._nonCasterLightPasses.length; ++i)\n                    this._pAddPass(this._nonCasterLightPasses[i]);\n        }\n        if (this._pass)\n            this._pAddPass(this._pass);\n    };\n    /**\n     * Initializes all the passes and their dependent passes.\n     */\n    GL_MethodMaterialSurface.prototype.initPasses = function () {\n        // let the effects pass handle everything if there are no lights, when there are effect methods applied\n        // after shading, or when the material mode is single pass.\n        if (this.numLights == 0 || this._material.numEffectMethods > 0 || this._material.mode == MethodMaterialMode_1.MethodMaterialMode.SINGLE_PASS)\n            this.initEffectPass();\n        else if (this._pass)\n            this.removeEffectPass();\n        // only use a caster light pass if shadows need to be rendered\n        if (this._material.shadowMethod && this._material.mode == MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS)\n            this.initCasterLightPass();\n        else if (this._casterLightPass)\n            this.removeCasterLightPass();\n        // only use non caster light passes if there are lights that don't cast\n        if (this.numNonCasters > 0 && this._material.mode == MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS)\n            this.initNonCasterLightPasses();\n        else if (this._nonCasterLightPasses)\n            this.removeNonCasterLightPasses();\n    };\n    /**\n     * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.\n     */\n    GL_MethodMaterialSurface.prototype.setBlendAndCompareModes = function () {\n        var forceSeparateMVP = Boolean(this._casterLightPass || this._pass);\n        // caster light pass is always first if it exists, hence it uses normal blending\n        if (this._casterLightPass) {\n            this._casterLightPass.forceSeparateMVP = forceSeparateMVP;\n            this._casterLightPass.shader.setBlendMode(BlendMode_1.BlendMode.NORMAL);\n            this._casterLightPass.shader.depthCompareMode = this._material.depthCompareMode;\n        }\n        if (this._nonCasterLightPasses) {\n            var firstAdditiveIndex = 0;\n            // if there's no caster light pass, the first non caster light pass will be the first\n            // and should use normal blending\n            if (!this._casterLightPass) {\n                this._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;\n                this._nonCasterLightPasses[0].shader.setBlendMode(BlendMode_1.BlendMode.NORMAL);\n                this._nonCasterLightPasses[0].shader.depthCompareMode = this._material.depthCompareMode;\n                firstAdditiveIndex = 1;\n            }\n            // all lighting passes following the first light pass should use additive blending\n            for (var i = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {\n                this._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;\n                this._nonCasterLightPasses[i].shader.setBlendMode(BlendMode_1.BlendMode.ADD);\n                this._nonCasterLightPasses[i].shader.depthCompareMode = ContextGLCompareMode_1.ContextGLCompareMode.LESS_EQUAL;\n            }\n        }\n        if (this._casterLightPass || this._nonCasterLightPasses) {\n            //cannot be blended by blendmode property if multipass enabled\n            this._pRequiresBlending = false;\n            // there are light passes, so this should be blended in\n            if (this._pass) {\n                this._pass.mode = MethodPassMode_1.MethodPassMode.EFFECTS;\n                this._pass.forceSeparateMVP = forceSeparateMVP;\n                this._pass.shader.depthCompareMode = ContextGLCompareMode_1.ContextGLCompareMode.LESS_EQUAL;\n                this._pass.shader.setBlendMode(BlendMode_1.BlendMode.LAYER);\n            }\n        }\n        else if (this._pass) {\n            this._pRequiresBlending = (this._material.blendMode != BlendMode_1.BlendMode.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));\n            // effects pass is the only pass, so it should just blend normally\n            this._pass.mode = MethodPassMode_1.MethodPassMode.SUPER_SHADER;\n            this._pass.preserveAlpha = this._pRequiresBlending;\n            this._pass.forceSeparateMVP = false;\n            this._pass.colorTransform = this._material.colorTransform;\n            this._pass.shader.setBlendMode((this._material.blendMode == BlendMode_1.BlendMode.NORMAL && this._pRequiresBlending) ? BlendMode_1.BlendMode.LAYER : this._material.blendMode);\n            this._pass.shader.depthCompareMode = this._material.depthCompareMode;\n        }\n    };\n    GL_MethodMaterialSurface.prototype.initCasterLightPass = function () {\n        if (this._casterLightPass == null)\n            this._casterLightPass = new MethodPass_1.MethodPass(MethodPassMode_1.MethodPassMode.LIGHTING, this, this._material, this._elementsClass, this._stage);\n        this._casterLightPass.lightPicker = new StaticLightPicker_1.StaticLightPicker([this._material.shadowMethod.castingLight]);\n        this._casterLightPass.shadowMethod = this._material.shadowMethod;\n        this._casterLightPass.diffuseMethod = this._material.diffuseMethod;\n        this._casterLightPass.ambientMethod = this._material.ambientMethod;\n        this._casterLightPass.normalMethod = this._material.normalMethod;\n        this._casterLightPass.specularMethod = this._material.specularMethod;\n    };\n    GL_MethodMaterialSurface.prototype.removeCasterLightPass = function () {\n        this._casterLightPass.dispose();\n        this._pRemovePass(this._casterLightPass);\n        this._casterLightPass = null;\n    };\n    GL_MethodMaterialSurface.prototype.initNonCasterLightPasses = function () {\n        this.removeNonCasterLightPasses();\n        var pass;\n        var numDirLights = this._material.lightPicker.numDirectionalLights;\n        var numPointLights = this._material.lightPicker.numPointLights;\n        var numLightProbes = this._material.lightPicker.numLightProbes;\n        var dirLightOffset = 0;\n        var pointLightOffset = 0;\n        var probeOffset = 0;\n        if (!this._casterLightPass) {\n            numDirLights += this._material.lightPicker.numCastingDirectionalLights;\n            numPointLights += this._material.lightPicker.numCastingPointLights;\n        }\n        this._nonCasterLightPasses = new Array();\n        while (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {\n            pass = new MethodPass_1.MethodPass(MethodPassMode_1.MethodPassMode.LIGHTING, this, this._material, this._elementsClass, this._stage);\n            pass.includeCasters = this._material.shadowMethod == null;\n            pass.directionalLightsOffset = dirLightOffset;\n            pass.pointLightsOffset = pointLightOffset;\n            pass.lightProbesOffset = probeOffset;\n            pass.lightPicker = this._material.lightPicker;\n            pass.diffuseMethod = this._material.diffuseMethod;\n            pass.ambientMethod = this._material.ambientMethod;\n            pass.normalMethod = this._material.normalMethod;\n            pass.specularMethod = this._material.specularMethod;\n            this._nonCasterLightPasses.push(pass);\n            dirLightOffset += pass.numDirectionalLights;\n            pointLightOffset += pass.numPointLights;\n            probeOffset += pass.numLightProbes;\n        }\n    };\n    GL_MethodMaterialSurface.prototype.removeNonCasterLightPasses = function () {\n        if (!this._nonCasterLightPasses)\n            return;\n        for (var i = 0; i < this._nonCasterLightPasses.length; ++i)\n            this._pRemovePass(this._nonCasterLightPasses[i]);\n        this._nonCasterLightPasses = null;\n    };\n    GL_MethodMaterialSurface.prototype.removeEffectPass = function () {\n        if (this._pass.ambientMethod != this._material.ambientMethod)\n            this._pass.ambientMethod.dispose();\n        if (this._pass.diffuseMethod != this._material.diffuseMethod)\n            this._pass.diffuseMethod.dispose();\n        if (this._pass.specularMethod != this._material.specularMethod)\n            this._pass.specularMethod.dispose();\n        if (this._pass.normalMethod != this._material.normalMethod)\n            this._pass.normalMethod.dispose();\n        this._pRemovePass(this._pass);\n        this._pass = null;\n    };\n    GL_MethodMaterialSurface.prototype.initEffectPass = function () {\n        if (this._pass == null)\n            this._pass = new MethodPass_1.MethodPass(MethodPassMode_1.MethodPassMode.SUPER_SHADER, this, this._material, this._elementsClass, this._stage);\n        if (this._material.mode == MethodMaterialMode_1.MethodMaterialMode.SINGLE_PASS) {\n            this._pass.ambientMethod = this._material.ambientMethod;\n            this._pass.diffuseMethod = this._material.diffuseMethod;\n            this._pass.specularMethod = this._material.specularMethod;\n            this._pass.normalMethod = this._material.normalMethod;\n            this._pass.shadowMethod = this._material.shadowMethod;\n        }\n        else if (this._material.mode == MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS) {\n            if (this.numLights == 0) {\n                this._pass.ambientMethod = this._material.ambientMethod;\n            }\n            else {\n                this._pass.ambientMethod = null;\n            }\n            this._pass.preserveAlpha = false;\n            this._pass.normalMethod = this._material.normalMethod;\n        }\n        //update effect methods\n        var i = 0;\n        var effectMethod;\n        var len = Math.max(this._material.numEffectMethods, this._pass.numEffectMethods);\n        while (i < len) {\n            effectMethod = this._material.getEffectMethodAt(i);\n            if (effectMethod != this._pass.getEffectMethodAt(i)) {\n                this._pass.removeEffectMethodAt(i);\n                if (effectMethod != null) {\n                    if (i < this._pass.numEffectMethods)\n                        this._pass.addEffectMethodAt(effectMethod, i);\n                    else\n                        this._pass.addEffectMethod(effectMethod);\n                }\n            }\n            i++;\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    GL_MethodMaterialSurface.prototype.onClear = function (event) {\n        _super.prototype.onClear.call(this, event);\n        //TODO\n    };\n    return GL_MethodMaterialSurface;\n}(GL_SurfaceBase_1.GL_SurfaceBase));\nexports.GL_MethodMaterialSurface = GL_MethodMaterialSurface;\n\n},{\"../MethodMaterialMode\":\"awayjs-methodmaterials/lib/MethodMaterialMode\",\"../surfaces/passes/MethodPass\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\",\"../surfaces/passes/MethodPassMode\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\",\"awayjs-core/lib/image/BlendMode\":undefined,\"awayjs-display/lib/materials/lightpickers/StaticLightPicker\":undefined,\"awayjs-renderergl/lib/surfaces/GL_SurfaceBase\":undefined,\"awayjs-stagegl/lib/base/ContextGLCompareMode\":undefined}],\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\":[function(require,module,exports){\n\"use strict\";\nvar MethodPassMode = (function () {\n    function MethodPassMode() {\n    }\n    /**\n     *\n     */\n    MethodPassMode.EFFECTS = 0x01;\n    /**\n     *\n     */\n    MethodPassMode.LIGHTING = 0x02;\n    /**\n     *\n     */\n    MethodPassMode.SUPER_SHADER = 0x03;\n    return MethodPassMode;\n}());\nexports.MethodPassMode = MethodPassMode;\n\n},{}],\"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AssetEvent_1 = require(\"awayjs-core/lib/events/AssetEvent\");\nvar LightSources_1 = require(\"awayjs-display/lib/materials/LightSources\");\nvar LightingShader_1 = require(\"awayjs-renderergl/lib/shaders/LightingShader\");\nvar ShadingMethodEvent_1 = require(\"awayjs-renderergl/lib/events/ShadingMethodEvent\");\nvar ShaderBase_1 = require(\"awayjs-renderergl/lib/shaders/ShaderBase\");\nvar PassBase_1 = require(\"awayjs-renderergl/lib/surfaces/passes/PassBase\");\nvar MethodVO_1 = require(\"../../data/MethodVO\");\nvar EffectColorTransformMethod_1 = require(\"../../methods/EffectColorTransformMethod\");\nvar MethodPassMode_1 = require(\"../../surfaces/passes/MethodPassMode\");\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nvar MethodPass = (function (_super) {\n    __extends(MethodPass, _super);\n    /**\n     * Creates a new CompiledPass object.\n     *\n     * @param material The material to which this pass belongs.\n     */\n    function MethodPass(mode, render, renderOwner, elementsClass, stage) {\n        var _this = this;\n        _super.call(this, render, renderOwner, elementsClass, stage);\n        this._maxLights = 3;\n        this._mode = 0x03;\n        this._includeCasters = true;\n        this._iMethodVOs = new Array();\n        this._numEffectDependencies = 0;\n        this.numDirectionalLights = 0;\n        this.numPointLights = 0;\n        this.numLightProbes = 0;\n        this.pointLightsOffset = 0;\n        this.directionalLightsOffset = 0;\n        this.lightProbesOffset = 0;\n        this._mode = mode;\n        this._material = renderOwner;\n        this._onLightsChangeDelegate = function (event) { return _this.onLightsChange(event); };\n        this._onMethodInvalidatedDelegate = function (event) { return _this.onMethodInvalidated(event); };\n        this.lightPicker = renderOwner.lightPicker;\n        if (this._shader == null)\n            this._updateShader();\n    }\n    Object.defineProperty(MethodPass.prototype, \"mode\", {\n        /**\n         *\n         */\n        get: function () {\n            return this._mode;\n        },\n        set: function (value) {\n            if (this._mode == value)\n                return;\n            this._mode = value;\n            this._updateLights();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"includeCasters\", {\n        /**\n         * Indicates whether or not shadow casting lights need to be included.\n         */\n        get: function () {\n            return this._includeCasters;\n        },\n        set: function (value) {\n            if (this._includeCasters == value)\n                return;\n            this._includeCasters = value;\n            this._updateLights();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"lightPicker\", {\n        /**\n         *\n         * @returns {LightPickerBase}\n         */\n        get: function () {\n            return this._lightPicker;\n        },\n        set: function (value) {\n            //if (this._lightPicker == value)\n            //\treturn;\n            if (this._lightPicker)\n                this._lightPicker.removeEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n            this._lightPicker = value;\n            if (this._lightPicker)\n                this._lightPicker.addEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n            this._updateLights();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"enableLightFallOff\", {\n        /**\n         * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and\n         * compatibility for constrained mode.\n         */\n        get: function () {\n            return this._material.enableLightFallOff;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"diffuseLightSources\", {\n        /**\n         * Define which light source types to use for diffuse reflections. This allows choosing between regular lights\n         * and/or light probes for diffuse reflections.\n         *\n         * @see away3d.materials.LightSources\n         */\n        get: function () {\n            return this._material.diffuseLightSources;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"specularLightSources\", {\n        /**\n         * Define which light source types to use for specular reflections. This allows choosing between regular lights\n         * and/or light probes for specular reflections.\n         *\n         * @see away3d.materials.LightSources\n         */\n        get: function () {\n            return this._material.specularLightSources;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MethodPass.prototype._updateShader = function () {\n        if ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof LightingShader_1.LightingShader)) {\n            if (this._shader != null)\n                this._shader.dispose();\n            this._shader = new LightingShader_1.LightingShader(this._elementsClass, this, this._stage);\n        }\n        else if (!(this._shader instanceof ShaderBase_1.ShaderBase)) {\n            if (this._shader != null)\n                this._shader.dispose();\n            this._shader = new ShaderBase_1.ShaderBase(this._elementsClass, this, this._stage);\n        }\n    };\n    /**\n     * Initializes the unchanging constant data for this material.\n     */\n    MethodPass.prototype._iInitConstantData = function (shader) {\n        _super.prototype._iInitConstantData.call(this, shader);\n        //Updates method constants if they have changed.\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i)\n            this._iMethodVOs[i].method.iInitConstants(shader, this._iMethodVOs[i]);\n    };\n    Object.defineProperty(MethodPass.prototype, \"colorTransform\", {\n        /**\n         * The ColorTransform object to transform the colour of the material with. Defaults to null.\n         */\n        get: function () {\n            return this.colorTransformMethod ? this.colorTransformMethod.colorTransform : null;\n        },\n        set: function (value) {\n            if (value) {\n                if (this.colorTransformMethod == null)\n                    this.colorTransformMethod = new EffectColorTransformMethod_1.EffectColorTransformMethod();\n                this.colorTransformMethod.colorTransform = value;\n            }\n            else if (!value) {\n                if (this.colorTransformMethod)\n                    this.colorTransformMethod = null;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"colorTransformMethod\", {\n        /**\n         * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.\n         */\n        get: function () {\n            return this._iColorTransformMethodVO ? this._iColorTransformMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)\n                return;\n            if (this._iColorTransformMethodVO) {\n                this._removeDependency(this._iColorTransformMethodVO);\n                this._iColorTransformMethodVO = null;\n            }\n            if (value) {\n                this._iColorTransformMethodVO = new MethodVO_1.MethodVO(value, this);\n                this._addDependency(this._iColorTransformMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MethodPass.prototype._removeDependency = function (methodVO, effectsDependency) {\n        if (effectsDependency === void 0) { effectsDependency = false; }\n        var index = this._iMethodVOs.indexOf(methodVO);\n        if (!effectsDependency)\n            this._numEffectDependencies--;\n        methodVO.method.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n        this._iMethodVOs.splice(index, 1);\n        this.invalidate();\n    };\n    MethodPass.prototype._addDependency = function (methodVO, effectsDependency, index) {\n        if (effectsDependency === void 0) { effectsDependency = false; }\n        if (index === void 0) { index = -1; }\n        methodVO.method.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n        if (effectsDependency) {\n            if (index != -1)\n                this._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n            else\n                this._iMethodVOs.push(methodVO);\n            this._numEffectDependencies++;\n        }\n        else {\n            this._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n        }\n        this.invalidate();\n    };\n    /**\n     * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n     * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n     * methods added prior.\n     */\n    MethodPass.prototype.addEffectMethod = function (method) {\n        this._addDependency(new MethodVO_1.MethodVO(method, this), true);\n    };\n    Object.defineProperty(MethodPass.prototype, \"numEffectMethods\", {\n        /**\n         * The number of \"effect\" methods added to the material.\n         */\n        get: function () {\n            return this._numEffectDependencies;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Queries whether a given effects method was added to the material.\n     *\n     * @param method The method to be queried.\n     * @return true if the method was added to the material, false otherwise.\n     */\n    MethodPass.prototype.hasEffectMethod = function (method) {\n        return this.getDependencyForMethod(method) != null;\n    };\n    /**\n     * Returns the method added at the given index.\n     * @param index The index of the method to retrieve.\n     * @return The method at the given index.\n     */\n    MethodPass.prototype.getEffectMethodAt = function (index) {\n        if (index < 0 || index > this._numEffectDependencies - 1)\n            return null;\n        return this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;\n    };\n    /**\n     * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n     * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n     * etc. The method will be applied to the result of the methods with a lower index.\n     */\n    MethodPass.prototype.addEffectMethodAt = function (method, index) {\n        this._addDependency(new MethodVO_1.MethodVO(method, this), true, index);\n    };\n    /**\n     * Removes an effect method from the material.\n     * @param method The method to be removed.\n     */\n    MethodPass.prototype.removeEffectMethod = function (method) {\n        var methodVO = this.getDependencyForMethod(method);\n        if (methodVO != null)\n            this._removeDependency(methodVO, true);\n    };\n    /**\n     * remove an effect method at the specified index from the material.\n     */\n    MethodPass.prototype.removeEffectMethodAt = function (index) {\n        if (index < 0 || index > this._numEffectDependencies - 1)\n            return;\n        var methodVO = this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies];\n        if (methodVO != null)\n            this._removeDependency(methodVO, true);\n    };\n    MethodPass.prototype.getDependencyForMethod = function (method) {\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i)\n            if (this._iMethodVOs[i].method == method)\n                return this._iMethodVOs[i];\n        return null;\n    };\n    Object.defineProperty(MethodPass.prototype, \"normalMethod\", {\n        /**\n         * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n         */\n        get: function () {\n            return this._iNormalMethodVO ? this._iNormalMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iNormalMethodVO && this._iNormalMethodVO.method == value)\n                return;\n            if (this._iNormalMethodVO) {\n                this._removeDependency(this._iNormalMethodVO);\n                this._iNormalMethodVO = null;\n            }\n            if (value) {\n                this._iNormalMethodVO = new MethodVO_1.MethodVO(value, this);\n                this._addDependency(this._iNormalMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"ambientMethod\", {\n        /**\n         * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n         */\n        get: function () {\n            return this._iAmbientMethodVO ? this._iAmbientMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)\n                return;\n            if (this._iAmbientMethodVO) {\n                this._removeDependency(this._iAmbientMethodVO);\n                this._iAmbientMethodVO = null;\n            }\n            if (value) {\n                this._iAmbientMethodVO = new MethodVO_1.MethodVO(value, this);\n                this._addDependency(this._iAmbientMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"shadowMethod\", {\n        /**\n         * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n         */\n        get: function () {\n            return this._iShadowMethodVO ? this._iShadowMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iShadowMethodVO && this._iShadowMethodVO.method == value)\n                return;\n            if (this._iShadowMethodVO) {\n                this._removeDependency(this._iShadowMethodVO);\n                this._iShadowMethodVO = null;\n            }\n            if (value) {\n                this._iShadowMethodVO = new MethodVO_1.MethodVO(value, this);\n                this._addDependency(this._iShadowMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"diffuseMethod\", {\n        /**\n         * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n         */\n        get: function () {\n            return this._iDiffuseMethodVO ? this._iDiffuseMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)\n                return;\n            if (this._iDiffuseMethodVO) {\n                this._removeDependency(this._iDiffuseMethodVO);\n                this._iDiffuseMethodVO = null;\n            }\n            if (value) {\n                this._iDiffuseMethodVO = new MethodVO_1.MethodVO(value, this);\n                this._addDependency(this._iDiffuseMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MethodPass.prototype, \"specularMethod\", {\n        /**\n         * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n         */\n        get: function () {\n            return this._iSpecularMethodVO ? this._iSpecularMethodVO.method : null;\n        },\n        set: function (value) {\n            if (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)\n                return;\n            if (this._iSpecularMethodVO) {\n                this._removeDependency(this._iSpecularMethodVO);\n                this._iSpecularMethodVO = null;\n            }\n            if (value) {\n                this._iSpecularMethodVO = new MethodVO_1.MethodVO(value, this);\n                this._addDependency(this._iSpecularMethodVO);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype.dispose = function () {\n        if (this._lightPicker)\n            this._lightPicker.removeEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n        while (this._iMethodVOs.length)\n            this._removeDependency(this._iMethodVOs[0]);\n        _super.prototype.dispose.call(this);\n        this._iMethodVOs = null;\n    };\n    /**\n     * Called when any method's shader code is invalidated.\n     */\n    MethodPass.prototype.onMethodInvalidated = function (event) {\n        this.invalidate();\n    };\n    // RENDER LOOP\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype._iActivate = function (camera) {\n        _super.prototype._iActivate.call(this, camera);\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod)\n                methodVO.method.iActivate(this._shader, methodVO, this._stage);\n        }\n    };\n    /**\n     *\n     *\n     * @param renderable\n     * @param stage\n     * @param camera\n     */\n    MethodPass.prototype._setRenderState = function (renderable, camera, viewProjection) {\n        _super.prototype._setRenderState.call(this, renderable, camera, viewProjection);\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod)\n                methodVO.method.iSetRenderState(this._shader, methodVO, renderable, this._stage, camera);\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype._iDeactivate = function () {\n        _super.prototype._iDeactivate.call(this);\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = 0; i < len; ++i) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod)\n                methodVO.method.iDeactivate(this._shader, methodVO, this._stage);\n        }\n    };\n    MethodPass.prototype._iIncludeDependencies = function (shader) {\n        _super.prototype._iIncludeDependencies.call(this, shader);\n        //TODO: fragment animtion should be compatible with lighting pass\n        shader.usesFragmentAnimation = Boolean(this._mode == MethodPassMode_1.MethodPassMode.SUPER_SHADER);\n        if (shader.useAlphaPremultiplied && shader.usesBlending)\n            shader.usesCommonData = true;\n        var i;\n        var len = this._iMethodVOs.length;\n        for (i = 0; i < len; ++i)\n            this.setupAndCountDependencies(shader, this._iMethodVOs[i]);\n        var usesTangentSpace = true;\n        var methodVO;\n        for (i = 0; i < len; ++i) {\n            methodVO = this._iMethodVOs[i];\n            if ((methodVO.useMethod = methodVO.method.iIsUsed(shader)) && !methodVO.method.iUsesTangentSpace())\n                usesTangentSpace = false;\n        }\n        shader.outputsNormals = this._iNormalMethodVO && this._iNormalMethodVO.useMethod;\n        shader.outputsTangentNormals = shader.outputsNormals && this._iNormalMethodVO.method.iOutputsTangentNormals();\n        shader.usesTangentSpace = shader.outputsTangentNormals && !shader.usesProbes && usesTangentSpace;\n        if (!shader.usesTangentSpace) {\n            if (shader.viewDirDependencies > 0) {\n                shader.globalPosDependencies++;\n            }\n            else if (this.numPointLights > 0 && shader.usesLights) {\n                shader.globalPosDependencies++;\n                if (Boolean(this._mode & MethodPassMode_1.MethodPassMode.EFFECTS))\n                    shader.usesGlobalPosFragment = true;\n            }\n        }\n    };\n    /**\n     * Counts the dependencies for a given method.\n     * @param method The method to count the dependencies for.\n     * @param methodVO The method's data for this material.\n     */\n    MethodPass.prototype.setupAndCountDependencies = function (shader, methodVO) {\n        methodVO.reset();\n        methodVO.method.iInitVO(shader, methodVO);\n        if (methodVO.needsProjection)\n            shader.projectionDependencies++;\n        if (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos) {\n            shader.globalPosDependencies++;\n            if (methodVO.needsGlobalFragmentPos)\n                shader.usesGlobalPosFragment = true;\n        }\n        if (methodVO.needsNormals)\n            shader.normalDependencies++;\n        if (methodVO.needsTangents)\n            shader.tangentDependencies++;\n        if (methodVO.needsView)\n            shader.viewDirDependencies++;\n    };\n    MethodPass.prototype._iGetPreLightingVertexCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)\n            code += this._iAmbientMethodVO.method.iGetVertexCode(shader, this._iAmbientMethodVO, registerCache, sharedRegisters);\n        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n            code += this._iDiffuseMethodVO.method.iGetVertexCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n            code += this._iSpecularMethodVO.method.iGetVertexCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n        return code;\n    };\n    MethodPass.prototype._iGetPreLightingFragmentCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {\n            code += this._iAmbientMethodVO.method.iGetFragmentCode(shader, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n            if (this._iAmbientMethodVO.needsNormals)\n                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n            if (this._iAmbientMethodVO.needsView)\n                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n        }\n        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n            code += this._iDiffuseMethodVO.method.iGetFragmentPreLightingCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n            code += this._iSpecularMethodVO.method.iGetFragmentPreLightingCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n        return code;\n    };\n    MethodPass.prototype._iGetPerLightDiffuseFragmentCode = function (shader, lightDirReg, diffuseColorReg, registerCache, sharedRegisters) {\n        return this._iDiffuseMethodVO.method.iGetFragmentCodePerLight(shader, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetPerLightSpecularFragmentCode = function (shader, lightDirReg, specularColorReg, registerCache, sharedRegisters) {\n        return this._iSpecularMethodVO.method.iGetFragmentCodePerLight(shader, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetPerProbeDiffuseFragmentCode = function (shader, texReg, weightReg, registerCache, sharedRegisters) {\n        return this._iDiffuseMethodVO.method.iGetFragmentCodePerProbe(shader, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetPerProbeSpecularFragmentCode = function (shader, texReg, weightReg, registerCache, sharedRegisters) {\n        return this._iSpecularMethodVO.method.iGetFragmentCodePerProbe(shader, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetPostLightingVertexCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (this._iShadowMethodVO)\n            code += this._iShadowMethodVO.method.iGetVertexCode(shader, this._iShadowMethodVO, registerCache, sharedRegisters);\n        return code;\n    };\n    MethodPass.prototype._iGetPostLightingFragmentCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        if (shader.useAlphaPremultiplied && shader.usesBlending) {\n            code += \"add \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n                \"div \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \", \" + sharedRegisters.shadedTarget + \".w\\n\" +\n                \"sub \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n                \"sat \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \"\\n\";\n        }\n        if (this._iShadowMethodVO)\n            code += this._iShadowMethodVO.method.iGetFragmentCode(shader, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);\n        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {\n            code += this._iDiffuseMethodVO.method.iGetFragmentPostLightingCode(shader, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n            // resolve other dependencies as well?\n            if (this._iDiffuseMethodVO.needsNormals)\n                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n            if (this._iDiffuseMethodVO.needsView)\n                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n        }\n        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {\n            code += this._iSpecularMethodVO.method.iGetFragmentPostLightingCode(shader, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n            if (this._iSpecularMethodVO.needsNormals)\n                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n            if (this._iSpecularMethodVO.needsView)\n                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n        }\n        if (this._iShadowMethodVO)\n            registerCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);\n        return code;\n    };\n    MethodPass.prototype._iGetNormalVertexCode = function (shader, registerCache, sharedRegisters) {\n        return this._iNormalMethodVO.method.iGetVertexCode(shader, this._iNormalMethodVO, registerCache, sharedRegisters);\n    };\n    MethodPass.prototype._iGetNormalFragmentCode = function (shader, registerCache, sharedRegisters) {\n        var code = this._iNormalMethodVO.method.iGetFragmentCode(shader, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);\n        if (this._iNormalMethodVO.needsView)\n            registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n        if (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)\n            registerCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype._iGetVertexCode = function (shader, regCache, sharedReg) {\n        var code = \"\";\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = len - this._numEffectDependencies; i < len; i++) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod) {\n                code += methodVO.method.iGetVertexCode(shader, methodVO, regCache, sharedReg);\n                if (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)\n                    regCache.removeVertexTempUsage(sharedReg.globalPositionVertex);\n            }\n        }\n        if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n            code += this._iColorTransformMethodVO.method.iGetVertexCode(shader, this._iColorTransformMethodVO, regCache, sharedReg);\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    MethodPass.prototype._iGetFragmentCode = function (shader, regCache, sharedReg) {\n        var code = \"\";\n        var alphaReg;\n        if (this.preserveAlpha && this._numEffectDependencies > 0) {\n            alphaReg = regCache.getFreeFragmentSingleTemp();\n            regCache.addFragmentTempUsages(alphaReg, 1);\n            code += \"mov \" + alphaReg + \", \" + sharedReg.shadedTarget + \".w\\n\";\n        }\n        var methodVO;\n        var len = this._iMethodVOs.length;\n        for (var i = len - this._numEffectDependencies; i < len; i++) {\n            methodVO = this._iMethodVOs[i];\n            if (methodVO.useMethod) {\n                code += methodVO.method.iGetFragmentCode(shader, methodVO, sharedReg.shadedTarget, regCache, sharedReg);\n                if (methodVO.needsNormals)\n                    regCache.removeFragmentTempUsage(sharedReg.normalFragment);\n                if (methodVO.needsView)\n                    regCache.removeFragmentTempUsage(sharedReg.viewDirFragment);\n            }\n        }\n        if (this.preserveAlpha && this._numEffectDependencies > 0) {\n            code += \"mov \" + sharedReg.shadedTarget + \".w, \" + alphaReg + \"\\n\";\n            regCache.removeFragmentTempUsage(alphaReg);\n        }\n        if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n            code += this._iColorTransformMethodVO.method.iGetFragmentCode(shader, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);\n        return code;\n    };\n    /**\n     * Indicates whether the shader uses any shadows.\n     */\n    MethodPass.prototype._iUsesShadows = function (shader) {\n        return Boolean(this._iShadowMethodVO && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));\n    };\n    /**\n     * Indicates whether the shader uses any specular component.\n     */\n    MethodPass.prototype._iUsesSpecular = function (shader) {\n        return Boolean(this._iSpecularMethodVO);\n    };\n    /**\n     * Indicates whether the shader uses any specular component.\n     */\n    MethodPass.prototype._iUsesDiffuse = function (shader) {\n        return Boolean(this._iDiffuseMethodVO);\n    };\n    MethodPass.prototype.onLightsChange = function (event) {\n        this._updateLights();\n    };\n    MethodPass.prototype._updateLights = function () {\n        var numDirectionalLightsOld = this.numDirectionalLights;\n        var numPointLightsOld = this.numPointLights;\n        var numLightProbesOld = this.numLightProbes;\n        if (this._lightPicker && (this._mode & MethodPassMode_1.MethodPassMode.LIGHTING)) {\n            this.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);\n            this.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);\n            this.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);\n            if (this._includeCasters) {\n                this.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;\n                this.numPointLights += this._lightPicker.numCastingPointLights;\n            }\n        }\n        else {\n            this.numDirectionalLights = 0;\n            this.numPointLights = 0;\n            this.numLightProbes = 0;\n        }\n        if (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {\n            this._updateShader();\n            this.invalidate();\n        }\n    };\n    /**\n     * Calculates the amount of directional lights this material will support.\n     * @param numDirectionalLights The maximum amount of directional lights to support.\n     * @return The amount of directional lights this material will support, bounded by the amount necessary.\n     */\n    MethodPass.prototype.calculateNumDirectionalLights = function (numDirectionalLights) {\n        return Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);\n    };\n    /**\n     * Calculates the amount of point lights this material will support.\n     * @param numDirectionalLights The maximum amount of point lights to support.\n     * @return The amount of point lights this material will support, bounded by the amount necessary.\n     */\n    MethodPass.prototype.calculateNumPointLights = function (numPointLights) {\n        var numFree = this._maxLights - this.numDirectionalLights;\n        return Math.min(numPointLights - this.pointLightsOffset, numFree);\n    };\n    /**\n     * Calculates the amount of light probes this material will support.\n     * @param numDirectionalLights The maximum amount of light probes to support.\n     * @return The amount of light probes this material will support, bounded by the amount necessary.\n     */\n    MethodPass.prototype.calculateNumProbes = function (numLightProbes) {\n        var numChannels = 0;\n        if ((this.specularLightSources & LightSources_1.LightSources.PROBES) != 0)\n            ++numChannels;\n        if ((this.diffuseLightSources & LightSources_1.LightSources.PROBES) != 0)\n            ++numChannels;\n        // 4 channels available\n        return Math.min(numLightProbes - this.lightProbesOffset, (4 / numChannels) | 0);\n    };\n    return MethodPass;\n}(PassBase_1.PassBase));\nexports.MethodPass = MethodPass;\n\n},{\"../../data/MethodVO\":\"awayjs-methodmaterials/lib/data/MethodVO\",\"../../methods/EffectColorTransformMethod\":\"awayjs-methodmaterials/lib/methods/EffectColorTransformMethod\",\"../../surfaces/passes/MethodPassMode\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\",\"awayjs-core/lib/events/AssetEvent\":undefined,\"awayjs-display/lib/materials/LightSources\":undefined,\"awayjs-renderergl/lib/events/ShadingMethodEvent\":undefined,\"awayjs-renderergl/lib/shaders/LightingShader\":undefined,\"awayjs-renderergl/lib/shaders/ShaderBase\":undefined,\"awayjs-renderergl/lib/surfaces/passes/PassBase\":undefined}],\"awayjs-methodmaterials/lib/surfaces/passes/SingleObjectDepthPass\":[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Image2D_1 = require(\"awayjs-core/lib/image/Image2D\");\nvar Matrix3D_1 = require(\"awayjs-core/lib/geom/Matrix3D\");\nvar Single2DTexture_1 = require(\"awayjs-display/lib/textures/Single2DTexture\");\nvar PassBase_1 = require(\"awayjs-renderergl/lib/surfaces/passes/PassBase\");\n/**\n * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point\n * of view from a light.\n */\nvar SingleObjectDepthPass = (function (_super) {\n    __extends(SingleObjectDepthPass, _super);\n    /**\n     * Creates a new SingleObjectDepthPass object.\n     */\n    function SingleObjectDepthPass(render, renderOwner, elementsClass, stage) {\n        _super.call(this, render, renderOwner, elementsClass, stage);\n        this._textureSize = 512;\n        this._polyOffset = new Float32Array([15, 0, 0, 0]);\n        this._projectionTexturesInvalid = true;\n        //this._pNumUsedStreams = 2;\n        //this._pNumUsedVertexConstants = 7;\n        //this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n        //\n        //this._pAnimatableAttributes = Array<string>(\"va0\", \"va1\";\n        //this._pAnimationTargetRegisters = Array<string>(\"vt0\", \"vt1\";\n    }\n    Object.defineProperty(SingleObjectDepthPass.prototype, \"textureSize\", {\n        /**\n         * The size of the depth map texture to render to.\n         */\n        get: function () {\n            return this._textureSize;\n        },\n        set: function (value) {\n            this._textureSize = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SingleObjectDepthPass.prototype, \"polyOffset\", {\n        /**\n         * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n         */\n        get: function () {\n            return this._polyOffset[0];\n        },\n        set: function (value) {\n            this._polyOffset[0] = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype.dispose = function () {\n        if (this._textures) {\n            for (var key in this._textures) {\n                var texture = this._textures[key];\n                texture.dispose();\n            }\n            this._textures = null;\n        }\n    };\n    /**\n     * Updates the projection textures used to contain the depth renders.\n     */\n    SingleObjectDepthPass.prototype.updateProjectionTextures = function () {\n        if (this._textures) {\n            for (var key in this._textures) {\n                var texture = this._textures[key];\n                texture.dispose();\n            }\n        }\n        this._textures = new Object();\n        this._projections = new Object();\n        this._projectionTexturesInvalid = false;\n    };\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype._iGetVertexCode = function () {\n        var code;\n        // offset\n        code = \"mul vt7, vt1, vc4.x\t\\n\" +\n            \"add vt7, vt7, vt0\\n\" +\n            \"mov vt7.w, vt0.w\\n\";\n        // project\n        code += \"m44 vt2, vt7, vc0\\n\" +\n            \"mov op, vt2\\n\";\n        // perspective divide\n        code += \"div v0, vt2, vt2.w\\n\";\n        return code;\n    };\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {\n        var code = \"\";\n        // encode float -> rgba\n        code += \"mul ft0, fc0, v0.z\\n\" +\n            \"frc ft0, ft0\\n\" +\n            \"mul ft1, ft0.yzww, fc1\\n\" +\n            \"sub ft0, ft0, ft1\\n\" +\n            \"mov oc, ft0\\n\";\n        return code;\n    };\n    /**\n     * Gets the depth maps rendered for this object from all lights.\n     * @param renderableGL The renderableGL for which to retrieve the depth maps.\n     * @param stage3DProxy The Stage3DProxy object currently used for rendering.\n     * @return A list of depth map textures for all supported lights.\n     */\n    SingleObjectDepthPass.prototype._iGetDepthMap = function (renderableGL) {\n        return this._textures[renderableGL.renderable.id];\n    };\n    /**\n     * Retrieves the depth map projection maps for all lights.\n     * @param renderableGL The renderableGL for which to retrieve the projection maps.\n     * @return A list of projection maps for all supported lights.\n     */\n    SingleObjectDepthPass.prototype._iGetProjection = function (renderableGL) {\n        return this._projections[renderableGL.renderable.id];\n    };\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype._iRender = function (renderableGL, camera, viewProjection) {\n        var matrix;\n        var context = this._stage.context;\n        var len;\n        var light;\n        var lights = this._surface.lightPicker.allPickedLights;\n        var rId = renderableGL.renderable.id;\n        if (!this._textures[rId])\n            this._textures[rId] = new Single2DTexture_1.Single2DTexture(new Image2D_1.Image2D(this._textureSize, this._textureSize));\n        if (!this._projections[rId])\n            this._projections[rId] = new Matrix3D_1.Matrix3D();\n        len = lights.length;\n        // local position = enough\n        light = lights[0];\n        matrix = light.iGetObjectProjectionMatrix(renderableGL.sourceEntity, camera.sceneTransform, this._projections[rId]);\n        this._stage.setRenderTarget(this._textures[rId], true);\n        context.clear(1.0, 1.0, 1.0);\n        //context.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, matrix, true);\n        //context.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, this._enc, 2);\n        var elementsGL = renderableGL.elementsGL;\n        // elementsGL.activateVertexBufferVO(0, elements.positions);\n        // elementsGL.activateVertexBufferVO(1, elements.normals);\n        // elementsGL.getIndexBufferGL().draw(ContextGLDrawMode.TRIANGLES, 0, elements.numElements);\n    };\n    /**\n     * @inheritDoc\n     */\n    SingleObjectDepthPass.prototype._iActivate = function (camera) {\n        if (this._projectionTexturesInvalid)\n            this.updateProjectionTextures();\n        // never scale\n        _super.prototype._iActivate.call(this, camera);\n        //this._stage.context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);\n    };\n    return SingleObjectDepthPass;\n}(PassBase_1.PassBase));\nexports.SingleObjectDepthPass = SingleObjectDepthPass;\n\n},{\"awayjs-core/lib/geom/Matrix3D\":undefined,\"awayjs-core/lib/image/Image2D\":undefined,\"awayjs-display/lib/textures/Single2DTexture\":undefined,\"awayjs-renderergl/lib/surfaces/passes/PassBase\":undefined}],\"awayjs-methodmaterials/lib/surfaces\":[function(require,module,exports){\n\"use strict\";\nvar MethodPass_1 = require(\"./surfaces/passes/MethodPass\");\nexports.MethodPass = MethodPass_1.MethodPass;\nvar MethodPassMode_1 = require(\"./surfaces/passes/MethodPassMode\");\nexports.MethodPassMode = MethodPassMode_1.MethodPassMode;\nvar SingleObjectDepthPass_1 = require(\"./surfaces/passes/SingleObjectDepthPass\");\nexports.SingleObjectDepthPass = SingleObjectDepthPass_1.SingleObjectDepthPass;\nvar GL_MethodMaterialSurface_1 = require(\"./surfaces/GL_MethodMaterialSurface\");\nexports.GL_MethodMaterialSurface = GL_MethodMaterialSurface_1.GL_MethodMaterialSurface;\n\n},{\"./surfaces/GL_MethodMaterialSurface\":\"awayjs-methodmaterials/lib/surfaces/GL_MethodMaterialSurface\",\"./surfaces/passes/MethodPass\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPass\",\"./surfaces/passes/MethodPassMode\":\"awayjs-methodmaterials/lib/surfaces/passes/MethodPassMode\",\"./surfaces/passes/SingleObjectDepthPass\":\"awayjs-methodmaterials/lib/surfaces/passes/SingleObjectDepthPass\"}]},{},[1])\n\n",
    "import * as data\t\t\t\t\tfrom \"./lib/data\";\nimport * as methods\t\t\t\t\tfrom \"./lib/methods\";\nimport * as surfaces\t\t\t\tfrom \"./lib/surfaces\";\nimport {MethodMaterial}\t\t\t\tfrom \"./lib/MethodMaterial\";\nimport {MethodMaterialMode}\t\t\tfrom \"./lib/MethodMaterialMode\";\n\nimport {SurfacePool}\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/SurfacePool\";\n\nSurfacePool.registerAbstraction(surfaces.GL_MethodMaterialSurface, MethodMaterial);\n\nexport {\n\tdata,\n\tmethods,\n\tsurfaces,\n\tMethodMaterial,\n\tMethodMaterialMode\n}",
    "export class MethodMaterialMode\n{\n\t/**\n\t *\n\t */\n\tpublic static SINGLE_PASS:string = \"singlePass\";\n\n\t/**\n\t *\n\t */\n\tpublic static MULTI_PASS:string = \"multiPass\";\n}",
    "﻿import {Image2D}\t\t\t\t\t\tfrom \"awayjs-core/lib/image/Image2D\";\n\nimport {MaterialBase}\t\t\t\t\tfrom \"awayjs-display/lib/materials/MaterialBase\";\nimport {Single2DTexture}\t\t\t\tfrom \"awayjs-display/lib/textures/Single2DTexture\";\nimport {TextureBase}\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {ContextGLCompareMode}\t\t\tfrom \"awayjs-stagegl/lib/base/ContextGLCompareMode\";\n\nimport {MethodMaterialMode}\t\t\tfrom \"./MethodMaterialMode\";\nimport {AmbientBasicMethod}\t\t\tfrom \"./methods/AmbientBasicMethod\";\nimport {DiffuseBasicMethod}\t\t\tfrom \"./methods/DiffuseBasicMethod\";\nimport {EffectMethodBase}\t\t\t\tfrom \"./methods/EffectMethodBase\";\nimport {NormalBasicMethod}\t\t\tfrom \"./methods/NormalBasicMethod\";\nimport {ShadowMapMethodBase}\t\t\tfrom \"./methods/ShadowMapMethodBase\";\nimport {SpecularBasicMethod}\t\t\tfrom \"./methods/SpecularBasicMethod\";\n\n/**\n * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,\n * using material methods to define their appearance.\n */\nexport class MethodMaterial extends MaterialBase\n{\n\tpublic static assetType:string = \"[materials MethodMaterial]\";\n\n\tprivate _effectMethods:Array<EffectMethodBase> = new Array<EffectMethodBase>();\n\tprivate _mode:string;\n\n\tprivate _ambientMethod:AmbientBasicMethod = new AmbientBasicMethod();\n\tprivate _shadowMethod:ShadowMapMethodBase;\n\tprivate _diffuseMethod:DiffuseBasicMethod = new DiffuseBasicMethod();\n\tprivate _normalMethod:NormalBasicMethod = new NormalBasicMethod();\n\tprivate _specularMethod:SpecularBasicMethod = new SpecularBasicMethod();\n\n\n\tprivate _depthCompareMode:string = ContextGLCompareMode.LESS_EQUAL;\n\n\t/**\n\t *\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn MethodMaterial.assetType;\n\t}\n\n\t/**\n\t * Creates a new MethodMaterial object.\n\t *\n\t * @param texture The texture used for the material's albedo color.\n\t * @param smooth Indicates whether the texture should be filtered when sampled. Defaults to true.\n\t * @param repeat Indicates whether the texture should be tiled when sampled. Defaults to false.\n\t * @param mipmap Indicates whether or not any used textures should use mipmapping. Defaults to false.\n\t */\n\tconstructor(image?:Image2D, alpha?:number);\n\tconstructor(color?:number, alpha?:number);\n\tconstructor(imageColor:any = null, alpha:number = 1)\n\t{\n\t\tsuper(imageColor, alpha);\n\n\t\tthis._mode = MethodMaterialMode.SINGLE_PASS;\n\n\t\t//add default methods owners\n\t\tthis._ambientMethod.iAddOwner(this);\n\t\tthis._diffuseMethod.iAddOwner(this);\n\t\tthis._normalMethod.iAddOwner(this);\n\t\tthis._specularMethod.iAddOwner(this);\n\n\t\t//set a texture if an image is present\n\t\tif (imageColor instanceof Image2D)\n\t\t\tthis._ambientMethod.texture = new Single2DTexture();\n\t}\n\n\n\tpublic get mode():string\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:string)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\n\t\tthis._mode = value;\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The depth compare mode used to render the renderables using this material.\n\t *\n\t * @see away.stagegl.ContextGLCompareMode\n\t */\n\n\tpublic get depthCompareMode():string\n\t{\n\t\treturn this._depthCompareMode;\n\t}\n\n\tpublic set depthCompareMode(value:string)\n\t{\n\t\tif (this._depthCompareMode == value)\n\t\t\treturn;\n\n\t\tthis._depthCompareMode = value;\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The texture object to use for the ambient colour.\n\t */\n\tpublic get diffuseTexture():TextureBase\n\t{\n\t\treturn this._diffuseMethod.texture;\n\t}\n\n\tpublic set diffuseTexture(value:TextureBase)\n\t{\n\t\tthis._diffuseMethod.texture = value;\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._ambientMethod;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._ambientMethod == value)\n\t\t\treturn;\n\n\t\tif (this._ambientMethod)\n\t\t\tthis._ambientMethod.iRemoveOwner(this);\n\n\t\tthis._ambientMethod = value;\n\n\t\tif (this._ambientMethod)\n\t\t\tthis._ambientMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._shadowMethod;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._shadowMethod == value)\n\t\t\treturn;\n\n\t\tif (this._shadowMethod)\n\t\t\tthis._shadowMethod.iRemoveOwner(this);\n\n\t\tthis._shadowMethod = value;\n\n\t\tif (this._shadowMethod)\n\t\t\tthis._shadowMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._diffuseMethod;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._diffuseMethod == value)\n\t\t\treturn;\n\n\t\tif (this._diffuseMethod)\n\t\t\tthis._diffuseMethod.iRemoveOwner(this);\n\n\t\tthis._diffuseMethod = value;\n\n\t\tif (this._diffuseMethod)\n\t\t\tthis._diffuseMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._specularMethod;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._specularMethod == value)\n\t\t\treturn;\n\n\t\tif (this._specularMethod)\n\t\t\tthis._specularMethod.iRemoveOwner(this);\n\n\t\tthis._specularMethod = value;\n\n\t\tif (this._specularMethod)\n\t\t\tthis._specularMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._normalMethod;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._normalMethod == value)\n\t\t\treturn;\n\n\t\tif (this._normalMethod)\n\t\t\tthis._normalMethod.iRemoveOwner(this);\n\n\t\tthis._normalMethod = value;\n\n\t\tif (this._normalMethod)\n\t\t\tthis._normalMethod.iAddOwner(this);\n\n\t\tthis.invalidate();\n\t}\n\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._effectMethods.length;\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase):void\n\t{\n\t\tmethod.iAddOwner(this);\n\n\t\tthis._effectMethods.push(method);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\treturn this._effectMethods[index];\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number):void\n\t{\n\t\tmethod.iAddOwner(this);\n\n\t\tthis._effectMethods.splice(index, 0, method);\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase):void\n\t{\n\t\tmethod.iRemoveOwner(this);\n\n\t\tthis._effectMethods.splice(this._effectMethods.indexOf(method), 1);\n\n\t\tthis.invalidate();\n\t}\n}",
    "import {GL_TextureBase}\t\t\t\tfrom \"awayjs-renderergl/lib/textures/GL_TextureBase\";\n\nimport {MethodPass}\t\t\t\t\tfrom \"../surfaces/passes/MethodPass\";\nimport {ShadingMethodBase}\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * MethodVO contains data for a given shader object for the use within a single material.\n * This allows shader methods to be shared across materials while their non-public state differs.\n */\nexport class MethodVO\n{\n\tpublic useMethod:boolean = true;\n\n\tpublic method:ShadingMethodBase;\n\tpublic pass:MethodPass;\n\n\t// public register indices\n\tpublic textureGL:GL_TextureBase;\n\tpublic secondaryTextureGL:GL_TextureBase; // sometimes needed for composites\n\tpublic vertexConstantsIndex:number;\n\tpublic secondaryVertexConstantsIndex:number; // sometimes needed for composites\n\tpublic fragmentConstantsIndex:number;\n\tpublic secondaryFragmentConstantsIndex:number; // sometimes needed for composites\n\n\t// internal stuff for the material to know before assembling code\n\tpublic needsProjection:boolean;\n\tpublic needsView:boolean;\n\tpublic needsNormals:boolean;\n\tpublic needsTangents:boolean;\n\tpublic needsGlobalVertexPos:boolean;\n\tpublic needsGlobalFragmentPos:boolean;\n\t/**\n\t * Creates a new MethodVO object.\n\t */\n\tconstructor(method:ShadingMethodBase, pass:MethodPass)\n\t{\n\t\tthis.method = method;\n\t\tthis.pass = pass;\n\t}\n\n\t/**\n\t * Resets the values of the value object to their \"unused\" state.\n\t */\n\tpublic reset():void\n\t{\n\t\tthis.method.iReset();\n\n\t\tthis.vertexConstantsIndex = -1;\n\t\tthis.secondaryVertexConstantsIndex = -1;\n\t\tthis.fragmentConstantsIndex = -1;\n\t\tthis.secondaryFragmentConstantsIndex = -1;\n\n\t\tthis.needsProjection = false;\n\t\tthis.needsView = false;\n\t\tthis.needsNormals = false;\n\t\tthis.needsTangents = false;\n\t\tthis.needsGlobalVertexPos = false;\n\t\tthis.needsGlobalFragmentPos = false;\n\t}\n}\n",
    "export {MethodVO}\t\t\t\t\t\tfrom \"./data/MethodVO\";",
    "import {AssetEvent}\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\nimport {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {ShadingMethodBase}\t\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nexport class AmbientBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number;\n\tprivate _alpha:number = 1;\n\n\tpublic _texture:TextureBase;\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _strength:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, this._texture));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tif (!methodVO.textureGL) {\n\t\t\tthis._color = shader.numLights? 0xFFFFFF : methodVO.pass._surface.style.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tif (this._strength == value)\n\t\t\treturn;\n\n\t\tthis._strength = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The texture to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase):void\n\t{\n\t\tvar m:any = method;\n\t\tvar b:AmbientBasicMethod = <AmbientBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (methodVO.textureGL) {\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tvar ambientInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tif (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tif (methodVO.textureGL)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor():void\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._strength;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._strength;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._strength;\n\t}\n}",
    "import {AssetEvent}\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {AmbientBasicMethod}\t\t\t\tfrom \"../methods/AmbientBasicMethod\";\n\n/**\n * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to\n * approximate global lighting rather than lights.\n */\nexport class AmbientEnvMapMethod extends AmbientBasicMethod\n{\n\t/**\n\t * Creates a new <code>AmbientEnvMapMethod</code> object.\n\t *\n\t * @param envMap The cube environment map to use for the ambient lighting.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tmethodVO.needsNormals = true;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, this._texture));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (this._texture)? methodVO.textureGL._iGetFragmentCode(targetReg, regCache, sharedRegisters, sharedRegisters.normalFragment) : \"\";\n\t}\n}",
    "import {AssetEvent}\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\nimport {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {ShadingMethodBase}\t\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * AmbientBasicMethod provides the default shading method for uniform ambient lighting.\n */\nexport class CurveBasicMethod extends ShadingMethodBase\n{\n\tprivate _color:number = 0xffffff;\n\tprivate _alpha:number = 1;\n\n\tpublic _texture:TextureBase;\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tprivate _ambient:number = 1;\n\n\t/**\n\t * Creates a new AmbientBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, this._texture));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tif (!methodVO.textureGL) {\n\t\t\tthis._color = methodVO.pass._surface.style.color;\n\t\t\tthis.updateColor();\n\t\t}\n\t}\n\n\t/**\n\t * The strength of the ambient reflection of the surface.\n\t */\n\tpublic get ambient():number\n\t{\n\t\treturn this._ambient;\n\t}\n\n\tpublic set ambient(value:number)\n\t{\n\t\tif (this._ambient == value)\n\t\t\treturn;\n\n\t\tthis._ambient = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The alpha component of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tif (this._alpha == value)\n\t\t\treturn;\n\n\t\tthis._alpha = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The texture to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase):void\n\t{\n\t\tvar m:any = method;\n\t\tvar b:CurveBasicMethod = <CurveBasicMethod> m;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n    /*\n    public iGeVertexCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string {\n        var code:string = \"\";\n        code = \"mov \" + sharedRegisters.uvVarying + \" \" + registerCache.uv +  \" \\n\";\n    }*/\n    public iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar ambientInputRegister:ShaderRegisterElement;\n\n\t\tif (methodVO.textureGL) {\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\t\t\tif (shader.alphaThreshold > 0) {\n\t\t\t\tvar cutOffReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\t\tmethodVO.fragmentConstantsIndex = cutOffReg.index*4;\n\n\t\t\t\tcode += \"sub \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\" +\n\t\t\t\t\t\"kil \" + targetReg + \".w\\n\" +\n\t\t\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + cutOffReg + \".x\\n\";\n\t\t\t}\n\n\t\t} else {\n\t\t\tambientInputRegister = registerCache.getFreeFragmentConstant();\n\t\t\tmethodVO.fragmentConstantsIndex = ambientInputRegister.index*4;\n\n\t\t\tcode += \"mov \" + targetReg + \", \" + ambientInputRegister + \"\\n\";\n\t\t}\n        code = \"mov \" + targetReg + \", \" + sharedRegisters.uvVarying + \"\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tif (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\t\tif (shader.alphaThreshold > 0)\n\t\t\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tdata[index] = this._colorR;\n\t\t\tdata[index + 1] = this._colorG;\n\t\t\tdata[index + 2] = this._colorB;\n\t\t\tdata[index + 3] = this._alpha;\n\t\t}\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tif (methodVO.textureGL)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateColor():void\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff*this._ambient;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff*this._ambient;\n\t\tthis._colorB = (this._color & 0xff)/0xff*this._ambient;\n\t}\n}\nexport default CurveBasicMethod;",
    "import {AssetEvent}\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\n\nimport {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {ShadingMethodBase}\t\t\t\tfrom \"../methods/ShadingMethodBase\";\nimport {LightingMethodBase}\t\t\t\tfrom \"../methods/LightingMethodBase\";\n\n/**\n * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.\n */\nexport class DiffuseBasicMethod extends LightingMethodBase\n{\n\tprivate _multiply:boolean = true;\n\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\n\tpublic _texture:TextureBase;\n\tprivate _ambientColor:number;\n\tprivate _ambientColorR:number = 1;\n\tprivate _ambientColorG:number = 1;\n\tprivate _ambientColorB:number = 1;\n\tprivate _color:number = 0xffffff;\n\tprivate _colorR:number = 1;\n\tprivate _colorG:number = 1;\n\tprivate _colorB:number = 1;\n\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Set internally if diffuse color component multiplies or replaces the ambient color\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this._multiply;\n\t}\n\n\tpublic set multiply(value:boolean)\n\t{\n\t\tif (this._multiply == value)\n\t\t\treturn;\n\n\t\tthis._multiply = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, null));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\n\t\tif (shader.numLights > 0) {\n\t\t\tshader.usesCommonData = true;\n\t\t\tmethodVO.needsNormals = true;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tif (shader.numLights > 0) {\n\t\t\tthis._ambientColor = methodVO.pass._surface.style.color;\n\t\t\tthis.updateAmbientColor();\n\t\t} else {\n\t\t\tthis._ambientColor = null;\n\t\t}\n\t}\n\n\t/**\n\t * The color of the diffuse reflection when not using a texture.\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number)\n\t{\n\t\tif (this._color == value)\n\t\t\treturn;\n\n\t\tthis._color = value;\n\n\t\tthis.updateColor();\n\t}\n\n\t/**\n\t * The texture to use to define the diffuse reflection color per texel.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose():void\n\t{\n\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase):void\n\t{\n\t\tvar diff:DiffuseBasicMethod = <DiffuseBasicMethod> method;\n\n\t\tthis.texture = diff.texture;\n\t\tthis.multiply = diff.multiply;\n\t\tthis.color = diff.color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData():void\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pTotalLightColorReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \", \" + sharedRegisters.normalFragment + \"\\n\" +\n\t\t\t\t\"max \" + t + \".w, \" + t + \".x, \" + sharedRegisters.commons + \".y\\n\";\n\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".w, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"tex \" + t + \", \" + sharedRegisters.normalFragment + \", \" + cubeMapReg + \" <cube,linear,miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tvar diffuseColor:ShaderRegisterElement;\n\t\tvar cutOffReg:ShaderRegisterElement;\n\n\t\t// incorporate input from ambient\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += this.pApplyShadow(shader, methodVO, registerCache, sharedRegisters);\n\n\t\tregisterCache.addFragmentTempUsages(diffuseColor = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar ambientColorRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = ambientColorRegister.index*4;\n\n\t\tif (this._texture) {\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(diffuseColor, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\t\t} else {\n\t\t\tvar diffuseInputRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\t\tcode += \"mov \" + diffuseColor + \", \" + diffuseInputRegister + \"\\n\";\n\t\t}\n\n\t\tcode += \"sat \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\"mul \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\";\n\n\t\tif (this._multiply) {\n\t\t\tcode += \"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + ambientColorRegister + \"\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\";\n\t\t} else if (this._texture) {\n\t\t\tcode += \"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + ambientColorRegister + \"\\n\" + // multiply target by ambient for total ambient\n\t\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\" + // ambient * (1 - totalLightColor)\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; //add diffuse color and ambient color\n\t\t} else {\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" +\n\t\t\t\t\"sub \" + this._pTotalLightColorReg + \".xyz, \" + ambientColorRegister + \", \" + this._pTotalLightColorReg + \"\\n\" + // ambient * (1 - totalLightColor)\n\t\t\t\t\"add \" + diffuseColor + \".xyz, \" + diffuseColor + \", \" + this._pTotalLightColorReg + \"\\n\" + // add diffuse color and  ambient color\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \", \" + diffuseColor + \"\\n\"; // multiply by target which could be texture or white\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\tregisterCache.removeFragmentTempUsage(diffuseColor);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Generate the code that applies the calculated shadow to the diffuse light\n\t * @param methodVO The MethodVO object for which the compilation is currently happening.\n\t * @param regCache The register cache the compiler is currently using for the register management.\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t\t} else {\n\t\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\t\tif (this._multiply) {\n\t\t\t\tdata[index + 4] = this._colorR*this._ambientColorR;\n\t\t\t\tdata[index + 5] = this._colorG*this._ambientColorG;\n\t\t\t\tdata[index + 6] = this._colorB*this._ambientColorB;\n\t\t\t} else {\n\t\t\t\tdata[index + 4] = this._colorR;\n\t\t\t\tdata[index + 5] = this._colorG;\n\t\t\t\tdata[index + 6] = this._colorB;\n\t\t\t}\n\t\t\tdata[index + 7] = 1;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the diffuse color data used by the render state.\n\t */\n\tprivate updateColor():void\n\t{\n\t\tthis._colorR = ((this._color >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((this._color >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (this._color & 0xff)/0xff;\n\t}\n\n\n\t/**\n\t * Updates the ambient color data used by the render state.\n\t */\n\tprivate updateAmbientColor():void\n\t{\n\t\tthis._ambientColorR = ((this._ambientColor >> 16) & 0xff)/0xff;\n\t\tthis._ambientColorG = ((this._ambientColor >> 8) & 0xff)/0xff;\n\t\tthis._ambientColorB = (this._ambientColor & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\n\t\t//TODO move this to Activate (ambientR/G/B currently calc'd in render state)\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = shader.ambientR*this._ambientColorR;\n\t\tdata[index + 1] = shader.ambientG*this._ambientColorG;\n\t\tdata[index + 2] = shader.ambientB*this._ambientColorB;\n\t\tdata[index + 3] = 1;\n\t}\n}",
    "import {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {DiffuseBasicMethod}\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\nimport {DiffuseCompositeMethod}\t\t\tfrom \"../methods/DiffuseCompositeMethod\";\n\n/**\n * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.\n */\nexport class DiffuseCelMethod extends DiffuseCompositeMethod\n{\n\tprivate _levels:number /*uint*/;\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\n\t/**\n\t * Creates a new DiffuseCelMethod object.\n\t * @param levels The amount of shadow gradations.\n\t * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.\n\t */\n\tconstructor(levels:number /*uint*/ = 3, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampDiffuse(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._levels = levels;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tdata[index + 1] = 1;\n\t\tdata[index + 2] = 0;\n\t}\n\n\t/**\n\t * The amount of shadow gradations.\n\t */\n\tpublic get levels():number /*uint*/\n\t{\n\t\treturn this._levels;\n\t}\n\n\tpublic set levels(value:number /*uint*/)\n\t{\n\t\tthis._levels = value;\n\t}\n\n\t/**\n\t * The smoothness of the edge between 2 shading levels.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData():void\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = this._levels;\n\t\tdata[index + 3] = this._smoothness;\n\t}\n\n\t/**\n\t * Snaps the diffuse shading of the wrapped method to one of the levels.\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the diffuse strength in the \"w\" component.\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampDiffuse(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"frc \" + targetReg + \".z, \" + targetReg + \".w\\n\" +\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t\"mov \" + targetReg + \".x, \" + this._dataReg + \".x\\n\" +\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"rcp \" + targetReg + \".x,\" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\n\t\t\t// previous clamped strength\n\t\t\t\"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + targetReg + \".x\\n\" +\n\n\t\t\t// fract/epsilon (so 0 - epsilon will become 0 - 1)\n\t\t\t\"div \" + targetReg + \".z, \" + targetReg + \".z, \" + this._dataReg + \".w\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".z\\n\" +\n\t\t\t// 1-z\n\t\t\t\"sub \" + targetReg + \".z, \" + this._dataReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t}\n}",
    "import {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\nimport {ISurface}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\nimport {ShadingMethodEvent}\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {DiffuseBasicMethod}\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\n\n/**\n * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the\n * calculated diffuse reflection strength.\n */\nexport class DiffuseCompositeMethod extends DiffuseBasicMethod\n{\n\tpublic pBaseMethod:DiffuseBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new <code>DiffuseCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.\n\t * @param baseMethod The base diffuse method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis.pBaseMethod = baseMethod || new DiffuseBasicMethod();\n\t\tthis.pBaseMethod._iModulateMethod = modulateMethod;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base diffuse method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this.pBaseMethod;\n\t}\n\n\tpublic set baseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this.pBaseMethod == value)\n\t\t\treturn;\n\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod = value;\n\t\tthis.pBaseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tthis.pBaseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tthis.pBaseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\tpublic iAddOwner(owner:ISurface):void\n\t{\n\t\tsuper.iAddOwner(owner);\n\n\t\tthis.pBaseMethod.iAddOwner(owner);\n\t}\n\n\tpublic iRemoveOwner(owner:ISurface):void\n\t{\n\t\tsuper.iRemoveOwner(owner);\n\n\t\tthis.pBaseMethod.iRemoveOwner(owner);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose():void\n\t{\n\t\tthis.pBaseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis.pBaseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this.pBaseMethod.texture;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis.pBaseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this.pBaseMethod.color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set color(value:number)\n\t{\n\t\tthis.pBaseMethod.color = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get multiply():boolean\n\t{\n\t\treturn this.pBaseMethod.multiply;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set multiply(value:boolean)\n\t{\n\t\tthis.pBaseMethod.multiply = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this.pBaseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t\tthis._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tthis.pBaseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tthis.pBaseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:LightingShader, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tthis.pBaseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this.pBaseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset():void\n\t{\n\t\tthis.pBaseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData():void\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis.pBaseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent):void\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}",
    "import {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {DiffuseBasicMethod}\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\n\n/**\n * DiffuseDepthMethod provides a debug method to visualise depth maps\n */\nexport class DiffuseDepthMethod extends DiffuseBasicMethod\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = 1.0;\n\t\tdata[index + 1] = 1/255.0;\n\t\tdata[index + 2] = 1/65025.0;\n\t\tdata[index + 3] = 1/16581375.0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement;\n\t\tvar decReg:ShaderRegisterElement;\n\n\t\tif (!this._texture)\n\t\t\tthrow new Error(\"DiffuseDepthMethod requires texture!\");\n\n\t\t// incorporate input from ambient\n\t\tif (shader.numLights > 0) {\n\t\t\tif (sharedRegisters.shadowTarget)\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + sharedRegisters.shadowTarget + \".w\\n\";\n\t\t\tcode += \"add \" + targetReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"sat \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\t\t\tregisterCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);\n\t\t} else {\n\t\t\ttemp = targetReg;\n\t\t}\n\n\t\tdecReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\"dp4 \" + temp + \".x, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"mov \" + temp + \".yz, \" + temp + \".xx\t\t\t\\n\" +\n\t\t\t\"mov \" + temp + \".w, \" + decReg + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + decReg + \".xxx, \" + temp + \".xyz\\n\";\n\n\t\tif (shader.numLights == 0)\n\t\t\treturn code;\n\n\t\tcode += \"mul \" + targetReg + \".xyz, \" + temp + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mov \" + targetReg + \".w, \" + temp + \".w\\n\";\n\n\t\tif (shader.numLights > 0)\n\t\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}",
    "import {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {DiffuseBasicMethod}\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\n\n/**\n * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient\n * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude\n * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate\n * scattered light within the skin attributing to the final colour)\n */\nexport class DiffuseGradientMethod extends DiffuseBasicMethod\n{\n\tprivate _gradient:TextureBase;\n\n\t/**\n\t * Creates a new DiffuseGradientMethod object.\n\t * @param gradient A texture that contains the light colour based on the angle. This can be used to change\n\t * the light colour due to subsurface scattering when the surface faces away from the light.\n\t */\n\tconstructor(gradient:TextureBase)\n\t{\n\t\tsuper();\n\n\t\tthis._gradient = gradient;\n\n\t\tif (this._gradient)\n\t\t\tthis.iAddTexture(this._gradient);\n\t}\n\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._gradient);\n\t}\n\n\t/**\n\t * A texture that contains the light colour based on the angle. This can be used to change the light colour\n\t * due to subsurface scattering when the surface faces away from the light.\n\t */\n\tpublic get gradient():TextureBase\n\t{\n\t\treturn this._gradient;\n\t}\n\n\tpublic set gradient(value:TextureBase)\n\t{\n\t\tif (this._gradient == value)\n\t\t\treturn;\n\n\t\tif (this._gradient)\n\t\t\tthis.iRemoveTexture(this._gradient);\n\n\t\tthis._gradient = value;\n\n\t\tif (this._gradient)\n\t\t\tthis.iAddTexture(this._gradient);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData():void\n\t{\n\t\tsuper.iCleanCompilationData();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + sharedRegisters.commons + \".x\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(t, registerCache, sharedRegisters, t) +\n\t\t\t//\t\t\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + t + \".w\\n\" +\n\t\t\t\"mul \" + t + \".xyz, \" + t + \".xyz, \" + lightColReg + \".xyz\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic pApplyShadow(shader:LightingShader, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar t:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn \"mov \" + t + \", \" + sharedRegisters.shadowTarget + \".wwww\\n\" +\n\t\t\tmethodVO.secondaryTextureGL._iGetFragmentCode(t, regCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tif (shader.numLights > 0)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n}",
    "import {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {DiffuseBasicMethod}\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\nimport {DiffuseCompositeMethod}\t\t\tfrom \"../methods/DiffuseCompositeMethod\";\n\n/**\n * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse\n * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather\n * than only the diffuse lighting value.\n */\nexport class DiffuseLightMapMethod extends DiffuseCompositeMethod\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t * This can be used to add pre-calculated shadows or occlusion.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t * This can be used to add pre-calculated lighting or global illumination.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new DiffuseLightMapMethod method.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\t\tthis._lightMap = lightMap;\n\t\tthis.blendMode = blendMode;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see DiffuseLightMapMethod.ADD\n\t * @see DiffuseLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture containing the light map data.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iRemoveTexture(this._lightMap);\n\n\t\tthis._lightMap = value;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase DiffuseLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase DiffuseLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + this._pTotalLightColorReg + \", \" + this._pTotalLightColorReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcode += super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n}",
    "import {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {DiffuseBasicMethod}\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\nimport {DiffuseCompositeMethod}\t\t\tfrom \"../methods/DiffuseCompositeMethod\";\nimport {SingleObjectDepthPass}\t\t\tfrom \"../surfaces/passes/SingleObjectDepthPass\";\n\n/**\n * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of\n * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.\n * It can be used for candle wax, ice, skin, ...\n */\nexport class DiffuseSubSurfaceMethod extends DiffuseCompositeMethod\n{\n\tprivate _depthPass:SingleObjectDepthPass;\n\tprivate _lightProjVarying:ShaderRegisterElement;\n\tprivate _propReg:ShaderRegisterElement;\n\tprivate _scattering:number;\n\tprivate _translucency:number = 1;\n\tprivate _lightColorReg:ShaderRegisterElement;\n\tprivate _scatterColor:number /*uint*/ = 0xffffff;\n\tprivate _colorReg:ShaderRegisterElement;\n\tprivate _decReg:ShaderRegisterElement;\n\tprivate _scatterR:number = 1.0;\n\tprivate _scatterG:number = 1.0;\n\tprivate _scatterB:number = 1.0;\n\tprivate _targetReg:ShaderRegisterElement;\n\t\n\t/**\n\t * Creates a new <code>DiffuseSubSurfaceMethod</code> object.\n\t *\n\t * @param depthMapSize The size of the depth map used.\n\t * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.\n\t */\n\tconstructor(depthMapSize:number /*int*/ = 512, depthMapOffset:number = 15, baseMethod:DiffuseBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.pBaseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.scatterLight(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\t//this._passes = new Array<MaterialPassGLBase>();\n\t\t//this._depthPass = new SingleObjectDepthPass();\n\t\t//this._depthPass.textureSize = depthMapSize;\n\t\t//this._depthPass.polyOffset = depthMapOffset;\n\t\t//this._passes.push(this._depthPass);\n\t\tthis._scattering = 0.2;\n\t\tthis._translucency = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar data:Float32Array = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryVertexConstantsIndex;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = -.5;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\t\n\t\tdata = shader.fragmentConstantData;\n\t\tindex = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index + 3] = 1.0;\n\t\tdata[index + 4] = 1.0;\n\t\tdata[index + 5] = 1/255;\n\t\tdata[index + 6] = 1/65025;\n\t\tdata[index + 7] = 1/16581375;\n\t\tdata[index + 10] = .5;\n\t\tdata[index + 11] = -.1;\n\t}\n\t\n\tpublic iCleanCompilationData():void\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._lightProjVarying = null;\n\t\tthis._propReg = null;\n\t\tthis._lightColorReg = null;\n\t\tthis._colorReg = null;\n\t\tthis._decReg = null;\n\t\tthis._targetReg = null;\n\t}\n\t\n\t/**\n\t * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low\n\t * values for skin.\n\t */\n\tpublic get scattering():number\n\t{\n\t\treturn this._scattering;\n\t}\n\t\n\tpublic set scattering(value:number)\n\t{\n\t\tthis._scattering = value;\n\t}\n\t\n\t/**\n\t * The translucency of the object.\n\t */\n\tpublic get translucency():number\n\t{\n\t\treturn this._translucency;\n\t}\n\t\n\tpublic set translucency(value:number)\n\t{\n\t\tthis._translucency = value;\n\t}\n\t\n\t/**\n\t * The colour of the \"insides\" of the object, ie: the colour the light becomes after leaving the object.\n\t */\n\tpublic get scatterColor():number /*uint*/\n\t{\n\t\treturn this._scatterColor;\n\t}\n\t\n\tpublic set scatterColor(scatterColor:number /*uint*/)\n\t{\n\t\tthis._scatterColor = scatterColor;\n\t\tthis._scatterR = ((scatterColor >> 16) & 0xff)/0xff;\n\t\tthis._scatterG = ((scatterColor >> 8) & 0xff)/0xff;\n\t\tthis._scatterB = (scatterColor & 0xff)/0xff;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tvar lightProjection:ShaderRegisterElement;\n\t\tvar toTexRegister:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\t\t\n\t\ttoTexRegister = registerCache.getFreeVertexConstant();\n\t\tmethodVO.secondaryVertexConstantsIndex = toTexRegister.index*4;\n\n\t\tthis._lightProjVarying = registerCache.getFreeVarying();\n\t\tlightProjection = registerCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\tregisterCache.getFreeVertexConstant();\n\t\t\n\t\tcode += \"m44 \" + temp + \", vt0, \" + lightProjection + \"\\n\" +\n\t\t\t\"div \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xy\\n\" +\n\t\t\t\"add \" + temp + \".xy, \" + temp + \".xy, \" + toTexRegister + \".xx\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"mov \" + this._lightProjVarying + \".w, va0.w\\n\";\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._colorReg = registerCache.getFreeFragmentConstant();\n\t\tthis._decReg = registerCache.getFreeFragmentConstant();\n\t\tthis._propReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._colorReg.index*4;\n\t\t\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pIsFirstLight = true;\n\t\tthis._lightColorReg = lightColReg;\n\t\treturn super.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\t\n\t\tcode += \"mul \" + temp + \".xyz, \" + this._lightColorReg + \".xyz, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + this._colorReg + \".xyz\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t\n\t\tif (this._targetReg != sharedRegisters.viewDirFragment)\n\t\t\tregisterCache.removeFragmentTempUsage(targetReg);\n\t\t\n\t\treturn code;\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._scatterR;\n\t\tdata[index + 1] = this._scatterG;\n\t\tdata[index + 2] = this._scatterB;\n\t\tdata[index + 8] = this._scattering;\n\t\tdata[index + 9] = this._translucency;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._depthPass._iGetDepthMap(renderable));\n\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\n\t\tthis._depthPass._iGetProjection(renderable).copyRawDataTo(shader.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);\n\t}\n\t\n\t/**\n\t * Generates the code for this method\n\t */\n\tprivate scatterLight(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// only scatter first light\n\t\tif (!this._pIsFirstLight)\n\t\t\treturn \"\";\n\n\t\tthis._pIsFirstLight = false;\n\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.viewDirFragment)\n\t\t\tthis._targetReg = sharedRegisters.viewDirFragment;\n\t\telse\n\t\t\tregisterCache.addFragmentTempUsages(this._targetReg = registerCache.getFreeFragmentVectorTemp(), 1);\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._lightProjVarying) +\n\t\t\t// reencode RGBA\n\t\t\t\"dp4 \" + targetReg + \".z, \" + temp + \", \" + this._decReg + \"\\n\";\n\t\t// currentDistanceToLight - closestDistanceToLight\n\t\tcode += \"sub \" + targetReg + \".z, \" + this._lightProjVarying + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t\"sub \" + targetReg + \".z, \" + this._propReg + \".x, \" + targetReg + \".z\\n\" +\n\t\t\t\"mul \" + targetReg + \".z, \" + this._propReg + \".y, \" + targetReg + \".z\\n\" +\n\t\t\t\"sat \" + targetReg + \".z, \" + targetReg + \".z\\n\" +\n\t\t\t\n\t\t\t// targetReg.x contains dot(lightDir, normal)\n\t\t\t// modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)\n\t\t\t\"neg \" + targetReg + \".y, \" + targetReg + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".y, \" + this._propReg + \".z\\n\" +\n\t\t\t\"mul \" + this._targetReg + \".w, \" + targetReg + \".z, \" + targetReg + \".y\\n\" +\n\t\t\t\n\t\t\t// blend diffuse: d' = (1-s)*d + s*1\n\t\t\t\"sub \" + targetReg + \".y, \" + this._colorReg + \".w, \" + this._targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t\t\n\t\treturn code;\n\t}\n}",
    "import {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {DiffuseBasicMethod}\t\t\t\tfrom \"../methods/DiffuseBasicMethod\";\n\n/**\n * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be \"wrapped around\" the normally dark area, to some extent.\n * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.\n */\nexport class DiffuseWrapMethod extends DiffuseBasicMethod\n{\n\tprivate _wrapDataRegister:ShaderRegisterElement;\n\tprivate _wrapFactor:number;\n\n\t/**\n\t * Creates a new DiffuseWrapMethod object.\n\t * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap\n\t */\n\tconstructor(wrapFactor:number = .5)\n\t{\n\t\tsuper();\n\n\t\tthis.wrapFactor = wrapFactor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData():void\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._wrapDataRegister = null;\n\t}\n\n\t/**\n\t * A factor to indicate the amount by which the light is allowed to wrap.\n\t */\n\tpublic get wrapFactor():number\n\t{\n\t\treturn this._wrapFactor;\n\t}\n\n\tpublic set wrapFactor(value:number)\n\t{\n\t\tthis._wrapFactor = value;\n\t\tthis._wrapFactor = 1/(value + 1);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t\tthis._pIsFirstLight = true;\n\t\tthis._wrapDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index*4;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tcode += \"dp3 \" + t + \".x, \" + lightDirReg + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + t + \".y, \" + t + \".x, \" + this._wrapDataRegister + \".x\\n\" +\n\t\t\t\"mul \" + t + \".y, \" + t + \".y, \" + this._wrapDataRegister + \".y\\n\" +\n\t\t\t\"sat \" + t + \".w, \" + t + \".y\\n\" +\n\t\t\t\"mul \" + t + \".xz, \" + t + \".w, \" + lightDirReg + \".wz\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, lightDirReg, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \", \" + t + \".x, \" + lightColReg + \"\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._wrapFactor;\n\t\tdata[index + 1] = 1/(this._wrapFactor + 1);\n\t}\n}",
    "import {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {EffectMethodBase}\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used\n * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water\n * etc).\n */\nexport class EffectAlphaMaskMethod extends EffectMethodBase\n{\n\tprivate _texture:TextureBase;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectAlphaMaskMethod object.\n\t *\n\t * @param texture The texture to use as the alpha mask.\n\t * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.\n\t */\n\tconstructor(texture:TextureBase, useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for\n\t * instance to tile the main texture and normal map while providing untiled alpha, for example to define the\n\t * transparency over a tiled water surface.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The texture to use as the alpha mask.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \".x\\n\";\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n}",
    "import {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {EffectMethodBase}\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.\n */\nexport class EffectColorMatrixMethod extends EffectMethodBase\n{\n\tprivate _matrix:Array<number>;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t *\n\t * @param matrix An array of 20 items for 4 x 5 color transform.\n\t */\n\tconstructor(matrix:Array<number>)\n\t{\n\t\tsuper();\n\n\t\tif (matrix.length != 20)\n\t\t\tthrow new Error(\"Matrix length must be 20!\");\n\n\t\tthis._matrix = matrix;\n\t}\n\n\t/**\n\t * The 4 x 5 matrix to transform the color of the material.\n\t */\n\tpublic get colorMatrix():Array<number>\n\t{\n\t\treturn this._matrix;\n\t}\n\n\tpublic set colorMatrix(value:Array<number>)\n\t{\n\t\tthis._matrix = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\t\tregisterCache.getFreeFragmentConstant();\n\n\t\tvar colorOffsetReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode += \"m44 \" + temp + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + temp + \", \" + colorOffsetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tvar matrix:Array<number> = this._matrix;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\t// r\n\t\tdata[index] = matrix[0];\n\t\tdata[index + 1] = matrix[1];\n\t\tdata[index + 2] = matrix[2];\n\t\tdata[index + 3] = matrix[3];\n\n\t\t// g\n\t\tdata[index + 4] = matrix[5];\n\t\tdata[index + 5] = matrix[6];\n\t\tdata[index + 6] = matrix[7];\n\t\tdata[index + 7] = matrix[8];\n\n\t\t// b\n\t\tdata[index + 8] = matrix[10];\n\t\tdata[index + 9] = matrix[11];\n\t\tdata[index + 10] = matrix[12];\n\t\tdata[index + 11] = matrix[13];\n\n\t\t// a\n\t\tdata[index + 12] = matrix[15];\n\t\tdata[index + 13] = matrix[16];\n\t\tdata[index + 14] = matrix[17];\n\t\tdata[index + 15] = matrix[18];\n\n\t\t// rgba offset\n\t\tdata[index + 16] = matrix[4];\n\t\tdata[index + 17] = matrix[9];\n\t\tdata[index + 18] = matrix[14];\n\t\tdata[index + 19] = matrix[19];\n\t}\n}",
    "import {ColorTransform}\t\t\t\tfrom \"awayjs-core/lib/geom/ColorTransform\";\n\nimport {Stage}\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {ShaderBase}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {EffectMethodBase}\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a\n * ColorTransform object.\n */\nexport class EffectColorTransformMethod extends EffectMethodBase\n{\n\tprivate _colorTransform:ColorTransform;\n\n\t/**\n\t * Creates a new EffectColorTransformMethod.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this._colorTransform;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tthis._colorTransform = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar colorMultReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar colorOffsReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = colorMultReg.index*4;\n\n\t\t//TODO: AGAL <> GLSL\n\n\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + colorMultReg + \"\\n\" + \"add \" + targetReg + \", \" + targetReg + \", \" + colorOffsReg + \"\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tvar inv:number = 1/0xff;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\tdata[index] = this._colorTransform.redMultiplier;\n\t\tdata[index + 1] = this._colorTransform.greenMultiplier;\n\t\tdata[index + 2] = this._colorTransform.blueMultiplier;\n\t\tdata[index + 3] = this._colorTransform.alphaMultiplier;\n\t\tdata[index + 4] = this._colorTransform.redOffset*inv;\n\t\tdata[index + 5] = this._colorTransform.greenOffset*inv;\n\t\tdata[index + 6] = this._colorTransform.blueOffset*inv;\n\t\tdata[index + 7] = this._colorTransform.alphaOffset*inv;\n\n\t}\n}",
    "import {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {EffectMethodBase}\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.\n */\nexport class EffectEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates an EffectEnvMapMethod object.\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the surface.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (value == this._mask)\n\t\t\treturn;\n\n\t\tif (this._mask)\n\t\t\tthis.iRemoveTexture(this._mask);\n\n\t\tthis._mask = value;\n\n\t\tif (this._mask)\n\t\t\tthis.iAddTexture(this._mask);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tif (this._envMap)\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._envMap);\n\n\t\tif (this._mask) {\n\t\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose():void\n\t{\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\t// r = I - 2(I.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + sharedRegisters.normalFragment + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" + // -.5\n\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\tif (this._mask) {\n\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + temp + \", \" + temp2 + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + dataRegister + \".x\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}",
    "import {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {EffectMethodBase}\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectFogMethod provides a method to add distance-based fog to a material.\n */\nexport class EffectFogMethod extends EffectMethodBase\n{\n\tprivate _minDistance:number = 0;\n\tprivate _maxDistance:number = 1000;\n\tprivate _fogColor:number /*uint*/;\n\tprivate _fogR:number;\n\tprivate _fogG:number;\n\tprivate _fogB:number;\n\n\t/**\n\t * Creates a new EffectFogMethod object.\n\t * @param minDistance The distance from which the fog starts appearing.\n\t * @param maxDistance The distance at which the fog is densest.\n\t * @param fogColor The colour of the fog.\n\t */\n\tconstructor(minDistance:number, maxDistance:number, fogColor:number /*uint*/ = 0x808080)\n\t{\n\t\tsuper();\n\t\tthis.minDistance = minDistance;\n\t\tthis.maxDistance = maxDistance;\n\t\tthis.fogColor = fogColor;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 6] = 0;\n\t\tdata[index + 7] = 0;\n\t}\n\n\t/**\n\t * The distance from which the fog starts appearing.\n\t */\n\tpublic get minDistance():number\n\t{\n\t\treturn this._minDistance;\n\t}\n\n\tpublic set minDistance(value:number)\n\t{\n\t\tthis._minDistance = value;\n\t}\n\n\t/**\n\t * The distance at which the fog is densest.\n\t */\n\tpublic get maxDistance():number\n\t{\n\t\treturn this._maxDistance;\n\t}\n\n\tpublic set maxDistance(value:number)\n\t{\n\t\tthis._maxDistance = value;\n\t}\n\n\t/**\n\t * The colour of the fog.\n\t */\n\tpublic get fogColor():number /*uint*/\n\t{\n\t\treturn this._fogColor;\n\t}\n\n\tpublic set fogColor(value:number/*uint*/)\n\t{\n\t\tthis._fogColor = value;\n\t\tthis._fogR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._fogG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._fogB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._fogR;\n\t\tdata[index + 1] = this._fogG;\n\t\tdata[index + 2] = this._fogB;\n\t\tdata[index + 4] = this._minDistance;\n\t\tdata[index + 5] = 1/(this._maxDistance - this._minDistance);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar fogColor:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar fogData:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\t\tmethodVO.fragmentConstantsIndex = fogColor.index*4;\n\n\t\tcode += \"sub \" + temp2 + \".w, \" + sharedRegisters.projectionFragment + \".z, \" + fogData + \".x\\n\" +\n\t\t\t\t\"mul \" + temp2 + \".w, \" + temp2 + \".w, \" + fogData + \".y\\n\" +\n\t\t\t\t\"sat \" + temp2 + \".w, \" + temp2 + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \", \" + fogColor + \", \" + targetReg + \"\\n\" + // (fogColor- col)\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + temp2 + \".w\\n\" + // (fogColor- col)*fogRatio\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\"; // fogRatio*(fogColor- col) + col\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}",
    "import {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {EffectMethodBase}\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets\n * stronger as the viewing angle becomes more grazing.\n */\nexport class EffectFresnelEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = 0;\n\tprivate _alpha:number;\n\tprivate _mask:TextureBase;\n\n\t/**\n\t * Creates a new <code>EffectFresnelEnvMapMethod</code> object.\n\t *\n\t * @param envMap The environment map containing the reflected scene.\n\t * @param alpha The reflectivity of the material.\n\t */\n\tconstructor(envMap:TextureBase, alpha:number = 1)\n\t{\n\t\tsuper();\n\n\t\tthis._envMap = envMap;\n\t\tthis._alpha = alpha;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._envMap);\n\n\t\tif (this._mask != null) {\n\t\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._mask);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * An optional texture to modulate the reflectivity of the surface.\n\t */\n\tpublic get mask():TextureBase\n\t{\n\t\treturn this._mask;\n\t}\n\n\tpublic set mask(value:TextureBase)\n\t{\n\t\tif (this._mask == value)\n\t\t\treturn;\n\n\t\tif (this._mask)\n\t\t\tthis.iRemoveTexture(this._mask);\n\n\t\tthis._mask = value;\n\n\t\tif (this._mask)\n\t\t\tthis.iAddTexture(this._mask);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * The cubic environment map containing the reflected scene.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * The reflectivity of the surface.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index] = this._alpha;\n\t\tdata[index + 1] = this._normalReflectance;\n\t\tdata[index + 2] = this._fresnelPower;\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\n\t\tif (this._mask)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar temp2:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp2, 1);\n\n\t\t// r = V - 2(V.N)*N\n\t\tcode += \"dp3 \" + temp + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"add \" + temp + \".w, \" + temp + \".w, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + normalReg + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".xyz, \" + temp + \".xyz, \" + viewDirReg + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\t\t\t\t\"sub \" + temp2 + \".w, \" + temp + \".w, fc0.x\\n\" +               \t// -.5\n\t\t\t\t\"kil \" + temp2 + \".w\\n\" +\t// used for real time reflection mapping - if alpha is not 1 (mock texture) kil output\n\t\t\t\t\"sub \" + temp + \", \" + temp + \", \" + targetReg + \"\\n\";\n\n\t\t// calculate fresnel term\n\t\tcode += \"dp3 \" + viewDirReg + \".w, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +  // dot(V, H)\n\t\t\t\t\"sub \" + viewDirReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +       // base = 1-dot(V, H)\n\t\t\t\t\"pow \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + dataRegister + \".z\\n\" +       // exp = pow(base, 5)\n\t\t\t\t\"sub \" + normalReg + \".w, \" + dataRegister + \".w, \" + viewDirReg + \".w\\n\" +        // 1 - exp\n\t\t\t\t\"mul \" + normalReg + \".w, \" + dataRegister + \".y, \" + normalReg + \".w\\n\" +         // f0*(1 - exp)\n\t\t\t\t\"add \" + viewDirReg + \".w, \" + viewDirReg + \".w, \" + normalReg + \".w\\n\" +          // exp + f0*(1 - exp)\n\n\t\t\t\t// total alpha\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + dataRegister + \".x, \" + viewDirReg + \".w\\n\";\n\n\t\tif (this._mask) {\n\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\t\t\t\t\"mul \" + viewDirReg + \".w, \" + temp2 + \".x, \" + viewDirReg + \".w\\n\";\n\t\t}\n\n\t\t// blend\n\t\tcode += \"mul \" + temp + \", \" + temp + \", \" + viewDirReg + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(temp2);\n\n\t\treturn code;\n\t}\n}",
    "import {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {EffectMethodBase}\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.\n * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather\n * than the whole pixel colour.\n */\nexport class EffectLightMapMethod extends EffectMethodBase\n{\n\t/**\n\t * Indicates the light map should be multiplied with the calculated shading result.\n\t */\n\tpublic static MULTIPLY:string = \"multiply\";\n\n\t/**\n\t * Indicates the light map should be added into the calculated shading result.\n\t */\n\tpublic static ADD:string = \"add\";\n\n\tprivate _lightMap:TextureBase;\n\n\tprivate _blendMode:string;\n\tprivate _useSecondaryUV:boolean;\n\n\t/**\n\t * Creates a new EffectLightMapMethod object.\n\t *\n\t * @param lightMap The texture containing the light map.\n\t * @param blendMode The blend mode with which the light map should be applied to the lighting result.\n\t * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tconstructor(lightMap:TextureBase, blendMode:string = \"multiply\", useSecondaryUV:boolean = false)\n\t{\n\t\tsuper();\n\n\t\tif (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._lightMap = lightMap;\n\t\tthis._blendMode = blendMode;\n\t\tthis._useSecondaryUV = useSecondaryUV;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tmethodVO.textureGL = shader.getAbstraction(this._lightMap);\n\n\t\tif (this._useSecondaryUV)\n\t\t\tshader.secondaryUVDependencies++;\n\t\telse\n\t\t\tshader.uvDependencies++;\n\t}\n\n\t/**\n\t * The blend mode with which the light map should be applied to the lighting result.\n\t *\n\t * @see EffectLightMapMethod.ADD\n\t * @see EffectLightMapMethod.MULTIPLY\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tif (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)\n\t\t\tthrow new Error(\"Unknown blendmode!\");\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The lightMap containing the light map.\n\t */\n\tpublic get lightMap():TextureBase\n\t{\n\t\treturn this._lightMap;\n\t}\n\n\tpublic set lightMap(value:TextureBase)\n\t{\n\t\tif (this._lightMap == value)\n\t\t\treturn;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iRemoveTexture(this._lightMap);\n\n\t\tthis._lightMap = value;\n\n\t\tif (this._lightMap)\n\t\t\tthis.iAddTexture(this._lightMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Indicates whether the secondary UV set should be used to map the light map.\n\t */\n\tpublic get useSecondaryUV():boolean\n\t{\n\t\treturn this._useSecondaryUV;\n\t}\n\n\tpublic set useSecondaryUV(value:boolean)\n\t{\n\t\tif (this._useSecondaryUV == value)\n\t\t\treturn;\n\n\t\tthis._useSecondaryUV = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\tcode = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);\n\n\t\tswitch (this._blendMode) {\n\t\t\tcase EffectLightMapMethod.MULTIPLY:\n\t\t\t\tcode += \"mul \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t\tcase EffectLightMapMethod.ADD:\n\t\t\t\tcode += \"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\\n\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n}",
    "import {IAsset}\t\t\t\t\t\tfrom \"awayjs-core/lib/library/IAsset\";\nimport {AbstractMethodError}\t\t\tfrom \"awayjs-core/lib/errors/AbstractMethodError\";\n\nimport {ShaderBase}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {ShadingMethodBase}\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,\n * and are in essence post-process effects on the materials.\n */\nexport class EffectMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset EffectMethod]\";\n\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn EffectMethodBase.assetType;\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register that will be containing the method's output.\n\t * @private\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t}\n}",
    "import {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {EffectMethodBase}\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.\n */\nexport class EffectRefractionEnvMapMethod extends EffectMethodBase\n{\n\tprivate _envMap:TextureBase;\n\n\tprivate _dispersionR:number = 0;\n\tprivate _dispersionG:number = 0;\n\tprivate _dispersionB:number = 0;\n\tprivate _useDispersion:boolean;\n\tprivate _refractionIndex:number;\n\tprivate _alpha:number = 1;\n\n\t/**\n\t * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015\n\t *\n\t * @param envMap The environment map containing the refracted scene.\n\t * @param refractionIndex The refractive index of the material.\n\t * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tconstructor(envMap:TextureBase, refractionIndex:number = .1, dispersionR:number = 0, dispersionG:number = 0, dispersionB:number = 0)\n\t{\n\t\tsuper();\n\t\tthis._envMap = envMap;\n\t\tthis._dispersionR = dispersionR;\n\t\tthis._dispersionG = dispersionG;\n\t\tthis._dispersionB = dispersionB;\n\t\tthis._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tthis._refractionIndex = refractionIndex;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index + 4] = 1;\n\t\tdata[index + 5] = 0;\n\t\tdata[index + 7] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._envMap);\n\t}\n\n\t/**\n\t * The cube environment map to use for the refraction.\n\t */\n\tpublic get envMap():TextureBase\n\t{\n\t\treturn this._envMap;\n\t}\n\n\tpublic set envMap(value:TextureBase)\n\t{\n\t\tif (this._envMap == value)\n\t\t\treturn;\n\n\t\tif (this._envMap)\n\t\t\tthis.iRemoveTexture(this._envMap);\n\n\t\tthis._envMap = value;\n\n\t\tif (this._envMap)\n\t\t\tthis.iAddTexture(this._envMap);\n\t}\n\n\t/**\n\t * The refractive index of the material.\n\t */\n\tpublic get refractionIndex():number\n\t{\n\t\treturn this._refractionIndex;\n\t}\n\n\tpublic set refractionIndex(value:number)\n\t{\n\t\tthis._refractionIndex = value;\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionR():number\n\t{\n\t\treturn this._dispersionR;\n\t}\n\n\tpublic set dispersionR(value:number)\n\t{\n\t\tthis._dispersionR = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionG():number\n\t{\n\t\treturn this._dispersionG;\n\t}\n\n\tpublic set dispersionG(value:number)\n\t{\n\t\tthis._dispersionG = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).\n\t */\n\tpublic get dispersionB():number\n\t{\n\t\treturn this._dispersionB;\n\t}\n\n\tpublic set dispersionB(value:number)\n\t{\n\t\tthis._dispersionB = value;\n\n\t\tvar useDispersion:boolean = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);\n\t\tif (this._useDispersion != useDispersion) {\n\t\t\tthis.iInvalidateShaderProgram();\n\t\t\tthis._useDispersion = useDispersion;\n\t\t}\n\t}\n\n\t/**\n\t * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual\n\t * material. A value of 1 will make it appear fully transparent.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\n\t\tdata[index] = this._dispersionR + this._refractionIndex;\n\n\t\tif (this._useDispersion) {\n\t\t\tdata[index + 1] = this._dispersionG + this._refractionIndex;\n\t\t\tdata[index + 2] = this._dispersionB + this._refractionIndex;\n\t\t}\n\t\tdata[index + 3] = this._alpha;\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: data2.x could use common reg, so only 1 reg is used\n\t\tvar data:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar data2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar code:string = \"\";\n\t\tvar refractionDir:ShaderRegisterElement;\n\t\tvar refractionColor:ShaderRegisterElement;\n\t\tvar temp:ShaderRegisterElement;\n\n\t\tmethodVO.fragmentConstantsIndex = data.index*4;\n\n\t\trefractionDir = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionDir, 1);\n\t\trefractionColor = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(refractionColor, 1);\n\t\ttemp = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".w, \" + data + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\"mul \" + temp + \".x, \" + data + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\"mul \" + refractionDir + \", \" + data + \".x, \" + viewDirReg + \"\\n\" +\n\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\tmethodVO.textureGL._iGetFragmentCode(refractionColor, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\"sub \" + refractionColor + \".w, \" + refractionColor + \".w, fc0.x\t\\n\" +\n\t\t\t\"kil \" + refractionColor + \".w\\n\";\n\n\t\tif (this._useDispersion) {\n\t\t\t// GREEN\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".y, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".y, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".y, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".y, \" + temp + \".y\\n\";\n\n\t\t\t// BLUE\n\t\t\tcode += \"dp3 \" + temp + \".x, \" + viewDirReg + \".xyz, \" + normalReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"mul \" + temp + \".w, \" + data + \".z, \" + temp + \".w\\n\" +\n\t\t\t\t\"sub \" + temp + \".w, \" + data2 + \".x, \" + temp + \".w\\n\" +\n\t\t\t\t\"sqt \" + temp + \".y, \" + temp + \".w\\n\" +\n\n\t\t\t\t\"mul \" + temp + \".x, \" + data + \".z, \" + temp + \".x\\n\" +\n\t\t\t\t\"add \" + temp + \".x, \" + temp + \".x, \" + temp + \".y\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".x, \" + normalReg + \".xyz\\n\" +\n\n\t\t\t\t\"mul \" + refractionDir + \", \" + data + \".z, \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"sub \" + refractionDir + \".xyz, \" + refractionDir + \".xyz, \" + temp + \".xyz\\n\" +\n\t\t\t\t\"nrm \" + refractionDir + \".xyz, \" + refractionDir + \".xyz\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +\n\t\t\t\t\"mov \" + refractionColor + \".z, \" + temp + \".z\\n\";\n\t\t}\n\n\t\tcode += \"sub \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\"mul \" + refractionColor + \".xyz, \" + refractionColor + \".xyz, \" + data + \".w\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + refractionColor + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(refractionDir);\n\t\tregisterCache.removeFragmentTempUsage(refractionColor);\n\n\t\t// restore\n\t\tcode += \"neg \" + viewDirReg + \".xyz, \" + viewDirReg + \".xyz\\n\";\n\n\t\treturn code;\n\t}\n}",
    "import {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {EffectMethodBase}\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.\n */\nexport class EffectRimLightMethod extends EffectMethodBase\n{\n\tpublic static ADD:string = \"add\";\n\tpublic static MULTIPLY:string = \"multiply\";\n\tpublic static MIX:string = \"mix\";\n\n\tprivate _color:number /*uint*/;\n\tprivate _blendMode:string;\n\tprivate _colorR:number;\n\tprivate _colorG:number;\n\tprivate _colorB:number;\n\tprivate _strength:number;\n\tprivate _power:number;\n\n\t/**\n\t * Creates a new <code>EffectRimLightMethod</code> object.\n\t *\n\t * @param color The colour of the rim light.\n\t * @param strength The strength of the rim light.\n\t * @param power The power of the rim light. Higher values will result in a higher edge fall-off.\n\t * @param blend The blend mode with which to add the light to the object.\n\t */\n\tconstructor(color:number /*uint*/ = 0xffffff, strength:number = .4, power:number = 2, blend:string = \"mix\")\n\t{\n\t\tsuper();\n\n\t\tthis._blendMode = blend;\n\t\tthis._strength = strength;\n\t\tthis._power = power;\n\n\t\tthis.color = color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tmethodVO.needsNormals = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\n\t/**\n\t * The blend mode with which to add the light to the object.\n\t *\n\t * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.\n\t * EffectRimLightMethod.ADD adds the rim light with the material's colour.\n\t * EffectRimLightMethod.MIX provides normal alpha blending.\n\t */\n\tpublic get blendMode():string\n\t{\n\t\treturn this._blendMode;\n\t}\n\n\tpublic set blendMode(value:string)\n\t{\n\t\tif (this._blendMode == value)\n\t\t\treturn;\n\n\t\tthis._blendMode = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The color of the rim light.\n\t */\n\tpublic get color():number /*uint*/\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number /*uint*/)\n\t{\n\t\tthis._color = value;\n\t\tthis._colorR = ((value >> 16) & 0xff)/0xff;\n\t\tthis._colorG = ((value >> 8) & 0xff)/0xff;\n\t\tthis._colorB = (value & 0xff)/0xff;\n\t}\n\n\t/**\n\t * The strength of the rim light.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._strength = value;\n\t}\n\n\t/**\n\t * The power of the rim light. Higher values will result in a higher edge fall-off.\n\t */\n\tpublic get power():number\n\t{\n\t\treturn this._power;\n\t}\n\n\tpublic set power(value:number)\n\t{\n\t\tthis._power = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._colorR;\n\t\tdata[index + 1] = this._colorG;\n\t\tdata[index + 2] = this._colorB;\n\t\tdata[index + 4] = this._strength;\n\t\tdata[index + 5] = this._power;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar dataRegister:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataRegister2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tvar code:string = \"\";\n\n\t\tmethodVO.fragmentConstantsIndex = dataRegister.index*4;\n\n\t\tcode += \"dp3 \" + temp + \".x, \" + sharedRegisters.viewDirFragment + \".xyz, \" + sharedRegisters.normalFragment + \".xyz\\n\" +\n\t\t\t\"sat \" + temp + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"pow \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".y\\n\" +\n\t\t\t\"mul \" + temp + \".x, \" + temp + \".x, \" + dataRegister2 + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".x, \" + dataRegister + \".w, \" + temp + \".x\\n\" +\n\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".x\\n\" +\n\t\t\t\"sub \" + temp + \".w, \" + dataRegister + \".w, \" + temp + \".x\\n\";\n\n\t\tif (this._blendMode == EffectRimLightMethod.ADD) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {\n\t\t\tcode += \"mul \" + temp + \".xyz, \" + temp + \".w, \" + dataRegister + \".xyz\\n\" +\n\t\t\t\t\"mul \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t} else {\n\t\t\tcode += \"sub \" + temp + \".xyz, \" + dataRegister + \".xyz, \" + targetReg + \".xyz\\n\" +\n\t\t\t\t\"mul \" + temp + \".xyz, \" + temp + \".xyz, \" + temp + \".w\\n\" +\n\t\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + temp + \".xyz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n}",
    "import {ShaderBase}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {LightingShader}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderRegisterCache}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {ShadingMethodBase}\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * LightingMethodBase provides an abstract base method for shading methods that uses lights.\n * Used for diffuse and specular shaders only.\n */\nexport class LightingMethodBase extends ShadingMethodBase\n{\n\t/**\n\t * A method that is exposed to wrappers in case the strength needs to be controlled\n\t */\n\tpublic _iModulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string;\n\n\t/**\n\t * Creates a new LightingMethodBase.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * Get the fragment shader code that will be needed before any per-light code is added.\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @private\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param lightDirReg The register containing the light direction vector.\n\t * @param lightColReg The register containing the light colour.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that will generate the code relevant to a single light probe object.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param cubeMapReg The register containing the cube map for the current probe\n\t * @param weightRegister A string representation of the register + component containing the current weight\n\t * @param regCache The register cache providing any necessary registers to the shader\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.\n\t *\n\t * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register containing the final shading output.\n\t * @private\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n}",
    "import {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {ShadingMethodBase}\t\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * NormalBasicMethod is the default method for standard tangent-space normal mapping.\n */\nexport class NormalBasicMethod extends ShadingMethodBase\n{\n\tprivate _texture:TextureBase;\n\n\t/**\n\t * Creates a new NormalBasicMethod object.\n\t */\n\tconstructor(texture:TextureBase = null)\n\t{\n\t\tsuper();\n\n\t\tthis._texture = texture;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\tif (this._texture && shader.normalDependencies)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iOutputsTangentNormals():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase):void\n\t{\n\t\tvar s:any = method;\n\t\tvar bnm:NormalBasicMethod = <NormalBasicMethod> method;\n\n\t\tif (bnm.texture != null)\n\t\t\tthis.texture = bnm.texture;\n\t}\n\n\t/**\n\t * A texture to modulate the direction of the surface for each texel (normal map). The default normal method expects\n\t * tangent-space normal maps, but others could expect object-space maps.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose():void\n\t{\n\t\tif (this._texture)\n\t\t\tthis._texture = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._texture)\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\n\n\t\tcode += \"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \"\\n\";\n\n\t\treturn code;\n\t}\n}",
    "import {Single2DTexture}\t\t\t\t\tfrom \"awayjs-display/lib/textures/Single2DTexture\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {NormalBasicMethod}\t\t\t\tfrom \"../methods/NormalBasicMethod\";\nimport {ShadingMethodBase}\t\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.\n */\nexport class NormalHeightMapMethod extends NormalBasicMethod\n{\n\tprivate _worldXYRatio:number;\n\tprivate _worldXZRatio:number;\n\n\t/**\n\t * Creates a new NormalHeightMapMethod method.\n\t *\n\t * @param heightMap The texture containing the height data. 0 means low, 1 means high.\n\t * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.\n\t * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.\n\t * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.\n\t */\n\tconstructor(heightMap:TextureBase, worldWidth:number, worldHeight:number, worldDepth:number)\n\t{\n\t\tsuper();\n\n\t\tthis.texture = heightMap;\n\t\tthis._worldXYRatio = worldWidth/worldHeight;\n\t\tthis._worldXZRatio = worldDepth/worldHeight;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = 1/(<Single2DTexture> this.texture).image2D.width;\n\t\tdata[index + 1] = 1/(<Single2DTexture> this.texture).image2D.height;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t\tdata[index + 4] = this._worldXYRatio;\n\t\tdata[index + 5] = this._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get tangentSpace():boolean\n\t{\n\t\treturn false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase):void\n\t{\n\t\tsuper.copyFrom(method);\n\n\t\tthis._worldXYRatio = (<NormalHeightMapMethod> method)._worldXYRatio;\n\t\tthis._worldXZRatio = (<NormalHeightMapMethod> method)._worldXZRatio;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode+= methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying) +\n\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".xzzz\\n\" +\n\n\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\n\t\t\t\"sub \" + targetReg + \".x, \" + targetReg + \".x, \" + temp + \".x\\n\" +\n\t\t\t\"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg + \".zyzz\\n\" +\n\n\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +\n\n\t\t\t\"sub \" + targetReg + \".z, \" + targetReg + \".z, \" + temp + \".x\\n\" +\n\t\t\t\"mov \" + targetReg + \".y, \" + dataReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".xz, \" + targetReg + \".xz, \" + dataReg2 + \".xy\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\n\t\treturn code;\n\t}\n}",
    "import {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {NormalBasicMethod}\t\t\t\tfrom \"../methods/NormalBasicMethod\";\n\n/**\n * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.\n */\nexport class NormalSimpleWaterMethod extends NormalBasicMethod\n{\n\tprivate _secondaryNormalMap:TextureBase;\n\tprivate _water1OffsetX:number = 0;\n\tprivate _water1OffsetY:number = 0;\n\tprivate _water2OffsetX:number = 0;\n\tprivate _water2OffsetY:number = 0;\n\n\t/**\n\t * Creates a new NormalSimpleWaterMethod object.\n\t * @param waveMap1 A normal map containing one layer of a wave structure.\n\t * @param waveMap2 A normal map containing a second layer of a wave structure.\n\t */\n\tconstructor(normalMap:TextureBase = null, secondaryNormalMap:TextureBase = null)\n\t{\n\t\tsuper(normalMap);\n\n\t\tthis._secondaryNormalMap = secondaryNormalMap;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iAddTexture(this._secondaryNormalMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = .5;\n\t\tdata[index + 1] = 0;\n\t\tdata[index + 2] = 0;\n\t\tdata[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\t\t\n\t\tif (this._secondaryNormalMap) {\n\t\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(this._secondaryNormalMap);\n\t\t\tshader.uvDependencies++;\n\t\t}\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the X-axis.\n\t */\n\tpublic get water1OffsetX():number\n\t{\n\t\treturn this._water1OffsetX;\n\t}\n\n\tpublic set water1OffsetX(value:number)\n\t{\n\t\tthis._water1OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the first wave layer along the Y-axis.\n\t */\n\tpublic get water1OffsetY():number\n\t{\n\t\treturn this._water1OffsetY;\n\t}\n\n\tpublic set water1OffsetY(value:number)\n\t{\n\t\tthis._water1OffsetY = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the X-axis.\n\t */\n\tpublic get water2OffsetX():number\n\t{\n\t\treturn this._water2OffsetX;\n\t}\n\n\tpublic set water2OffsetX(value:number)\n\t{\n\t\tthis._water2OffsetX = value;\n\t}\n\n\t/**\n\t * The translation of the second wave layer along the Y-axis.\n\t */\n\tpublic get water2OffsetY():number\n\t{\n\t\treturn this._water2OffsetY;\n\t}\n\n\tpublic set water2OffsetY(value:number)\n\t{\n\t\tthis._water2OffsetY = value;\n\t}\n\n\t/**\n\t * A second normal map that will be combined with the first to create a wave-like animation pattern.\n\t */\n\tpublic get secondaryNormalMap():TextureBase\n\t{\n\t\treturn this._secondaryNormalMap;\n\t}\n\n\tpublic set secondaryNormalMap(value:TextureBase)\n\t{\n\t\tif (this._secondaryNormalMap == value)\n\t\t\treturn;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iRemoveTexture(this._secondaryNormalMap);\n\n\t\tthis._secondaryNormalMap = value;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tthis.iAddTexture(this._secondaryNormalMap);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose():void\n\t{\n\t\tsuper.dispose();\n\n\t\tthis._secondaryNormalMap = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\n\t\tdata[index + 4] = this._water1OffsetX;\n\t\tdata[index + 5] = this._water1OffsetY;\n\t\tdata[index + 6] = this._water2OffsetX;\n\t\tdata[index + 7] = this._water2OffsetY;\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg2:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".xyxy\\n\";\n\n\t\tif (this.texture)\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, temp);\n\n\t\tcode += \"add \" + temp + \", \" + sharedRegisters.uvVarying + \", \" + dataReg2 + \".zwzw\\n\";\n\n\t\tif (this._secondaryNormalMap)\n\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp);\n\n\t\tcode +=\t\"add \" + targetReg + \", \" + targetReg + \", \" + temp + \"\t\t\\n\" +\n\t\t\t\"mul \" + targetReg + \", \" + targetReg + \", \" + dataReg + \".x\t\\n\" +\n\t\t\t\"sub \" + targetReg + \".xyz, \" + targetReg + \".xyz, \" + sharedRegisters.commons + \".xxx\t\\n\" +\n\t\t\t\"nrm \" + targetReg + \".xyz, \" + targetReg + \".xyz\t\t\t\t\t\t\t\\n\";\n\n\t\treturn code;\n\t}\n}",
    "import {AssetBase}\t\t\t\t\tfrom \"awayjs-core/lib/library/AssetBase\";\n\nimport {Camera}\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {ISurface}\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\nimport {TextureBase}\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {ShadingMethodEvent}\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport {ShaderBase}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\tfrom \"../data/MethodVO\";\n\n\n/**\n * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile\n * the final shading program.\n */\nexport class ShadingMethodBase extends AssetBase\n{\n\tpublic _textures:Array<TextureBase> = new Array<TextureBase>();\n\n\tpublic _owners:Array<ISurface> = new Array<ISurface>();\n\tpublic _counts:Array<number> = new Array<number>();\n\n\tpublic static assetType:string = \"[asset ShadingMethod]\";\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadingMethodBase.assetType;\n\t}\n\n\t/**\n\t * Create a new ShadingMethodBase object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:ShaderBase):boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Initializes the properties for a MethodVO, including register and texture indices.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitVO(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\n\t}\n\n\t/**\n\t * Initializes unchanging shader constants using the data from a MethodVO.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t *\n\t * @internal\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\n\n\t}\n\n\t/**\n\t * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.\n\t */\n\tpublic iUsesTangentSpace():boolean\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * Cleans up any resources used by the current object.\n\t */\n\tpublic dispose():void\n\t{\n\n\t}\n\n\n\tpublic iAddOwner(owner:ISurface):void\n\t{\n\t\t//a method can be used more than once in the same material, so we check for this\n\t\tvar index:number = this._owners.indexOf(owner);\n\n\t\tif (index != -1) {\n\t\t\tthis._counts[index]++;\n\t\t} else {\n\t\t\tthis._owners.push(owner);\n\t\t\tthis._counts.push(1);\n\n\t\t\t//add textures\n\t\t\tvar len:number = this._textures.length;\n\t\t\tfor (var i:number = 0; i< len; i++)\n\t\t\t\towner.addTexture(this._textures[i]);\n\t\t}\n\t}\n\n\tpublic iRemoveOwner(owner:ISurface):void\n\t{\n\t\tvar index:number = this._owners.indexOf(owner);\n\n\t\tif (this._counts[index] != 1) {\n\t\t\tthis._counts[index]--;\n\t\t} else {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tthis._counts.splice(index, 1);\n\n\t\t\t//remove textures\n\t\t\tvar len:number = this._textures.length;\n\t\t\tfor (var i:number = 0; i< len; i++)\n\t\t\t\towner.removeTexture(this._textures[i]);\n\t\t}\n\t}\n\n\n\t/**\n\t *\n\t */\n\tpublic iAddTexture(texture:TextureBase):void\n\t{\n\t\tthis._textures.push(texture);\n\n\t\tvar len:number = this._owners.length;\n\t\tfor (var i:number = 0; i < len; i++)\n\t\t\tthis._owners[i].addTexture(texture);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic iRemoveTexture(texture:TextureBase):void\n\t{\n\t\tthis._textures.splice(this._textures.indexOf(texture), 1);\n\n\t\tvar len:number = this._owners.length;\n\t\tfor (var i:number = 0; i < len; i++)\n\t\t\tthis._owners[i].removeTexture(texture);\n\t}\n\n\t/**\n\t * Resets the compilation state of the method.\n\t *\n\t * @internal\n\t */\n\tpublic iReset():void\n\t{\n\t\tthis.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Resets the method's state for compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iCleanCompilationData():void\n\t{\n\t}\n\n\t/**\n\t * Get the vertex shader code for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t *\n\t * @internal\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn null;\n\t}\n\n\t/**\n\t * Sets the render state for this method.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\n\t}\n\n\t/**\n\t * Sets the render state for a single renderable.\n\t *\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param renderable The renderable currently being rendered.\n\t * @param stage The Stage object currently used for rendering.\n\t * @param camera The camera from which the scene is currently rendered.\n\t *\n\t * @internal\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\n\t}\n\n\t/**\n\t * Clears the render state for this method.\n\t * @param vo The MethodVO object linking this method with the pass currently being compiled.\n\t * @param stage The Stage object currently used for rendering.\n\t *\n\t * @internal\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\n\t}\n\n\t/**\n\t * Marks the shader program as invalid, so it will be recompiled before the next render.\n\t *\n\t * @internal\n\t */\n\tpublic iInvalidateShaderProgram():void\n\t{\n\t\tthis.dispatchEvent(new ShadingMethodEvent(ShadingMethodEvent.SHADER_INVALIDATED));\n\t}\n\n\t/**\n\t * Copies the state from a ShadingMethodBase object into the current object.\n\t */\n\tpublic copyFrom(method:ShadingMethodBase):void\n\t{\n\t}\n}",
    "import {AssetEvent}\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\n\nimport {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {DirectionalLight}\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\nimport {CascadeShadowMapper}\t\t\t\tfrom \"awayjs-display/lib/materials/shadowmappers/CascadeShadowMapper\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {ShadingMethodEvent}\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {ShadowMapMethodBase}\t\t\t\tfrom \"../methods/ShadowMapMethodBase\";\nimport {ShadowMethodBase}\t\t\t\t\tfrom \"../methods/ShadowMethodBase\";\n\n/**\n * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.\n * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.\n *\n * @see away.lights.CascadeShadowMapper\n */\nexport class ShadowCascadeMethod extends ShadowMapMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\tprivate _cascadeShadowMapper:CascadeShadowMapper;\n\tprivate _depthMapCoordVaryings:Array<ShaderRegisterElement>;\n\tprivate _cascadeProjections:Array<ShaderRegisterElement>;\n\n\t/**\n\t * Creates a new ShadowCascadeMethod object.\n\t *\n\t * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t */\n\tconstructor(shadowMethodBase:ShadowMethodBase)\n\t{\n\t\tsuper(shadowMethodBase.castingLight);\n\n\t\tthis._baseMethod = shadowMethodBase;\n\t\tif (!(this._pCastingLight instanceof DirectionalLight))\n\t\t\tthrow new Error(\"ShadowCascadeMethod is only compatible with DirectionalLight\");\n\n\t\tthis._cascadeShadowMapper = <CascadeShadowMapper> this._pCastingLight.shadowMapper;\n\n\t\tif (!this._cascadeShadowMapper)\n\t\t\tthrow new Error(\"ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.\");\n\n\t\tthis._cascadeShadowMapper.addEventListener(AssetEvent.INVALIDATE, (event:AssetEvent) => this.onCascadeChange(event));\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\t}\n\n\t/**\n\t * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction\n\t * with a DirectionalShadowMapper.\n\t *\n\t * @see ShadowHardMethod\n\t * @see ShadowSoftMethod\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, (event:ShadingMethodEvent) => this.onShaderInvalidated(event));\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tvar tempVO:MethodVO = new MethodVO(this._baseMethod, methodVO.pass);\n\t\tthis._baseMethod.iInitVO(shader, tempVO);\n\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = .5;\n\t\tfragmentData[index + 7] = -.5;\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tvertexData[index] = .5;\n\t\tvertexData[index + 1] = -.5;\n\t\tvertexData[index + 2] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData():void\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._cascadeProjections = null;\n\t\tthis._depthMapCoordVaryings = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeVertexConstant();\n\n\t\tthis.initProjectionsRegs(registerCache);\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeVertexVectorTemp();\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + this._cascadeProjections[i] + \"\\n\" +\n\t\t\t\t\"add \" + this._depthMapCoordVaryings[i] + \", \" + temp + \", \" + dataReg + \".zzwz\\n\";\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Creates the registers for the cascades' projection coordinates.\n\t */\n\tprivate initProjectionsRegs(registerCache:ShaderRegisterCache):void\n\t{\n\t\tthis._cascadeProjections = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\t\tthis._depthMapCoordVaryings = new Array<ShaderRegisterElement>(this._cascadeShadowMapper.numCascades);\n\n\t\tfor (var i:number = 0; i < this._cascadeShadowMapper.numCascades; ++i) {\n\t\t\tthis._depthMapCoordVaryings[i] = registerCache.getFreeVarying();\n\t\t\tthis._cascadeProjections[i] = registerCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t\tregisterCache.getFreeVertexConstant();\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvar decReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistanceReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar planeDistances:Array<string> = Array<string>( planeDistanceReg + \".x\", planeDistanceReg + \".y\", planeDistanceReg + \".z\", planeDistanceReg + \".w\" );\n\t\tvar code:string;\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar inQuad:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(inQuad, 1);\n\t\tvar uvCoord:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvCoord, 1);\n\n\t\t// assume lowest partition is selected, will be overwritten later otherwise\n\t\tcode = \"mov \" + uvCoord + \", \" + this._depthMapCoordVaryings[numCascades - 1] + \"\\n\";\n\n\t\tfor (var i:number = numCascades - 2; i >= 0; --i) {\n\t\t\tvar uvProjection:ShaderRegisterElement = this._depthMapCoordVaryings[i];\n\n\t\t\t// calculate if in texturemap (result == 0 or 1, only 1 for a single partition)\n\t\t\tcode += \"slt \" + inQuad + \".z, \" + sharedRegisters.projectionFragment + \".z, \" + planeDistances[i] + \"\\n\"; // z = x > minX, w = y > minY\n\n\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t// linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)\n\t\t\tcode += \"sub \" + temp + \", \" + uvProjection + \", \" + uvCoord + \"\\n\" +\n\t\t\t\t\"mul \" + temp + \", \" + temp + \", \" + inQuad + \".z\\n\" +\n\t\t\t\t\"add \" + uvCoord + \", \" + uvCoord + \", \" + temp + \"\\n\";\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(inQuad);\n\n\t\tcode += \"div \" + uvCoord + \", \" + uvCoord + \", \" + uvCoord + \".w\\n\" +\n\t\t\t\"mul \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zw\\n\" +\n\t\t\t\"add \" + uvCoord + \".xy, \" + uvCoord + \".xy, \" + dataReg + \".zz\\n\";\n\n\t\tcode += this._baseMethod._iGetCascadeFragmentCode(shader, methodVO, decReg, uvCoord, targetReg, registerCache, sharedRegisters) +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + dataReg + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(uvCoord);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar vertexIndex:number = methodVO.vertexConstantsIndex;\n\n\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/(this._cascadeShadowMapper.depth*this._pEpsilon);\n\n\t\tvar numCascades:number = this._cascadeShadowMapper.numCascades;\n\t\tvertexIndex += 4;\n\t\tfor (var k:number = 0; k < numCascades; ++k) {\n\t\t\tthis._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);\n\t\t\tvertexIndex += 16;\n\t\t}\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar fragmentIndex:number = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[fragmentIndex + 5] = 1 - this._pAlpha;\n\n\t\tvar nearPlaneDistances:Array<number> = this._cascadeShadowMapper._iNearPlaneDistances;\n\n\t\tfragmentIndex += 8;\n\t\tfor (var i:number = 0; i < numCascades; ++i)\n\t\t\tfragmentData[fragmentIndex + i] = nearPlaneDistances[i];\n\n\t\tthis._baseMethod.iActivateForCascade(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t}\n\n\t/**\n\t * Called when the shadow mappers cascade configuration changes.\n\t */\n\tprivate onCascadeChange(event:AssetEvent):void\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent):void\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}",
    "import {BitmapImage2D}\t\t\t\t\tfrom \"awayjs-core/lib/image/BitmapImage2D\";\n\nimport {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {DirectionalLight}\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\nimport {Single2DTexture}\t\t\t\t\tfrom \"awayjs-display/lib/textures/Single2DTexture\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {ShadowMethodBase}\t\t\t\t\tfrom \"../methods/ShadowMethodBase\";\n\n/**\n * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.\n */\nexport class ShadowDitheredMethod extends ShadowMethodBase\n{\n\tprivate static _grainTexture:Single2DTexture;\n\tprivate static _grainUsages:number /*int*/;\n\tprivate static _grainBitmapImage2D:BitmapImage2D;\n\tprivate _depthMapSize:number /*int*/;\n\tprivate _range:number;\n\tprivate _numSamples:number /*int*/;\n\n\t/**\n\t * Creates a new ShadowDitheredMethod object.\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 4, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\n\t\t++ShadowDitheredMethod._grainUsages;\n\n\t\tif (!ShadowDitheredMethod._grainTexture)\n\t\t\tthis.initGrainTexture();\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tif (value < 1)\n\t\t\tvalue = 1;\n\t\telse if (value > 24)\n\t\t\tvalue = 24;\n\n\t\tif (this._numSamples == value)\n\t\t\treturn;\n\n\t\tthis._numSamples = value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tsuper.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\n\t\tmethodVO.secondaryTextureGL = shader.getAbstraction(ShadowDitheredMethod._grainTexture);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = 1/this._numSamples;\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range*2;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value/2;\n\t}\n\n\t/**\n\t * Creates a texture containing the dithering noise texture.\n\t */\n\tprivate initGrainTexture():void\n\t{\n\t\tShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D(64, 64, false);\n\t\tvar vec:Array<number> /*uint*/ = new Array<number>();\n\t\tvar len:number /*uint*/ = 4096;\n\t\tvar step:number = 1/(this._depthMapSize*this._range);\n\t\tvar r:number, g:number;\n\n\t\tfor (var i:number /*uint*/ = 0; i < len; ++i) {\n\t\t\tr = 2*(Math.random() - .5);\n\t\t\tg = 2*(Math.random() - .5);\n\t\t\tif (r < 0)\n\t\t\t\tr -= step; else\n\t\t\t\tr += step;\n\t\t\tif (g < 0)\n\t\t\t\tg -= step; else\n\t\t\t\tg += step;\n\t\t\tif (r > 1)\n\t\t\t\tr = 1; else if (r < -1)\n\t\t\t\tr = -1;\n\t\t\tif (g > 1)\n\t\t\t\tg = 1; else if (g < -1)\n\t\t\t\tg = -1;\n\t\t\tvec[i] = (Math.floor((r*.5 + .5)*0xff) << 16) | (Math.floor((g*.5 + .5)*0xff) << 8);\n\t\t}\n\n\t\tShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);\n\t\tShadowDitheredMethod._grainTexture = new Single2DTexture(ShadowDitheredMethod._grainBitmapImage2D);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose():void\n\t{\n\t\tif (--ShadowDitheredMethod._grainUsages == 0) {\n\t\t\tShadowDitheredMethod._grainTexture.dispose();\n\t\t\tShadowDitheredMethod._grainBitmapImage2D.dispose();\n\t\t\tShadowDitheredMethod._grainTexture = null;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex;\n\t\tdata[index + 9] = (stage.width - 1)/63;\n\t\tdata[index + 10] = (stage.height - 1)/63;\n\t\tdata[index + 11] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tsuper.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\n\t\tmethodVO.secondaryTextureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, customDataReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar numSamples:number /*int*/ = this._numSamples;\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(temp, 1);\n\n\t\tvar projectionReg:ShaderRegisterElement = sharedRegisters.projectionFragment;\n\n\t\tcode += \"div \" + uvReg + \", \" + projectionReg + \", \" + projectionReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".xy, \" + uvReg + \".xy, \" + customDataReg + \".yz\\n\";\n\n\t\twhile (numSamples > 0) {\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\tcode += methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, uvReg);\n\t\t\t} else {\n\t\t\t\tcode += \"mov \" + temp + \", \" + uvReg + \".zwxy \\n\" +\n\t\t\t\t\tmethodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, temp);\n\t\t\t}\n\n\t\t\t// keep grain in uvReg.zw\n\t\t\tcode += \"sub \" + uvReg + \".zw, \" + uvReg + \".xy, fc0.xx\\n\" + // uv-.5\n\t\t\t\t\"mul \" + uvReg + \".zw, \" + uvReg + \".zw, \" + customDataReg + \".w\\n\"; // (tex unpack scale and tex scale in one)\n\n\t\t\tif (numSamples == this._numSamples) {\n\t\t\t\t// first sample\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".zw, \" + this._pDepthMapCoordReg + \".xy\\n\" +\n\t\t\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t\t\t} else {\n\t\t\t\tcode += this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\t\t\t}\n\n\t\t\tif (numSamples > 4)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 1)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 5)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".zw\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 2) {\n\t\t\t\tcode += \"neg \" + uvReg + \".w, \" + uvReg + \".w\\n\"; // will be rotated 90 degrees when being accessed as wz\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".wz, \" + this._pDepthMapCoordReg + \".xy\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\t\t\t}\n\n\t\t\tif (numSamples > 6)\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 3)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tif (numSamples > 7)\n\t\t\t\tcode += \"sub \" + uvReg + \".xy, \" + uvReg + \".xy, \" + uvReg + \".wz\\n\" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);\n\n\t\t\tnumSamples -= 8;\n\t\t}\n\n\t\tregCache.removeFragmentTempUsage(temp);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\t\tcode += \"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + customDataReg + \".x\\n\"; // average\n\t\treturn code;\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uvReg The uv register for the tap.\n\t * @param depthMapRegister The texture register containing the depth map.\n\t * @param decReg The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, uvReg:ShaderRegisterElement, decReg:ShaderRegisterElement, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + temp + \".z, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \".z\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = (stage.width - 1)/63;\n\t\tdata[index + 2] = (stage.height - 1)/63;\n\t\tdata[index + 3] = 2*this._range/this._depthMapSize;\n\n\t\tmethodVO.secondaryTextureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);\n\t}\n}",
    "import {DirectionalLight}\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {ShadowMethodBase}\t\t\t\t\tfrom \"../methods/ShadowMethodBase\";\n\n/**\n * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison\n * results of neighbouring pixels.\n */\nexport class ShadowFilteredMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadow\n\t */\n\tconstructor(castingLight:DirectionalLight)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index + 8] = .5;\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tfragmentData[index + 9] = size;\n\t\tfragmentData[index + 10] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar customDataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthCol, 1);\n\t\tvar uvReg:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tcode += \"mov \" + uvReg + \", \" + this._pDepthMapCoordReg + \"\\n\" +\n\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" + \t// (1, 0)\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mov \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".y, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".z\\n\" +\t// (0, 1)\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t\"add \" + uvReg + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".z\\n\" +\t// (1, 1)\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\" +   // 0 if in shadow\n\n\t\t\t// recalculate fraction, since we ran out of registers :(\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".x, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" + \"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + uvReg + \".z\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + uvReg + \".w, \" + uvReg + \".z, \" + uvReg + \".w\\n\" +\n\n\t\t\t\"mul \" + depthCol + \".x, \" + this._pDepthMapCoordReg + \".y, \" + customDataReg + \".y\\n\" +\n\t\t\t\"frc \" + depthCol + \".x, \" + depthCol + \".x\\n\" +\n\t\t\t\"sub \" + uvReg + \".w, \" + uvReg + \".w, \" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + uvReg + \".w, \" + uvReg + \".w, \" + depthCol + \".x\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + targetReg + \".w, \" + uvReg + \".w\\n\";\n\n\t\tregCache.removeFragmentTempUsage(depthCol);\n\t\tregCache.removeFragmentTempUsage(uvReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tvar size:number /*int*/ = this.castingLight.shadowMapper.depthMapSize;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = size;\n\t\tdata[index + 1] = 1/size;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(temp, 1);\n\t\tvar predicate:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(predicate, 1);\n\n\t\tcode = methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".x, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".z, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"add \" + depthProjection + \".y, \" + depthProjection + \".y, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"sub \" + depthProjection + \".x, \" + depthProjection + \".x, \" + dataReg + \".y\\n\" +\n\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + predicate + \".y, \" + depthProjection + \".z, \" + temp + \".z\\n\" +\n\n\t\t\t\"mul \" + temp + \".xy, \" + depthProjection + \".xy, \" + dataReg + \".x\\n\" +\n\t\t\t\"frc \" + temp + \".xy, \" + temp + \".xy\\n\" +\n\n\t\t\t// some strange register juggling to prevent agal bugging out\n\t\t\t\"sub \" + depthProjection + \", \" + predicate + \".xyzw, \" + predicate + \".zwxy\\n\" +\n\t\t\t\"mul \" + depthProjection + \", \" + depthProjection + \", \" + temp + \".x\\n\" +\n\n\t\t\t\"add \" + predicate + \".xy, \" + predicate + \".xy, \" + depthProjection + \".zw\\n\" +\n\n\t\t\t\"sub \" + predicate + \".y, \" + predicate + \".y, \" + predicate + \".x\\n\" +\n\t\t\t\"mul \" + predicate + \".y, \" + predicate + \".y, \" + temp + \".y\\n\" +\n\t\t\t\"add \" + targetRegister + \".w, \" + predicate + \".x, \" + predicate + \".y\\n\";\n\n\t\tregisterCache.removeFragmentTempUsage(temp);\n\t\tregisterCache.removeFragmentTempUsage(predicate);\n\t\treturn code;\n\t}\n}",
    "import {LightBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/display/LightBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {ShadowMethodBase}\t\t\t\t\tfrom \"../methods/ShadowMethodBase\";\n\n/**\n * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.\n */\nexport class ShadowHardMethod extends ShadowMethodBase\n{\n\t/**\n\t * Creates a new ShadowHardMethod object.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper(castingLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\n\t\tvar depthCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +\n\t\t\t\"dp4 \" + depthCol + \".z, \" + depthCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"slt \" + targetReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + depthCol + \".z\\n\"; // 0 if in shadow\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar epsReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar posReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tvar depthSampleCol:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(depthSampleCol, 1);\n\t\tvar lightDir:ShaderRegisterElement = regCache.getFreeFragmentVectorTemp();\n\t\tregCache.addFragmentTempUsages(lightDir, 1);\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\tcode += \"sub \" + lightDir + \", \" + sharedRegisters.globalPositionVarying + \", \" + posReg + \"\\n\" +\n\t\t\t\"dp3 \" + lightDir + \".w, \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\t\t\t\"mul \" + lightDir + \".w, \" + lightDir + \".w, \" + posReg + \".w\\n\" +\n\t\t\t\"nrm \" + lightDir + \".xyz, \" + lightDir + \".xyz\\n\" +\n\n\t\t\tmethodVO.textureGL._iGetFragmentCode(depthSampleCol, regCache, sharedRegisters, lightDir) +\n\t\t\t\"dp4 \" + depthSampleCol + \".z, \" + depthSampleCol + \", \" + decReg + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".w, \" + lightDir + \".w, \" + epsReg + \".x\\n\" +    // offset by epsilon\n\n\t\t\t\"slt \" + targetReg + \".w, \" + targetReg + \".w, \" + depthSampleCol + \".z\\n\"; // 0 if in shadow\n\n\t\tregCache.removeFragmentTempUsage(lightDir);\n\t\tregCache.removeFragmentTempUsage(depthSampleCol);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + targetRegister + \".w, \" + depthProjection + \".z, \" + temp + \".z\\n\"; // 0 if in shadow\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t}\n}",
    "import {IAsset}\t\t\t\t\t\t\tfrom \"awayjs-core/lib/library/IAsset\";\n\nimport {LightBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/display/LightBase\";\nimport {ShadowMapperBase}\t\t\t\t\tfrom \"awayjs-display/lib/materials/shadowmappers/ShadowMapperBase\";\n\nimport {ShadingMethodBase}\t\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * ShadowMapMethodBase provides an abstract base method for shadow map methods.\n */\nexport class ShadowMapMethodBase extends ShadingMethodBase implements IAsset\n{\n\tpublic static assetType:string = \"[asset ShadowMapMethod]\";\n\n\tpublic _pCastingLight:LightBase;\n\tpublic _pShadowMapper:ShadowMapperBase;\n\n\tpublic _pEpsilon:number = .02;\n\tpublic _pAlpha:number = 1;\n\n\t/**\n\t * Creates a new ShadowMapMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper();\n\t\tthis._pCastingLight = castingLight;\n\t\tcastingLight.shadowsEnabled = true;\n\t\tthis._pShadowMapper = castingLight.shadowMapper;\n\n\t\tthis.iAddTexture(castingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get assetType():string\n\t{\n\t\treturn ShadowMapMethodBase.assetType;\n\t}\n\n\t/**\n\t * The \"transparency\" of the shadows. This allows making shadows less strong.\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._pAlpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._pAlpha = value;\n\t}\n\n\t/**\n\t * The light casting the shadows.\n\t */\n\tpublic get castingLight():LightBase\n\t{\n\t\treturn this._pCastingLight;\n\t}\n\n\t/**\n\t * A small value to counter floating point precision errors when comparing values in the shadow map with the\n\t * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._pEpsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._pEpsilon = value;\n\t}\n}",
    "import {Vector3D}\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Vector3D\";\nimport {AbstractMethodError}\t\t\t\tfrom \"awayjs-core/lib/errors/AbstractMethodError\";\n\nimport {LightBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/display/LightBase\";\nimport {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {DirectionalLight}\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\nimport {PointLight}\t\t\t\t\t\tfrom \"awayjs-display/lib/display/PointLight\";\nimport {DirectionalShadowMapper}\t\t\tfrom \"awayjs-display/lib/materials/shadowmappers/DirectionalShadowMapper\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {ShadowMapMethodBase}\t\t\t\tfrom \"../methods/ShadowMapMethodBase\";\n\n/**\n * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.\n */\nexport class ShadowMethodBase extends ShadowMapMethodBase\n{\n\tpublic _pDepthMapCoordReg:ShaderRegisterElement;\n\tpublic _pUsePoint:boolean;\n\n\t/**\n\t * Creates a new ShadowMethodBase object.\n\t * @param castingLight The light used to cast shadows.\n\t */\n\tconstructor(castingLight:LightBase)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis._pUsePoint = (castingLight instanceof PointLight);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tmethodVO.needsView = true;\n\t\tmethodVO.needsGlobalVertexPos = true;\n\t\tmethodVO.needsGlobalFragmentPos = this._pUsePoint;\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\n\t\tmethodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar vertexData:Float32Array = shader.vertexConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\t\tfragmentData[index] = 1.0;\n\t\tfragmentData[index + 1] = 1/255.0;\n\t\tfragmentData[index + 2] = 1/65025.0;\n\t\tfragmentData[index + 3] = 1/16581375.0;\n\n\t\tfragmentData[index + 6] = 0;\n\t\tfragmentData[index + 7] = 1;\n\n\t\tif (this._pUsePoint) {\n\t\t\tfragmentData[index + 8] = 0;\n\t\t\tfragmentData[index + 9] = 0;\n\t\t\tfragmentData[index + 10] = 0;\n\t\t\tfragmentData[index + 11] = 1;\n\t\t}\n\n\t\tindex = methodVO.vertexConstantsIndex;\n\t\tif (index != -1) {\n\t\t\tvertexData[index] = .5;\n\t\t\tvertexData[index + 1] = .5;\n\t\t\tvertexData[index + 2] = 0.0;\n\t\t\tvertexData[index + 3] = 1.0;\n\t\t}\n\t}\n\n\t/**\n\t * Wrappers that override the vertex shader need to set this explicitly\n\t */\n\tpublic get _iDepthMapCoordReg():ShaderRegisterElement\n\t{\n\t\treturn this._pDepthMapCoordReg;\n\t}\n\n\tpublic set _iDepthMapCoordReg(value:ShaderRegisterElement)\n\t{\n\t\tthis._pDepthMapCoordReg = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData():void\n\t{\n\t\tsuper.iCleanCompilationData();\n\n\t\tthis._pDepthMapCoordReg = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._pUsePoint? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters):this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a point light.\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic _pGetPointVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tmethodVO.vertexConstantsIndex = -1;\n\t\treturn \"\";\n\t}\n\n\t/**\n\t * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).\n\t *\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t */\n\tpublic pGetPlanarVertexCode(methodVO:MethodVO, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar temp:ShaderRegisterElement = regCache.getFreeVertexVectorTemp();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tvar depthMapProj:ShaderRegisterElement = regCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tregCache.getFreeVertexConstant();\n\t\tthis._pDepthMapCoordReg = regCache.getFreeVarying();\n\t\tmethodVO.vertexConstantsIndex = dataReg.index*4;\n\n\t\t// todo: can epsilon be applied here instead of fragment shader?\n\n\t\tcode += \"m44 \" + temp + \", \" + sharedRegisters.globalPositionVertex + \", \" + depthMapProj + \"\\n\" +\n\t\t\t\"div \" + temp + \", \" + temp + \", \" + temp + \".w\\n\" +\n\t\t\t\"mul \" + temp + \".xy, \" + temp + \".xy, \" + dataReg + \".xy\\n\" +\n\t\t\t\"add \" + this._pDepthMapCoordReg + \", \" + temp + \", \" + dataReg + \".xxwz\\n\";\n\t\t//\"sub \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".z, \" + this._pDepthMapCoordReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._pUsePoint? this._pGetPointFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t\tcode += \"add \" + targetReg + \".w, \" + targetReg + \".w, fc\" + (methodVO.fragmentConstantsIndex/4 + 1) + \".y\\n\" +\n\t\t\t\"sat \" + targetReg + \".w, \" + targetReg + \".w\\n\";\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a planar shadow map.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t}\n\n\t/**\n\t * Gets the fragment code for shadow mapping with a point light.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param targetReg The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _pGetPointFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new AbstractMethodError();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tif (!this._pUsePoint)\n\t\t\t(<DirectionalShadowMapper> this._pShadowMapper).iDepthProjection.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);\n\n\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Gets the fragment code for combining this method with a cascaded shadow map method.\n\t * @param methodVO The MethodVO object linking this method with the pass currently being compiled.\n\t * @param regCache The register cache used during the compilation.\n\t * @param decodeRegister The register containing the data to decode the shadow map depth value.\n\t * @param depthTexture The texture containing the shadow map.\n\t * @param depthProjection The projection of the fragment relative to the light.\n\t * @param targetRegister The register to contain the shadow coverage\n\t * @return\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.fragmentConstantsIndex;\n\n\t\tif (this._pUsePoint)\n\t\t\tfragmentData[index + 4] = -Math.pow(1/((<PointLight> this._pCastingLight).fallOff*this._pEpsilon), 2);\n\t\telse\n\t\t\tshader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1/((<DirectionalShadowMapper> this._pShadowMapper).depth*this._pEpsilon);\n\n\t\tfragmentData[index + 5] = 1 - this._pAlpha;\n\n\t\tif (this._pUsePoint) {\n\t\t\tvar pos:Vector3D = this._pCastingLight.scenePosition;\n\t\t\tfragmentData[index + 8] = pos.x;\n\t\t\tfragmentData[index + 9] = pos.y;\n\t\t\tfragmentData[index + 10] = pos.z;\n\t\t\t// used to decompress distance\n\t\t\tvar f:number = (<PointLight> this._pCastingLight).fallOff;\n\t\t\tfragmentData[index + 11] = 1/(2*f*f);\n\t\t}\n\n\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\t}\n\n\t/**\n\t * Sets the method state for cascade shadow mapping.\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tthrow new Error(\"This shadow method is incompatible with cascade shadows\");\n\t}\n}",
    "import {NearDirectionalShadowMapper}\t\tfrom \"awayjs-display/lib/materials/shadowmappers/NearDirectionalShadowMapper\";\nimport {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {ShadingMethodEvent}\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {ShadowMethodBase}\t\t\t\t\tfrom \"../methods/ShadowMethodBase\";\n\n// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work\n/**\n * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize\n * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.\n *\n * @see away.lights.NearDirectionalShadowMapper\n */\nexport class ShadowNearMethod extends ShadowMethodBase\n{\n\tprivate _baseMethod:ShadowMethodBase;\n\n\tprivate _fadeRatio:number;\n\tprivate _nearShadowMapper:NearDirectionalShadowMapper;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new ShadowNearMethod object.\n\t * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)\n\t * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tconstructor(baseMethod:ShadowMethodBase, fadeRatio:number = .1)\n\t{\n\t\tsuper(baseMethod.castingLight);\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod;\n\t\tthis._fadeRatio = fadeRatio;\n\t\tthis._nearShadowMapper = <NearDirectionalShadowMapper> this._pCastingLight.shadowMapper;\n\t\tif (!this._nearShadowMapper)\n\t\t\tthrow new Error(\"ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.\");\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * The base shadow map method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():ShadowMethodBase\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:ShadowMethodBase)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index + 2] = 0;\n\t\tfragmentData[index + 3] = 1;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\n\t\tmethodVO.needsProjection = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose():void\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get alpha():number\n\t{\n\t\treturn this._baseMethod.alpha;\n\t}\n\n\tpublic set alpha(value:number)\n\t{\n\t\tthis._baseMethod.alpha = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get epsilon():number\n\t{\n\t\treturn this._baseMethod.epsilon;\n\t}\n\n\tpublic set epsilon(value:number)\n\t{\n\t\tthis._baseMethod.epsilon = value;\n\t}\n\n\t/**\n\t * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.\n\t */\n\tpublic get fadeRatio():number\n\t{\n\t\treturn this._fadeRatio;\n\t}\n\n\tpublic set fadeRatio(value:number)\n\t{\n\t\tthis._fadeRatio = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._baseMethod.iGetFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentSingleTemp();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\tcode += \"abs \" + temp + \", \" + sharedRegisters.projectionFragment + \".w\\n\" +\n\t\t\t\"sub \" + temp + \", \" + temp + \", \" + dataReg + \".x\\n\" +\n\t\t\t\"mul \" + temp + \", \" + temp + \", \" + dataReg + \".y\\n\" +\n\t\t\t\"sat \" + temp + \", \" + temp + \"\\n\" +\n\t\t\t\"sub \" + temp + \", \" + dataReg + \".w,\" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + temp + \"\\n\" +\n\t\t\t\"sub \" + targetReg + \".w, \" + dataReg + \".w,\" + targetReg + \".w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:ShaderBase, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\t// todo: move this to activate (needs camera)\n\t\tvar near:number = camera.projection.near;\n\t\tvar d:number = camera.projection.far - near;\n\t\tvar maxDistance:number = this._nearShadowMapper.coverageRatio;\n\t\tvar minDistance:number = maxDistance*(1 - this._fadeRatio);\n\n\t\tmaxDistance = near + maxDistance*d;\n\t\tminDistance = near + minDistance*d;\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = minDistance;\n\t\tfragmentData[index + 1] = 1/(maxDistance - minDistance);\n\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset():void\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData():void\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent):void\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}",
    "import {PoissonLookup}\t\t\t\t\tfrom \"awayjs-core/lib/geom/PoissonLookup\";\n\nimport {DirectionalLight}\t\t\t\t\tfrom \"awayjs-display/lib/display/DirectionalLight\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {ShadowMethodBase}\t\t\t\t\tfrom \"../methods/ShadowMethodBase\";\n\n/**\n * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.\n */\nexport class ShadowSoftMethod extends ShadowMethodBase\n{\n\tprivate _range:number = 1;\n\tprivate _numSamples:number /*int*/;\n\tprivate _offsets:Array<number>;\n\n\t/**\n\t * Creates a new DiffuseBasicMethod object.\n\t *\n\t * @param castingLight The light casting the shadows\n\t * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.\n\t */\n\tconstructor(castingLight:DirectionalLight, numSamples:number /*int*/ = 5, range:number = 1)\n\t{\n\t\tsuper(castingLight);\n\n\t\tthis.numSamples = numSamples;\n\t\tthis.range = range;\n\t}\n\n\t/**\n\t * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the\n\t * complexity of the shader.\n\t */\n\tpublic get numSamples():number /*int*/\n\t{\n\t\treturn this._numSamples;\n\t}\n\n\tpublic set numSamples(value:number /*int*/)\n\t{\n\t\tthis._numSamples = value;\n\t\t\n\t\tif (this._numSamples < 1)\n\t\t\tthis._numSamples = 1;\n\t\telse if (this._numSamples > 32)\n\t\t\tthis._numSamples = 32;\n\n\t\tthis._offsets = PoissonLookup.getDistribution(this._numSamples);\n\t\t\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The range in the shadow map in which to distribute the samples.\n\t */\n\tpublic get range():number\n\t{\n\t\treturn this._range;\n\t}\n\n\tpublic set range(value:number)\n\t{\n\t\tthis._range = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tsuper.iInitConstants(shader, methodVO);\n\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1/this._numSamples;\n\t\tshader.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = .5*this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.fragmentConstantsIndex + 10;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pGetPlanarFragmentCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, regCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\t// todo: move some things to super\n\t\tvar decReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\t\tregCache.getFreeFragmentConstant();\n\t\tvar dataReg:ShaderRegisterElement = regCache.getFreeFragmentConstant();\n\n\t\tmethodVO.fragmentConstantsIndex = decReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decReg, targetReg, regCache, sharedRegisters, dataReg);\n\t}\n\n\t/**\n\t * Adds the code for another tap to the shader code.\n\t * @param uv The uv register for the tap.\n\t * @param texture The texture register containing the depth map.\n\t * @param decode The register containing the depth map decoding data.\n\t * @param target The target register to add the tap comparison result.\n\t * @param regCache The register cache managing the registers.\n\t * @return\n\t */\n\tprivate addSample(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData, uvReg:ShaderRegisterElement):string\n\t{\n\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\treturn methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\"slt \" + uvReg + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\" + // 0 if in shadow\n\t\t\t\"add \" + targetRegister + \".w, \" + targetRegister + \".w, \" + uvReg + \".w\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivateForCascade(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar texRange:number = this._range/this._pCastingLight.shadowMapper.depthMapSize;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tvar index:number /*uint*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar len:number /*uint*/ = this._numSamples << 1;\n\t\tdata[index] = 1/this._numSamples;\n\t\tdata[index + 1] = 0;\n\t\tindex += 2;\n\n\t\tfor (var i:number /*int*/ = 0; i < len; ++i)\n\t\t\tdata[index + i] = this._offsets[i]*texRange;\n\n\t\tif (len%4 == 0) {\n\t\t\tdata[index + len] = 0;\n\t\t\tdata[index + len + 1] = 0;\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetCascadeFragmentCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, depthProjection:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._pDepthMapCoordReg = depthProjection;\n\n\t\tvar dataReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = dataReg.index*4;\n\n\t\treturn this.getSampleCode(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg);\n\t}\n\n\t/**\n\t * Get the actual shader code for shadow mapping\n\t * @param regCache The register cache managing the registers.\n\t * @param depthTexture The texture register containing the depth map.\n\t * @param decodeRegister The register containing the depth map decoding data.\n\t * @param targetReg The target register to add the shadow coverage.\n\t * @param dataReg The register containing additional data.\n\t */\n\tprivate getSampleCode(shader:ShaderBase, methodVO:MethodVO, decodeRegister:ShaderRegisterElement, targetRegister:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData, dataReg:ShaderRegisterElement):string\n\t{\n\t\tvar code:string;\n\t\tvar uvReg:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(uvReg, 1);\n\n\t\tvar offsets:Array<string> = new Array<string>(dataReg + \".zw\");\n\t\tvar numRegs:number /*int*/ = this._numSamples >> 1;\n\n\t\tfor (var i:number /*int*/ = 0; i < numRegs; ++i) {\n\t\t\tvar reg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();\n\t\t\toffsets.push(reg + \".xy\");\n\t\t\toffsets.push(reg + \".zw\");\n\t\t}\n\n\t\tfor (i = 0; i < this._numSamples; ++i) {\n\t\t\tif (i == 0) {\n\t\t\t\tvar temp:ShaderRegisterElement = registerCache.getFreeFragmentVectorTemp();\n\n\t\t\t\tcode = \"add \" + uvReg + \", \" + this._pDepthMapCoordReg + \", \" + dataReg + \".zwyy\\n\" +\n\t\t\t\t\tmethodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +\n\t\t\t\t\t\"dp4 \" + temp + \".z, \" + temp + \", \" + decodeRegister + \"\\n\" +\n\t\t\t\t\t\"slt \" + targetRegister + \".w, \" + this._pDepthMapCoordReg + \".z, \" + temp + \".z\\n\"; // 0 if in shadow;\n\t\t\t} else {\n\t\t\t\tcode += \"add \" + uvReg + \".xy, \" + this._pDepthMapCoordReg + \".xy, \" + offsets[i] + \"\\n\" +\n\t\t\t\t\tthis.addSample(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg);\n\t\t\t}\n\t\t}\n\n\t\tregisterCache.removeFragmentTempUsage(uvReg);\n\n\t\tcode += \"mul \" + targetRegister + \".w, \" + targetRegister + \".w, \" + dataReg + \".x\\n\"; // average\n\n\t\treturn code;\n\t}\n}",
    "import {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {SpecularBasicMethod}\t\t\t\tfrom \"../methods/SpecularBasicMethod\";\n\n/**\n * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for\n * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.\n * The tangent vectors are used as the surface groove directions.\n */\nexport class SpecularAnisotropicMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularAnisotropicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tmethodVO.needsTangents = true;\n\t\tmethodVO.needsView = true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight)\n\t\t\tt = this._pTotalLightColorReg;\n\t\telse {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\t// (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k\n\n\t\tcode += \"nrm \" + t + \".xyz, \" + sharedRegisters.tangentVarying + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".w, \" + t + \".xyz, \" + lightDirReg + \".xyz\\n\" +\n\t\t\t\"dp3 \" + t + \".z, \" + t + \".xyz, \" + sharedRegisters.viewDirFragment + \".xyz\\n\";\n\n\t\t// (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k\n\t\tcode += \"sin \" + t + \".x, \" + t + \".w\\n\" +\n\t\t\t\"sin \" + t + \".y, \" + t + \".z\\n\" +\n\t\t\t// (t.x * t.y - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"mul \" + t + \".x, \" + t + \".x, \" + t + \".y\\n\" +\n\t\t\t// (t.x - cos(t.w)*cos(t.z)) ^ k\n\t\t\t\"cos \" + t + \".z, \" + t + \".z\\n\" +\n\t\t\t\"cos \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t// (t.x - t.w*t.z) ^ k\n\t\t\t\"mul \" + t + \".w, \" + t + \".w, \" + t + \".z\\n\" +\n\t\t\t// (t.x - t.w) ^ k\n\t\t\t\"sub \" + t + \".w, \" + t + \".x, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}",
    "import {AssetEvent}\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\n\nimport {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {LightingMethodBase}\t\t\t\tfrom \"../methods/LightingMethodBase\";\nimport {ShadingMethodBase}\t\t\t\tfrom \"../methods/ShadingMethodBase\";\n\n/**\n * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated\n * version of Phong specularity).\n */\nexport class SpecularBasicMethod extends LightingMethodBase\n{\n\tpublic _pTotalLightColorReg:ShaderRegisterElement;\n\tpublic _pSpecularTexData:ShaderRegisterElement;\n\tpublic _pSpecularDataRegister:ShaderRegisterElement;\n\n\tprivate _texture:TextureBase;\n\n\tprivate _gloss:number = 50;\n\tprivate _strength:number = 1;\n\tprivate _color:number = 0xffffff;\n\tpublic _iSpecularR:number = 1;\n\tpublic _iSpecularG:number = 1;\n\tpublic _iSpecularB:number = 1;\n\tpublic _pIsFirstLight:boolean;\n\n\t/**\n\t * Creates a new SpecularBasicMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\tpublic iIsUsed(shader:LightingShader):boolean\n\t{\n\t\tif (!shader.numLights)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tmethodVO.needsNormals = shader.numLights > 0;\n\t\tmethodVO.needsView = shader.numLights > 0;\n\n\t\tif (this._texture) {\n\t\t\tmethodVO.textureGL = shader.getAbstraction(this._texture);\n\t\t\tshader.uvDependencies++;\n\t\t} else if (methodVO.textureGL) {\n\t\t\tmethodVO.textureGL.onClear(new AssetEvent(AssetEvent.CLEAR, null));\n\t\t\tmethodVO.textureGL = null;\n\t\t}\n\t}\n\n\t/**\n\t * The glossiness of the material (sharpness of the specular highlight).\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._gloss = value;\n\t}\n\n\t/**\n\t * The overall strength of the specular highlights.\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tif (value == this._strength)\n\t\t\treturn;\n\n\t\tthis._strength = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * The colour of the specular reflection of the surface.\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this._color;\n\t}\n\n\tpublic set color(value:number)\n\t{\n\t\tif (this._color == value)\n\t\t\treturn;\n\n\t\t// specular is now either enabled or disabled\n\t\tif (this._color == 0 || value == 0)\n\t\t\tthis.iInvalidateShaderProgram();\n\n\t\tthis._color = value;\n\t\tthis.updateSpecular();\n\t}\n\n\t/**\n\t * A texture that defines the strength of specular reflections for each texel in the red channel,\n\t * and the gloss factor (sharpness) in the green channel. You can use Specular2DTexture if you want to easily set\n\t * specular and gloss maps from grayscale images, but correctly authored images are preferred.\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tif (this._texture == value)\n\t\t\treturn;\n\n\t\tif (this._texture)\n\t\t\tthis.iRemoveTexture(this._texture);\n\n\t\tthis._texture = value;\n\n\t\tif (this._texture)\n\t\t\tthis.iAddTexture(this._texture);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic copyFrom(method:ShadingMethodBase):void\n\t{\n\n\t\tvar m:any = method;\n\t\tvar bsm:SpecularBasicMethod = <SpecularBasicMethod> method;\n\n\t\tvar spec:SpecularBasicMethod = bsm;//SpecularBasicMethod(method);\n\t\tthis.texture = spec.texture;\n\t\tthis.strength = spec.strength;\n\t\tthis.color = spec.color;\n\t\tthis.gloss = spec.gloss;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData():void\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._pTotalLightColorReg = null;\n\t\tthis._pSpecularTexData = null;\n\t\tthis._pSpecularDataRegister = null;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tthis._pIsFirstLight = true;\n\n\t\tthis._pSpecularDataRegister = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index*4;\n\n\t\tif (this._texture) {\n\n\t\t\tthis._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(this._pSpecularTexData, 1);\n\n\t\t\tcode += methodVO.textureGL._iGetFragmentCode(this._pSpecularTexData, registerCache, sharedRegisters, sharedRegisters.uvVarying);\n\t\t}\n\n\t\tthis._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();\n\t\tregisterCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\n\t\t// blinn-phong half vector model\n\t\tcode += \"add \" + t + \", \" + lightDirReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"nrm \" + t + \".xyz, \" + t + \"\\n\" +\n\t\t\t\t\"dp3 \" + t + \".w, \" + normalReg + \", \" + t + \"\\n\" +\n\t\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else {\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\t\t}\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \", \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\t// write in temporary if not first light, so we can add to total diffuse colour\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar normalReg:ShaderRegisterElement = sharedRegisters.normalFragment;\n\t\tvar viewDirReg:ShaderRegisterElement = sharedRegisters.viewDirFragment;\n\n\t\tcode += \"dp3 \" + t + \".w, \" + normalReg + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" +\n\t\t\t\t\"mul \" + t + \", \" + t + \".w, \" + normalReg + \"\\n\" +\n\t\t\t\t\"sub \" + t + \", \" + t + \", \" + viewDirReg + \"\\n\" +\n\t\t\t\t\"tex \" + t + \", \" + t + \", \" + cubeMapReg + \" <cube,\" + \"linear\" + \",miplinear>\\n\" +\n\t\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + weightRegister + \"\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + t + \"\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (sharedRegisters.shadowTarget)\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + sharedRegisters.shadowTarget + \".w\\n\";\n\n\t\tif (this._texture) {\n\t\t\t// apply strength modulation from texture\n\t\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularTexData + \".x\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(this._pSpecularTexData);\n\t\t}\n\n\t\t// apply material's specular reflection\n\t\tcode += \"mul \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \", \" + this._pSpecularDataRegister + \"\\n\" +\n\t\t\t\"add \" + targetReg + \".xyz, \" + targetReg + \", \" + this._pTotalLightColorReg + \"\\n\";\n\t\tregisterCache.removeFragmentTempUsage(this._pTotalLightColorReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL.activate(methodVO.pass._render);\n\n\t\tvar index:number = methodVO.fragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._iSpecularR;\n\t\tdata[index + 1] = this._iSpecularG;\n\t\tdata[index + 2] = this._iSpecularB;\n\t\tdata[index + 3] = this._gloss;\n\t}\n\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tif (this._texture)\n\t\t\tmethodVO.textureGL._setRenderState(renderable);\n\t}\n\n\t/**\n\t * Updates the specular color data used by the render state.\n\t */\n\tprivate updateSpecular():void\n\t{\n\t\tthis._iSpecularR = (( this._color >> 16) & 0xff)/0xff*this._strength;\n\t\tthis._iSpecularG = (( this._color >> 8) & 0xff)/0xff*this._strength;\n\t\tthis._iSpecularB = ( this._color & 0xff)/0xff*this._strength;\n\t}\n}",
    "import {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {SpecularBasicMethod}\t\t\t\tfrom \"../methods/SpecularBasicMethod\";\nimport {SpecularCompositeMethod}\t\t\tfrom \"../methods/SpecularCompositeMethod\";\n\n/**\n * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.\n */\nexport class SpecularCelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _smoothness:number = .1;\n\tprivate _specularCutOff:number = .1;\n\n\t/**\n\t * Creates a new SpecularCelMethod object.\n\t * @param specularCutOff The threshold at which the specular highlight should be shown.\n\t * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.\n\t */\n\tconstructor(specularCutOff:number = .5, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.clampSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._specularCutOff = specularCutOff;\n\t}\n\n\t/**\n\t * The smoothness of the highlight edge.\n\t */\n\tpublic get smoothness():number\n\t{\n\t\treturn this._smoothness;\n\t}\n\n\tpublic set smoothness(value:number)\n\t{\n\t\tthis._smoothness = value;\n\t}\n\n\t/**\n\t * The threshold at which the specular highlight should be shown.\n\t */\n\tpublic get specularCutOff():number\n\t{\n\t\treturn this._specularCutOff;\n\t}\n\n\tpublic set specularCutOff(value:number)\n\t{\n\t\tthis._specularCutOff = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar index:number /*int*/ = methodVO.secondaryFragmentConstantsIndex;\n\t\tvar data:Float32Array = shader.fragmentConstantData;\n\t\tdata[index] = this._smoothness;\n\t\tdata[index + 1] = this._specularCutOff;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData():void\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff\n\t * @param vo The MethodVO used to compile the current shader.\n\t * @param t The register containing the specular strength in the \"w\" component, and either the half-vector or the reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared register data for this shader.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate clampSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn \"sub \" + targetReg + \".y, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" + // x - cutoff\n\t\t\t\"div \" + targetReg + \".y, \" + targetReg + \".y, \" + this._dataReg + \".x\\n\" + // (x - cutoff)/epsilon\n\t\t\t\"sat \" + targetReg + \".y, \" + targetReg + \".y\\n\" +\n\t\t\t\"sge \" + targetReg + \".w, \" + targetReg + \".w, \" + this._dataReg + \".y\\n\" +\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n}",
    "import {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\nimport {ISurface}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {ShadingMethodEvent}\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {SpecularBasicMethod}\t\t\t\tfrom \"../methods/SpecularBasicMethod\";\n\n/**\n * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the\n * calculated specular reflection strength.\n */\nexport class SpecularCompositeMethod extends SpecularBasicMethod\n{\n\tprivate _baseMethod:SpecularBasicMethod;\n\n\tprivate _onShaderInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\t/**\n\t * Creates a new <code>SpecularCompositeMethod</code> object.\n\t *\n\t * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.\n\t * @param baseMethod The base specular method on which this method's shading is based.\n\t */\n\tconstructor(modulateMethod:(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => string, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\tsuper();\n\n\t\tthis._onShaderInvalidatedDelegate = (event:ShadingMethodEvent) => this.onShaderInvalidated(event);\n\n\t\tthis._baseMethod = baseMethod || new SpecularBasicMethod();\n\t\tthis._baseMethod._iModulateMethod = modulateMethod;\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitVO(shader:LightingShader, methodVO:MethodVO):void\n\t{\n\t\tthis._baseMethod.iInitVO(shader, methodVO);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tthis._baseMethod.iInitConstants(shader, methodVO);\n\t}\n\n\n\tpublic iAddOwner(owner:ISurface):void\n\t{\n\t\tsuper.iAddOwner(owner);\n\n\t\tthis._baseMethod.iAddOwner(owner);\n\t}\n\n\tpublic iRemoveOwner(owner:ISurface):void\n\t{\n\t\tsuper.iRemoveOwner(owner);\n\n\t\tthis._baseMethod.iRemoveOwner(owner);\n\t}\n\n\t/**\n\t * The base specular method on which this method's shading is based.\n\t */\n\tpublic get baseMethod():SpecularBasicMethod\n\t{\n\t\treturn this._baseMethod;\n\t}\n\n\tpublic set baseMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._baseMethod == value)\n\t\t\treturn;\n\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis._baseMethod = value;\n\n\t\tthis._baseMethod.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get gloss():number\n\t{\n\t\treturn this._baseMethod.gloss;\n\t}\n\n\tpublic set gloss(value:number)\n\t{\n\t\tthis._baseMethod.gloss = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get strength():number\n\t{\n\t\treturn this._baseMethod.strength;\n\t}\n\n\tpublic set strength(value:number)\n\t{\n\t\tthis._baseMethod.strength = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get color():number\n\t{\n\t\treturn this._baseMethod.color;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic set color(value:number)\n\t{\n\t\tthis._baseMethod.color = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose():void\n\t{\n\t\tthis._baseMethod.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);\n\t\tthis._baseMethod.dispose();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic get texture():TextureBase\n\t{\n\t\treturn this._baseMethod.texture;\n\t}\n\n\tpublic set texture(value:TextureBase)\n\t{\n\t\tthis._baseMethod.texture = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tthis._baseMethod.iActivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iSetRenderState(shader:LightingShader, methodVO:MethodVO, renderable:GL_RenderableBase, stage:Stage, camera:Camera):void\n\t{\n\t\tthis._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iDeactivate(shader:ShaderBase, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tthis._baseMethod.iDeactivate(shader, methodVO, stage);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetVertexCode(shader:ShaderBase, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @return\n\t */\n\tpublic iGetFragmentCodePerProbe(shader:LightingShader, methodVO:MethodVO, cubeMapReg:ShaderRegisterElement, weightRegister:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPostLightingCode(shader:LightingShader, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._baseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iReset():void\n\t{\n\t\tthis._baseMethod.iReset();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData():void\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._baseMethod.iCleanCompilationData();\n\t}\n\n\t/**\n\t * Called when the base method's shader code is invalidated.\n\t */\n\tprivate onShaderInvalidated(event:ShadingMethodEvent):void\n\t{\n\t\tthis.iInvalidateShaderProgram();\n\t}\n}",
    "import {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {SpecularBasicMethod}\t\t\t\tfrom \"../methods/SpecularBasicMethod\";\nimport {SpecularCompositeMethod}\t\t\tfrom \"../methods/SpecularCompositeMethod\";\n\n/**\n * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.\n */\nexport class SpecularFresnelMethod extends SpecularCompositeMethod\n{\n\tprivate _dataReg:ShaderRegisterElement;\n\tprivate _incidentLight:boolean;\n\tprivate _fresnelPower:number = 5;\n\tprivate _normalReflectance:number = .028; // default value for skin\n\n\t/**\n\t * Creates a new SpecularFresnelMethod object.\n\t * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.\n\t */\n\tconstructor(basedOnSurface:boolean = true, baseMethod:SpecularBasicMethod = null)\n\t{\n\t\t// may want to offer diff speculars\n\t\tsuper(null, baseMethod);\n\n\t\tthis.baseMethod._iModulateMethod = (shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData) => this.modulateSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters);\n\n\t\tthis._incidentLight = !basedOnSurface;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iInitConstants(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tshader.fragmentConstantData[index + 2] = 1;\n\t\tshader.fragmentConstantData[index + 3] = 0;\n\t}\n\n\t/**\n\t * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.\n\t */\n\tpublic get basedOnSurface():boolean\n\t{\n\t\treturn !this._incidentLight;\n\t}\n\n\tpublic set basedOnSurface(value:boolean)\n\t{\n\t\tif (this._incidentLight != value)\n\t\t\treturn;\n\n\t\tthis._incidentLight = !value;\n\n\t\tthis.iInvalidateShaderProgram();\n\t}\n\n\t/**\n\t * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.\n\t */\n\tpublic get fresnelPower():number\n\t{\n\t\treturn this._fresnelPower;\n\t}\n\n\tpublic set fresnelPower(value:number)\n\t{\n\t\tthis._fresnelPower = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iCleanCompilationData():void\n\t{\n\t\tsuper.iCleanCompilationData();\n\t\tthis._dataReg = null;\n\t}\n\n\t/**\n\t * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.\n\t */\n\tpublic get normalReflectance():number\n\t{\n\t\treturn this._normalReflectance;\n\t}\n\n\tpublic set normalReflectance(value:number)\n\t{\n\t\tthis._normalReflectance = value;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iActivate(shader:LightingShader, methodVO:MethodVO, stage:Stage):void\n\t{\n\t\tsuper.iActivate(shader, methodVO, stage);\n\n\t\tvar fragmentData:Float32Array = shader.fragmentConstantData;\n\n\t\tvar index:number = methodVO.secondaryFragmentConstantsIndex;\n\t\tfragmentData[index] = this._normalReflectance;\n\t\tfragmentData[index + 1] = this._fresnelPower;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentPreLightingCode(shader:LightingShader, methodVO:MethodVO, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tthis._dataReg = registerCache.getFreeFragmentConstant();\n\n\t\tmethodVO.secondaryFragmentConstantsIndex = this._dataReg.index*4;\n\n\t\treturn super.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);\n\t}\n\n\t/**\n\t * Applies the fresnel effect to the specular strength.\n\t *\n\t * @param vo The MethodVO object containing the method data for the currently compiled material pass.\n\t * @param target The register containing the specular strength in the \"w\" component, and the half-vector/reflection vector in \"xyz\".\n\t * @param regCache The register cache used for the shader compilation.\n\t * @param sharedRegisters The shared registers created by the compiler.\n\t * @return The AGAL fragment code for the method.\n\t */\n\tprivate modulateSpecular(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string;\n\n\t\tcode = \"dp3 \" + targetReg + \".y, \" + sharedRegisters.viewDirFragment + \".xyz, \" + (this._incidentLight? targetReg : sharedRegisters.normalFragment) + \".xyz\\n\" +   // dot(V, H)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // base = 1-dot(V, H)\n\t\t\t\"pow \" + targetReg + \".x, \" + targetReg + \".y, \" + this._dataReg + \".y\\n\" +             // exp = pow(base, 5)\n\t\t\t\"sub \" + targetReg + \".y, \" + this._dataReg + \".z, \" + targetReg + \".y\\n\" +             // 1 - exp\n\t\t\t\"mul \" + targetReg + \".y, \" + this._dataReg + \".x, \" + targetReg + \".y\\n\" +             // f0*(1 - exp)\n\t\t\t\"add \" + targetReg + \".y, \" + targetReg + \".x, \" + targetReg + \".y\\n\" +          // exp + f0*(1 - exp)\n\t\t\t\"mul \" + targetReg + \".w, \" + targetReg + \".w, \" + targetReg + \".y\\n\";\n\n\t\treturn code;\n\t}\n\n}",
    "import {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../data/MethodVO\";\nimport {SpecularBasicMethod}\t\t\t\tfrom \"../methods/SpecularBasicMethod\";\n\n/**\n * SpecularPhongMethod provides a specular method that provides Phong highlights.\n */\nexport class SpecularPhongMethod extends SpecularBasicMethod\n{\n\t/**\n\t * Creates a new SpecularPhongMethod object.\n\t */\n\tconstructor()\n\t{\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic iGetFragmentCodePerLight(shader:LightingShader, methodVO:MethodVO, lightDirReg:ShaderRegisterElement, lightColReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar t:ShaderRegisterElement;\n\n\t\tif (this._pIsFirstLight) {\n\t\t\tt = this._pTotalLightColorReg;\n\t\t} else {\n\t\t\tt = registerCache.getFreeFragmentVectorTemp();\n\t\t\tregisterCache.addFragmentTempUsages(t, 1);\n\t\t}\n\n\t\tvar viewDirReg:ShaderRegisterElement =sharedRegisters.viewDirFragment;\n\t\tvar normalReg:ShaderRegisterElement =sharedRegisters.normalFragment;\n\n\t\t// phong model\n\t\tcode += \"dp3 \" + t + \".w, \" + lightDirReg + \", \" + normalReg + \"\\n\" + // sca1 = light.normal\n\n\t\t\t//find the reflected light vector R\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" + t + \".w\\n\" + // sca1 = sca1*2\n\t\t\t\"mul \" + t + \".xyz, \" + normalReg + \", \" + t + \".w\\n\" + // vec1 = normal*sca1\n\t\t\t\"sub \" + t + \".xyz, \" + t + \", \" + lightDirReg + \"\\n\" + // vec1 = vec1 - light (light vector is negative)\n\n\t\t\t//smooth the edge as incidence angle approaches 90\n\t\t\t\"add \" + t + \".w, \" + t + \".w, \" +sharedRegisters.commons + \".w\\n\" + // sca1 = sca1 + smoothtep;\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\" + // sca1 range 0 - 1\n\t\t\t\"mul \" + t + \".xyz, \" + t + \", \" + t + \".w\\n\" + // vec1 = vec1*sca1\n\n\t\t\t//find the dot product between R and V\n\t\t\t\"dp3 \" + t + \".w, \" + t + \", \" + viewDirReg + \"\\n\" + // sca1 = vec1.view\n\t\t\t\"sat \" + t + \".w, \" + t + \".w\\n\";\n\n\t\tif (this.texture) {\n\t\t\t// apply gloss modulation from texture\n\t\t\tcode += \"mul \" + this._pSpecularTexData + \".w, \" + this._pSpecularTexData + \".y, \" + this._pSpecularDataRegister + \".w\\n\" +\n\t\t\t\t\"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularTexData + \".w\\n\";\n\t\t} else\n\t\t\tcode += \"pow \" + t + \".w, \" + t + \".w, \" + this._pSpecularDataRegister + \".w\\n\";\n\n\t\t// attenuate\n\t\tif (shader.usesLightFallOff)\n\t\t\tcode += \"mul \" + t + \".w, \" + t + \".w, \" + lightDirReg + \".w\\n\";\n\n\t\tif (this._iModulateMethod != null)\n\t\t\tcode += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);\n\n\t\tcode += \"mul \" + t + \".xyz, \" + lightColReg + \".xyz, \" + t + \".w\\n\";\n\n\t\tif (!this._pIsFirstLight) {\n\t\t\tcode += \"add \" + this._pTotalLightColorReg + \".xyz, \" + this._pTotalLightColorReg + \".xyz, \" + t + \".xyz\\n\";\n\t\t\tregisterCache.removeFragmentTempUsage(t);\n\t\t}\n\n\t\tthis._pIsFirstLight = false;\n\n\t\treturn code;\n\t}\n}",
    "export {AmbientBasicMethod}\t\t\t\tfrom \"./methods/AmbientBasicMethod\";\nexport {AmbientEnvMapMethod}\t\t\t\tfrom \"./methods/AmbientEnvMapMethod\";\nexport {CurveBasicMethod}\t\t\t\tfrom \"./methods/CurveBasicMethod\";\nexport {DiffuseBasicMethod}\t\t\t\tfrom \"./methods/DiffuseBasicMethod\";\nexport {DiffuseCelMethod}\t\t\t\tfrom \"./methods/DiffuseCelMethod\";\nexport {DiffuseCompositeMethod}\t\t\tfrom \"./methods/DiffuseCompositeMethod\";\nexport {DiffuseDepthMethod}\t\t\t\tfrom \"./methods/DiffuseDepthMethod\";\nexport {DiffuseGradientMethod}\t\t\tfrom \"./methods/DiffuseGradientMethod\";\nexport {DiffuseLightMapMethod}\t\t\tfrom \"./methods/DiffuseLightMapMethod\";\nexport {DiffuseSubSurfaceMethod}\t\t\tfrom \"./methods/DiffuseSubSurfaceMethod\";\nexport {DiffuseWrapMethod}\t\t\t\tfrom \"./methods/DiffuseWrapMethod\";\nexport {EffectAlphaMaskMethod}\t\t\tfrom \"./methods/EffectAlphaMaskMethod\";\nexport {EffectColorMatrixMethod}\t\t\tfrom \"./methods/EffectColorMatrixMethod\";\nexport {EffectColorTransformMethod}\t\tfrom \"./methods/EffectColorTransformMethod\";\nexport {EffectEnvMapMethod}\t\t\t\tfrom \"./methods/EffectEnvMapMethod\";\nexport {EffectFogMethod}\t\t\t\t\tfrom \"./methods/EffectFogMethod\";\nexport {EffectFresnelEnvMapMethod}\t\tfrom \"./methods/EffectFresnelEnvMapMethod\";\nexport {EffectLightMapMethod}\t\t\tfrom \"./methods/EffectLightMapMethod\";\nexport {EffectMethodBase}\t\t\t\tfrom \"./methods/EffectMethodBase\";\nexport {EffectRefractionEnvMapMethod}\tfrom \"./methods/EffectRefractionEnvMapMethod\";\nexport {EffectRimLightMethod}\t\t\tfrom \"./methods/EffectRimLightMethod\";\nexport {LightingMethodBase}\t\t\t\tfrom \"./methods/LightingMethodBase\";\nexport {NormalBasicMethod}\t\t\t\tfrom \"./methods/NormalBasicMethod\";\nexport {NormalHeightMapMethod}\t\t\tfrom \"./methods/NormalHeightMapMethod\";\nexport {NormalSimpleWaterMethod}\t\t\tfrom \"./methods/NormalSimpleWaterMethod\";\nexport {ShadingMethodBase}\t\t\t\tfrom \"./methods/ShadingMethodBase\";\nexport {ShadowCascadeMethod}\t\t\t\tfrom \"./methods/ShadowCascadeMethod\";\nexport {ShadowDitheredMethod}\t\t\tfrom \"./methods/ShadowDitheredMethod\";\nexport {ShadowFilteredMethod}\t\t\tfrom \"./methods/ShadowFilteredMethod\";\nexport {ShadowHardMethod}\t\t\t\tfrom \"./methods/ShadowHardMethod\";\nexport {ShadowMapMethodBase}\t\t\t\tfrom \"./methods/ShadowMapMethodBase\";\nexport {ShadowMethodBase}\t\t\t\tfrom \"./methods/ShadowMethodBase\";\nexport {ShadowNearMethod}\t\t\t\tfrom \"./methods/ShadowNearMethod\";\nexport {ShadowSoftMethod}\t\t\t\tfrom \"./methods/ShadowSoftMethod\";\nexport {SpecularAnisotropicMethod}\t\tfrom \"./methods/SpecularAnisotropicMethod\";\nexport {SpecularBasicMethod}\t\t\t\tfrom \"./methods/SpecularBasicMethod\";\nexport {SpecularCelMethod}\t\t\t\tfrom \"./methods/SpecularCelMethod\";\nexport {SpecularCompositeMethod}\t\t\tfrom \"./methods/SpecularCompositeMethod\";\nexport {SpecularFresnelMethod}\t\t\tfrom \"./methods/SpecularFresnelMethod\";\nexport {SpecularPhongMethod}\t\t\t\tfrom \"./methods/SpecularPhongMethod\";",
    "import {BlendMode}\t\t\t\t\t\tfrom \"awayjs-core/lib/image/BlendMode\";\nimport {AssetEvent}\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\n\nimport {StaticLightPicker}\t\t\t\tfrom \"awayjs-display/lib/materials/lightpickers/StaticLightPicker\";\n\nimport {ContextGLCompareMode}\t\t\t\tfrom \"awayjs-stagegl/lib/base/ContextGLCompareMode\";\n\nimport {IElementsClassGL}\t\t\t\t\tfrom \"awayjs-renderergl/lib/elements/IElementsClassGL\";\nimport {GL_SurfaceBase}\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/GL_SurfaceBase\";\nimport {SurfacePool}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/SurfacePool\";\n\nimport {MethodMaterial}\t\t\t\t\tfrom \"../MethodMaterial\";\nimport {MethodMaterialMode}\t\t\t\tfrom \"../MethodMaterialMode\";\nimport {MethodPassMode}\t\t\t\t\tfrom \"../surfaces/passes/MethodPassMode\";\nimport {MethodPass}\t\t\t\t\t\tfrom \"../surfaces/passes/MethodPass\";\nimport {EffectMethodBase}\t\t\t\t\tfrom \"../methods/EffectMethodBase\";\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nexport class GL_MethodMaterialSurface extends GL_SurfaceBase\n{\n\tprivate _material:MethodMaterial;\n\tprivate _pass:MethodPass;\n\tprivate _casterLightPass:MethodPass;\n\tprivate _nonCasterLightPasses:Array<MethodPass>;\n\t\n\t/**\n\t * The maximum total number of lights provided by the light picker.\n\t */\n\tprivate get numLights():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights + this._material.lightPicker.numCastingDirectionalLights + this._material.lightPicker.numCastingPointLights : 0;\n\t}\n\n\t/**\n\t * The amount of lights that don't cast shadows.\n\t */\n\tprivate get numNonCasters():number\n\t{\n\t\treturn this._material.lightPicker? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights : 0;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(material:MethodMaterial, elementsClass:IElementsClassGL, pool:SurfacePool)\n\t{\n\t\tsuper(material, elementsClass, pool);\n\n\t\tthis._material = material;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _pUpdateRender():void\n\t{\n\t\tsuper._pUpdateRender();\n\n\t\tthis.initPasses();\n\n\t\tthis.setBlendAndCompareModes();\n\n\t\tthis._pClearPasses();\n\n\t\tif (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this._casterLightPass)\n\t\t\t\tthis._pAddPass(this._casterLightPass);\n\n\t\t\tif (this._nonCasterLightPasses)\n\t\t\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\t\t\tthis._pAddPass(this._nonCasterLightPasses[i]);\n\t\t}\n\n\t\tif (this._pass)\n\t\t\tthis._pAddPass(this._pass);\n\t}\n\n\t/**\n\t * Initializes all the passes and their dependent passes.\n\t */\n\tprivate initPasses():void\n\t{\n\t\t// let the effects pass handle everything if there are no lights, when there are effect methods applied\n\t\t// after shading, or when the material mode is single pass.\n\t\tif (this.numLights == 0 || this._material.numEffectMethods > 0 || this._material.mode == MethodMaterialMode.SINGLE_PASS)\n\t\t\tthis.initEffectPass();\n\t\telse if (this._pass)\n\t\t\tthis.removeEffectPass();\n\n\t\t// only use a caster light pass if shadows need to be rendered\n\t\tif (this._material.shadowMethod && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initCasterLightPass();\n\t\telse if (this._casterLightPass)\n\t\t\tthis.removeCasterLightPass();\n\n\t\t// only use non caster light passes if there are lights that don't cast\n\t\tif (this.numNonCasters > 0 && this._material.mode == MethodMaterialMode.MULTI_PASS)\n\t\t\tthis.initNonCasterLightPasses();\n\t\telse if (this._nonCasterLightPasses)\n\t\t\tthis.removeNonCasterLightPasses();\n\t}\n\n\t/**\n\t * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.\n\t */\n\tprivate setBlendAndCompareModes():void\n\t{\n\t\tvar forceSeparateMVP:boolean = Boolean(this._casterLightPass || this._pass);\n\n\t\t// caster light pass is always first if it exists, hence it uses normal blending\n\t\tif (this._casterLightPass) {\n\t\t\tthis._casterLightPass.forceSeparateMVP = forceSeparateMVP;\n\t\t\tthis._casterLightPass.shader.setBlendMode(BlendMode.NORMAL);\n\t\t\tthis._casterLightPass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\n\t\tif (this._nonCasterLightPasses) {\n\t\t\tvar firstAdditiveIndex:number = 0;\n\n\t\t\t// if there's no caster light pass, the first non caster light pass will be the first\n\t\t\t// and should use normal blending\n\t\t\tif (!this._casterLightPass) {\n\t\t\t\tthis._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[0].shader.setBlendMode(BlendMode.NORMAL);\n\t\t\t\tthis._nonCasterLightPasses[0].shader.depthCompareMode = this._material.depthCompareMode;\n\t\t\t\tfirstAdditiveIndex = 1;\n\t\t\t}\n\n\t\t\t// all lighting passes following the first light pass should use additive blending\n\t\t\tfor (var i:number = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {\n\t\t\t\tthis._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._nonCasterLightPasses[i].shader.setBlendMode(BlendMode.ADD);\n\t\t\t\tthis._nonCasterLightPasses[i].shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t}\n\t\t}\n\n\t\tif (this._casterLightPass || this._nonCasterLightPasses) {\n\t\t\t//cannot be blended by blendmode property if multipass enabled\n\t\t\tthis._pRequiresBlending = false;\n\n\t\t\t// there are light passes, so this should be blended in\n\t\t\tif (this._pass) {\n\t\t\t\tthis._pass.mode = MethodPassMode.EFFECTS;\n\t\t\t\tthis._pass.forceSeparateMVP = forceSeparateMVP;\n\t\t\t\tthis._pass.shader.depthCompareMode = ContextGLCompareMode.LESS_EQUAL;\n\t\t\t\tthis._pass.shader.setBlendMode(BlendMode.LAYER);\n\t\t\t}\n\n\t\t} else if (this._pass) {\n\t\t\tthis._pRequiresBlending = (this._material.blendMode != BlendMode.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));\n\t\t\t// effects pass is the only pass, so it should just blend normally\n\t\t\tthis._pass.mode = MethodPassMode.SUPER_SHADER;\n\t\t\tthis._pass.preserveAlpha = this._pRequiresBlending;\n\t\t\tthis._pass.forceSeparateMVP = false;\n\t\t\tthis._pass.colorTransform = this._material.colorTransform;\n\t\t\tthis._pass.shader.setBlendMode((this._material.blendMode == BlendMode.NORMAL && this._pRequiresBlending)? BlendMode.LAYER : this._material.blendMode);\n\t\t\tthis._pass.shader.depthCompareMode = this._material.depthCompareMode;\n\t\t}\n\t}\n\n\tprivate initCasterLightPass():void\n\t{\n\n\t\tif (this._casterLightPass == null)\n\t\t\tthis._casterLightPass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._elementsClass, this._stage);\n\n\t\tthis._casterLightPass.lightPicker = new StaticLightPicker([this._material.shadowMethod.castingLight]);\n\t\tthis._casterLightPass.shadowMethod = this._material.shadowMethod;\n\t\tthis._casterLightPass.diffuseMethod = this._material.diffuseMethod;\n\t\tthis._casterLightPass.ambientMethod = this._material.ambientMethod;\n\t\tthis._casterLightPass.normalMethod = this._material.normalMethod;\n\t\tthis._casterLightPass.specularMethod = this._material.specularMethod;\n\t}\n\n\tprivate removeCasterLightPass():void\n\t{\n\t\tthis._casterLightPass.dispose();\n\t\tthis._pRemovePass(this._casterLightPass);\n\t\tthis._casterLightPass = null;\n\t}\n\n\tprivate initNonCasterLightPasses():void\n\t{\n\t\tthis.removeNonCasterLightPasses();\n\t\tvar pass:MethodPass;\n\t\tvar numDirLights:number = this._material.lightPicker.numDirectionalLights;\n\t\tvar numPointLights:number = this._material.lightPicker.numPointLights;\n\t\tvar numLightProbes:number = this._material.lightPicker.numLightProbes;\n\t\tvar dirLightOffset:number = 0;\n\t\tvar pointLightOffset:number = 0;\n\t\tvar probeOffset:number = 0;\n\n\t\tif (!this._casterLightPass) {\n\t\t\tnumDirLights += this._material.lightPicker.numCastingDirectionalLights;\n\t\t\tnumPointLights += this._material.lightPicker.numCastingPointLights;\n\t\t}\n\n\t\tthis._nonCasterLightPasses = new Array<MethodPass>();\n\n\t\twhile (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {\n\t\t\tpass = new MethodPass(MethodPassMode.LIGHTING, this, this._material, this._elementsClass, this._stage);\n\t\t\tpass.includeCasters = this._material.shadowMethod == null;\n\t\t\tpass.directionalLightsOffset = dirLightOffset;\n\t\t\tpass.pointLightsOffset = pointLightOffset;\n\t\t\tpass.lightProbesOffset = probeOffset;\n\t\t\tpass.lightPicker = this._material.lightPicker;\n\t\t\tpass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tpass.ambientMethod = this._material.ambientMethod;\n\t\t\tpass.normalMethod = this._material.normalMethod;\n\t\t\tpass.specularMethod = this._material.specularMethod;\n\t\t\tthis._nonCasterLightPasses.push(pass);\n\n\t\t\tdirLightOffset += pass.numDirectionalLights;\n\t\t\tpointLightOffset += pass.numPointLights;\n\t\t\tprobeOffset += pass.numLightProbes;\n\t\t}\n\t}\n\n\tprivate removeNonCasterLightPasses():void\n\t{\n\t\tif (!this._nonCasterLightPasses)\n\t\t\treturn;\n\n\t\tfor (var i:number = 0; i < this._nonCasterLightPasses.length; ++i)\n\t\t\tthis._pRemovePass(this._nonCasterLightPasses[i]);\n\n\t\tthis._nonCasterLightPasses = null;\n\t}\n\n\tprivate removeEffectPass():void\n\t{\n\t\tif (this._pass.ambientMethod != this._material.ambientMethod)\n\t\t\tthis._pass.ambientMethod.dispose();\n\n\t\tif (this._pass.diffuseMethod != this._material.diffuseMethod)\n\t\t\tthis._pass.diffuseMethod.dispose();\n\n\t\tif (this._pass.specularMethod != this._material.specularMethod)\n\t\t\tthis._pass.specularMethod.dispose();\n\n\t\tif (this._pass.normalMethod != this._material.normalMethod)\n\t\t\tthis._pass.normalMethod.dispose();\n\n\t\tthis._pRemovePass(this._pass);\n\t\tthis._pass = null;\n\t}\n\n\tprivate initEffectPass():void\n\t{\n\t\tif (this._pass == null)\n\t\t\tthis._pass = new MethodPass(MethodPassMode.SUPER_SHADER, this, this._material, this._elementsClass, this._stage);\n\n\t\tif (this._material.mode == MethodMaterialMode.SINGLE_PASS) {\n\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\tthis._pass.diffuseMethod = this._material.diffuseMethod;\n\t\t\tthis._pass.specularMethod = this._material.specularMethod;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t\tthis._pass.shadowMethod = this._material.shadowMethod;\n\t\t} else if (this._material.mode == MethodMaterialMode.MULTI_PASS) {\n\t\t\tif (this.numLights == 0) {\n\t\t\t\tthis._pass.ambientMethod = this._material.ambientMethod;\n\t\t\t} else {\n\t\t\t\tthis._pass.ambientMethod = null;\n\t\t\t}\n\n\t\t\tthis._pass.preserveAlpha = false;\n\t\t\tthis._pass.normalMethod = this._material.normalMethod;\n\t\t}\n\n\t\t//update effect methods\n\t\tvar i:number = 0;\n\t\tvar effectMethod:EffectMethodBase;\n\t\tvar len:number = Math.max(this._material.numEffectMethods, this._pass.numEffectMethods);\n\n\t\twhile (i < len) {\n\t\t\teffectMethod = this._material.getEffectMethodAt(i);\n\t\t\tif (effectMethod != this._pass.getEffectMethodAt(i)) {\n\t\t\t\tthis._pass.removeEffectMethodAt(i);\n\n\t\t\t\tif (effectMethod != null) {\n\t\t\t\t\tif (i < this._pass.numEffectMethods)\n\t\t\t\t\t\tthis._pass.addEffectMethodAt(effectMethod, i);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis._pass.addEffectMethod(effectMethod);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic onClear(event:AssetEvent):void\n\t{\n\t\tsuper.onClear(event);\n\n\t\t//TODO\n\t}\n}",
    "export class MethodPassMode\n{\n\t/**\n\t *\n\t */\n\tpublic static EFFECTS:number = 0x01;\n\n\t/**\n\t *\n\t */\n\tpublic static LIGHTING:number = 0x02;\n\n\t/**\n\t *\n\t */\n\tpublic static SUPER_SHADER:number = 0x03;\n}",
    "import {ColorTransform}\t\t\t\t\tfrom \"awayjs-core/lib/geom/ColorTransform\";\nimport {Matrix}\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Matrix\";\nimport {Matrix3D}\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Matrix3D\";\nimport {Matrix3DUtils}\t\t\t\t\tfrom \"awayjs-core/lib/geom/Matrix3DUtils\";\nimport {Vector3D}\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Vector3D\";\nimport {AbstractMethodError}\t\t\t\tfrom \"awayjs-core/lib/errors/AbstractMethodError\";\nimport {AssetEvent}\t\t\t\t\t\tfrom \"awayjs-core/lib/events/AssetEvent\";\nimport {MaterialBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/materials/MaterialBase\";\n\nimport {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {ISurface}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\nimport {LightPickerBase}\t\t\t\t\tfrom \"awayjs-display/lib/materials/lightpickers/LightPickerBase\";\nimport {LightSources}\t\t\t\t\t\tfrom \"awayjs-display/lib/materials/LightSources\";\n\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {RendererBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/RendererBase\";\nimport {LightingShader}\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/LightingShader\";\nimport {ShadingMethodEvent}\t\t\t\tfrom \"awayjs-renderergl/lib/events/ShadingMethodEvent\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {ShaderRegisterElement}\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterElement\";\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {PassBase}\t\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/passes/PassBase\";\nimport {ILightingPass}\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/passes/ILightingPass\";\nimport {IElementsClassGL}\t\t\t\t\tfrom \"awayjs-renderergl/lib/elements/IElementsClassGL\";\n\nimport {MethodVO}\t\t\t\t\t\t\tfrom \"../../data/MethodVO\";\nimport {AmbientBasicMethod}\t\t\t\tfrom \"../../methods/AmbientBasicMethod\";\nimport {DiffuseBasicMethod}\t\t\t\tfrom \"../../methods/DiffuseBasicMethod\";\nimport {EffectColorTransformMethod}\t\tfrom \"../../methods/EffectColorTransformMethod\";\nimport {EffectMethodBase}\t\t\t\t\tfrom \"../../methods/EffectMethodBase\";\nimport {LightingMethodBase}\t\t\t\tfrom \"../../methods/LightingMethodBase\";\nimport {NormalBasicMethod}\t\t\t\tfrom \"../../methods/NormalBasicMethod\";\nimport {ShadowMapMethodBase}\t\t\t\tfrom \"../../methods/ShadowMapMethodBase\";\nimport {SpecularBasicMethod}\t\t\t\tfrom \"../../methods/SpecularBasicMethod\";\nimport {MethodPassMode}\t\t\t\t\tfrom \"../../surfaces/passes/MethodPassMode\";\nimport {GL_MethodMaterialSurface}\t\t\tfrom \"../../surfaces/GL_MethodMaterialSurface\";\n\n/**\n * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,\n * using material methods to define their appearance.\n */\nexport class MethodPass extends PassBase implements ILightingPass\n{\n\tprivate _maxLights:number = 3;\n\n\tprivate _mode:number = 0x03;\n\tprivate _material:MaterialBase;\n\tprivate _lightPicker:LightPickerBase;\n\n\tprivate _includeCasters:boolean = true;\n\n\tpublic _iColorTransformMethodVO:MethodVO;\n\tpublic _iNormalMethodVO:MethodVO;\n\tpublic _iAmbientMethodVO:MethodVO;\n\tpublic _iShadowMethodVO:MethodVO;\n\tpublic _iDiffuseMethodVO:MethodVO;\n\tpublic _iSpecularMethodVO:MethodVO;\n\tpublic _iMethodVOs:Array<MethodVO> = new Array<MethodVO>();\n\n\tpublic _numEffectDependencies:number = 0;\n\n\tprivate _onLightsChangeDelegate:(event:AssetEvent) => void;\n\tprivate _onMethodInvalidatedDelegate:(event:ShadingMethodEvent) => void;\n\n\tpublic numDirectionalLights:number = 0;\n\n\tpublic numPointLights:number = 0;\n\n\tpublic numLightProbes:number = 0;\n\n\tpublic pointLightsOffset:number = 0;\n\t\n\tpublic directionalLightsOffset:number= 0;\n\t\n\tpublic lightProbesOffset:number = 0;\n\t\n\t/**\n\t *\n\t */\n\tpublic get mode():number\n\t{\n\t\treturn this._mode;\n\t}\n\n\tpublic set mode(value:number)\n\t{\n\t\tif (this._mode == value)\n\t\t\treturn;\n\t\t\n\t\tthis._mode = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * Indicates whether or not shadow casting lights need to be included.\n\t */\n\tpublic get includeCasters():boolean\n\t{\n\t\treturn this._includeCasters;\n\t}\n\n\tpublic set includeCasters(value:boolean)\n\t{\n\t\tif (this._includeCasters == value)\n\t\t\treturn;\n\n\t\tthis._includeCasters = value;\n\n\t\tthis._updateLights();\n\t}\n\n\t/**\n\t * \n\t * @returns {LightPickerBase}\n\t */\n\tpublic get lightPicker():LightPickerBase\n\t{\n\t\treturn this._lightPicker;\n\t}\n\n\tpublic set lightPicker(value:LightPickerBase)\n\t{\n\t\t//if (this._lightPicker == value)\n\t\t//\treturn;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\tthis._lightPicker = value;\n\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.addEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\tthis._updateLights();\n\t}\n\t\n\t/**\n\t * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and\n\t * compatibility for constrained mode.\n\t */\n\tpublic get enableLightFallOff():boolean\n\t{\n\t\treturn this._material.enableLightFallOff;\n\t}\n\n\t/**\n\t * Define which light source types to use for diffuse reflections. This allows choosing between regular lights\n\t * and/or light probes for diffuse reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get diffuseLightSources():number\n\t{\n\t\treturn this._material.diffuseLightSources;\n\t}\n\n\t/**\n\t * Define which light source types to use for specular reflections. This allows choosing between regular lights\n\t * and/or light probes for specular reflections.\n\t *\n\t * @see away3d.materials.LightSources\n\t */\n\tpublic get specularLightSources():number\n\t{\n\t\treturn this._material.specularLightSources;\n\t}\n\n\t/**\n\t * Creates a new CompiledPass object.\n\t *\n\t * @param material The material to which this pass belongs.\n\t */\n\tconstructor(mode:number, render:GL_MethodMaterialSurface, renderOwner:MaterialBase, elementsClass:IElementsClassGL, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, elementsClass, stage);\n\n\t\tthis._mode = mode;\n\n\t\tthis._material = renderOwner;\n\n\t\tthis._onLightsChangeDelegate = (event:AssetEvent) => this.onLightsChange(event);\n\t\t\n\t\tthis._onMethodInvalidatedDelegate = (event:ShadingMethodEvent) => this.onMethodInvalidated(event);\n\n\t\tthis.lightPicker = renderOwner.lightPicker;\n\n\t\tif (this._shader == null)\n\t\t\tthis._updateShader();\n\t}\n\n\tprivate _updateShader():void\n\t{\n\t\tif ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof LightingShader)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new LightingShader(this._elementsClass, this, this._stage);\n\t\t} else if (!(this._shader instanceof ShaderBase)) {\n\t\t\tif (this._shader != null)\n\t\t\t\tthis._shader.dispose();\n\n\t\t\tthis._shader = new ShaderBase(this._elementsClass, this, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the unchanging constant data for this material.\n\t */\n\tpublic _iInitConstantData(shader:ShaderBase):void\n\t{\n\t\tsuper._iInitConstantData(shader);\n\n\t\t//Updates method constants if they have changed.\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tthis._iMethodVOs[i].method.iInitConstants(shader, this._iMethodVOs[i]);\n\t}\n\n\t/**\n\t * The ColorTransform object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransform():ColorTransform\n\t{\n\t\treturn this.colorTransformMethod? this.colorTransformMethod.colorTransform : null;\n\t}\n\n\tpublic set colorTransform(value:ColorTransform)\n\t{\n\t\tif (value) {\n\t\t\tif (this.colorTransformMethod == null)\n\t\t\t\tthis.colorTransformMethod = new EffectColorTransformMethod();\n\n\t\t\tthis.colorTransformMethod.colorTransform = value;\n\n\t\t} else if (!value) {\n\t\t\tif (this.colorTransformMethod)\n\t\t\t\tthis.colorTransformMethod = null;\n\t\t}\n\t}\n\n\t/**\n\t * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.\n\t */\n\tpublic get colorTransformMethod():EffectColorTransformMethod\n\t{\n\t\treturn this._iColorTransformMethodVO? <EffectColorTransformMethod> this._iColorTransformMethodVO.method : null;\n\t}\n\n\tpublic set colorTransformMethod(value:EffectColorTransformMethod)\n\t{\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iColorTransformMethodVO) {\n\t\t\tthis._removeDependency(this._iColorTransformMethodVO);\n\t\t\tthis._iColorTransformMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iColorTransformMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iColorTransformMethodVO);\n\t\t}\n\t}\n\n\tprivate _removeDependency(methodVO:MethodVO, effectsDependency:boolean = false):void\n\t{\n\t\tvar index:number = this._iMethodVOs.indexOf(methodVO);\n\n\t\tif (!effectsDependency)\n\t\t\tthis._numEffectDependencies--;\n\n\t\tmethodVO.method.removeEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\t\tthis._iMethodVOs.splice(index, 1);\n\n\t\tthis.invalidate();\n\t}\n\n\tprivate _addDependency(methodVO:MethodVO, effectsDependency:boolean = false, index:number = -1):void\n\t{\n\t\tmethodVO.method.addEventListener(ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);\n\n\t\tif (effectsDependency) {\n\t\t\tif (index != -1)\n\t\t\t\tthis._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t\telse\n\t\t\t\tthis._iMethodVOs.push(methodVO);\n\t\t\tthis._numEffectDependencies++;\n\t\t} else {\n\t\t\tthis._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);\n\t\t}\n\n\t\tthis.invalidate();\n\t}\n\n\t/**\n\t * Appends an \"effect\" shading method to the shader. Effect methods are those that do not influence the lighting\n\t * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the\n\t * methods added prior.\n\t */\n\tpublic addEffectMethod(method:EffectMethodBase):void\n\t{\n\t\tthis._addDependency(new MethodVO(method, this), true);\n\t}\n\n\t/**\n\t * The number of \"effect\" methods added to the material.\n\t */\n\tpublic get numEffectMethods():number\n\t{\n\t\treturn this._numEffectDependencies;\n\t}\n\n\t/**\n\t * Queries whether a given effects method was added to the material.\n\t *\n\t * @param method The method to be queried.\n\t * @return true if the method was added to the material, false otherwise.\n\t */\n\tpublic hasEffectMethod(method:EffectMethodBase):boolean\n\t{\n\t\treturn this.getDependencyForMethod(method) != null;\n\t}\n\n\t/**\n\t * Returns the method added at the given index.\n\t * @param index The index of the method to retrieve.\n\t * @return The method at the given index.\n\t */\n\tpublic getEffectMethodAt(index:number):EffectMethodBase\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn null;\n\n\t\treturn <EffectMethodBase> this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;\n\t}\n\n\t/**\n\t * Adds an effect method at the specified index amongst the methods already added to the material. Effect\n\t * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,\n\t * etc. The method will be applied to the result of the methods with a lower index.\n\t */\n\tpublic addEffectMethodAt(method:EffectMethodBase, index:number):void\n\t{\n\t\tthis._addDependency(new MethodVO(method, this), true, index);\n\t}\n\n\t/**\n\t * Removes an effect method from the material.\n\t * @param method The method to be removed.\n\t */\n\tpublic removeEffectMethod(method:EffectMethodBase):void\n\t{\n\t\tvar methodVO:MethodVO = this.getDependencyForMethod(method);\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\t/**\n\t * remove an effect method at the specified index from the material.\n\t */\n\tpublic removeEffectMethodAt(index:number):void\n\t{\n\t\tif (index < 0 || index > this._numEffectDependencies - 1)\n\t\t\treturn;\n\n\t\tvar methodVO:MethodVO = this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies];\n\n\t\tif (methodVO != null)\n\t\t\tthis._removeDependency(methodVO, true);\n\t}\n\n\n\tprivate getDependencyForMethod(method:EffectMethodBase):MethodVO\n\t{\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i)\n\t\t\tif (this._iMethodVOs[i].method == method)\n\t\t\t\treturn this._iMethodVOs[i];\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.\n\t */\n\tpublic get normalMethod():NormalBasicMethod\n\t{\n\t\treturn this._iNormalMethodVO? <NormalBasicMethod> this._iNormalMethodVO.method : null;\n\t}\n\n\tpublic set normalMethod(value:NormalBasicMethod)\n\t{\n\t\tif (this._iNormalMethodVO && this._iNormalMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iNormalMethodVO) {\n\t\t\tthis._removeDependency(this._iNormalMethodVO);\n\t\t\tthis._iNormalMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iNormalMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iNormalMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.\n\t */\n\tpublic get ambientMethod():AmbientBasicMethod\n\t{\n\t\treturn this._iAmbientMethodVO? <AmbientBasicMethod> this._iAmbientMethodVO.method : null;\n\t}\n\n\tpublic set ambientMethod(value:AmbientBasicMethod)\n\t{\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iAmbientMethodVO) {\n\t\t\tthis._removeDependency(this._iAmbientMethodVO);\n\t\t\tthis._iAmbientMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iAmbientMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iAmbientMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.\n\t */\n\tpublic get shadowMethod():ShadowMapMethodBase\n\t{\n\t\treturn this._iShadowMethodVO? <ShadowMapMethodBase> this._iShadowMethodVO.method : null;\n\t}\n\n\tpublic set shadowMethod(value:ShadowMapMethodBase)\n\t{\n\t\tif (this._iShadowMethodVO && this._iShadowMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iShadowMethodVO) {\n\t\t\tthis._removeDependency(this._iShadowMethodVO);\n\t\t\tthis._iShadowMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iShadowMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iShadowMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.\n\t */\n\tpublic get diffuseMethod():DiffuseBasicMethod\n\t{\n\t\treturn this._iDiffuseMethodVO? <DiffuseBasicMethod> this._iDiffuseMethodVO.method : null;\n\t}\n\n\tpublic set diffuseMethod(value:DiffuseBasicMethod)\n\t{\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iDiffuseMethodVO) {\n\t\t\tthis._removeDependency(this._iDiffuseMethodVO);\n\t\t\tthis._iDiffuseMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iDiffuseMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iDiffuseMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.\n\t */\n\tpublic get specularMethod():SpecularBasicMethod\n\t{\n\t\treturn this._iSpecularMethodVO? <SpecularBasicMethod> this._iSpecularMethodVO.method : null;\n\t}\n\n\tpublic set specularMethod(value:SpecularBasicMethod)\n\t{\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)\n\t\t\treturn;\n\n\t\tif (this._iSpecularMethodVO) {\n\t\t\tthis._removeDependency(this._iSpecularMethodVO);\n\t\t\tthis._iSpecularMethodVO = null;\n\t\t}\n\n\t\tif (value) {\n\t\t\tthis._iSpecularMethodVO = new MethodVO(value, this);\n\t\t\tthis._addDependency(this._iSpecularMethodVO);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose():void\n\t{\n\t\tif (this._lightPicker)\n\t\t\tthis._lightPicker.removeEventListener(AssetEvent.INVALIDATE, this._onLightsChangeDelegate);\n\n\t\twhile (this._iMethodVOs.length)\n\t\t\tthis._removeDependency(this._iMethodVOs[0]);\n\n\t\tsuper.dispose();\n\n\t\tthis._iMethodVOs = null;\n\t}\n\n\t/**\n\t * Called when any method's shader code is invalidated.\n\t */\n\tprivate onMethodInvalidated(event:ShadingMethodEvent):void\n\t{\n\t\tthis.invalidate();\n\t}\n\n\t// RENDER LOOP\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera):void\n\t{\n\t\tsuper._iActivate(camera);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iActivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param renderable\n\t * @param stage\n\t * @param camera\n\t */\n\tpublic _setRenderState(renderable:GL_RenderableBase, camera:Camera, viewProjection:Matrix3D):void\n\t{\n\t\tsuper._setRenderState(renderable, camera, viewProjection);\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iSetRenderState(this._shader, methodVO, renderable, this._stage, camera);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iDeactivate():void\n\t{\n\t\tsuper._iDeactivate();\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod)\n\t\t\t\tmethodVO.method.iDeactivate(this._shader, methodVO, this._stage);\n\t\t}\n\t}\n\n\tpublic _iIncludeDependencies(shader:LightingShader):void\n\t{\n\t\tsuper._iIncludeDependencies(shader);\n\n\t\t//TODO: fragment animtion should be compatible with lighting pass\n\t\tshader.usesFragmentAnimation = Boolean(this._mode == MethodPassMode.SUPER_SHADER);\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending)\n\t\t\tshader.usesCommonData = true;\n\n\t\tvar i:number;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tthis.setupAndCountDependencies(shader, this._iMethodVOs[i]);\n\n\t\tvar usesTangentSpace:boolean = true;\n\n\t\tvar methodVO:MethodVO;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif ((methodVO.useMethod = methodVO.method.iIsUsed(shader)) && !methodVO.method.iUsesTangentSpace())\n\t\t\t\tusesTangentSpace = false;\n\t\t}\n\n\t\tshader.outputsNormals = this._iNormalMethodVO && this._iNormalMethodVO.useMethod;\n\t\tshader.outputsTangentNormals = shader.outputsNormals && (<NormalBasicMethod> this._iNormalMethodVO.method).iOutputsTangentNormals();\n\t\tshader.usesTangentSpace = shader.outputsTangentNormals && !shader.usesProbes && usesTangentSpace;\n\n\t\tif (!shader.usesTangentSpace) {\n\t\t\tif (shader.viewDirDependencies > 0) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t} else if (this.numPointLights > 0 && shader.usesLights) {\n\t\t\t\tshader.globalPosDependencies++;\n\t\t\t\tif (Boolean(this._mode & MethodPassMode.EFFECTS))\n\t\t\t\t\tshader.usesGlobalPosFragment = true;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Counts the dependencies for a given method.\n\t * @param method The method to count the dependencies for.\n\t * @param methodVO The method's data for this material.\n\t */\n\tprivate setupAndCountDependencies(shader:ShaderBase, methodVO:MethodVO):void\n\t{\n\t\tmethodVO.reset();\n\n\t\tmethodVO.method.iInitVO(shader, methodVO);\n\n\t\tif (methodVO.needsProjection)\n\t\t\tshader.projectionDependencies++;\n\n\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos) {\n\n\t\t\tshader.globalPosDependencies++;\n\n\t\t\tif (methodVO.needsGlobalFragmentPos)\n\t\t\t\tshader.usesGlobalPosFragment = true;\n\n\t\t}\n\n\t\tif (methodVO.needsNormals)\n\t\t\tshader.normalDependencies++;\n\n\t\tif (methodVO.needsTangents)\n\t\t\tshader.tangentDependencies++;\n\n\t\tif (methodVO.needsView)\n\t\t\tshader.viewDirDependencies++;\n\t}\n\n\tpublic _iGetPreLightingVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)\n\t\t\tcode += this._iAmbientMethodVO.method.iGetVertexCode(shader, this._iAmbientMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += this._iDiffuseMethodVO.method.iGetVertexCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += this._iSpecularMethodVO.method.iGetVertexCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPreLightingFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {\n\t\t\tcode += this._iAmbientMethodVO.method.iGetFragmentCode(shader, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\tif (this._iAmbientMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iAmbientMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPreLightingCode(<LightingShader> shader, this._iSpecularMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPerLightDiffuseFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, diffuseColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerLight(shader, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerLightSpecularFragmentCode(shader:LightingShader, lightDirReg:ShaderRegisterElement, specularColorReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerLight(shader, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeDiffuseFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentCodePerProbe(shader, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPerProbeSpecularFragmentCode(shader:LightingShader, texReg:ShaderRegisterElement, weightReg:string, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentCodePerProbe(shader, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetPostLightingVertexCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetVertexCode(shader, this._iShadowMethodVO, registerCache, sharedRegisters);\n\n\t\treturn code;\n\t}\n\n\tpublic _iGetPostLightingFragmentCode(shader:LightingShader, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\tif (shader.useAlphaPremultiplied && shader.usesBlending) {\n\t\t\tcode += \"add \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"div \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \", \" + sharedRegisters.shadedTarget + \".w\\n\" +\n\t\t\t\"sub \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.shadedTarget + \".w, \" + sharedRegisters.commons + \".z\\n\" +\n\t\t\t\"sat \" + sharedRegisters.shadedTarget + \".xyz, \" + sharedRegisters.shadedTarget + \"\\n\";\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tcode += this._iShadowMethodVO.method.iGetFragmentCode(shader, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);\n\n\t\tif (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iDiffuseMethodVO.method).iGetFragmentPostLightingCode(shader, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\n\t\t\t// resolve other dependencies as well?\n\t\t\tif (this._iDiffuseMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\n\t\t\tif (this._iDiffuseMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {\n\t\t\tcode += (<LightingMethodBase> this._iSpecularMethodVO.method).iGetFragmentPostLightingCode(shader, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);\n\t\t\tif (this._iSpecularMethodVO.needsNormals)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.normalFragment);\n\t\t\tif (this._iSpecularMethodVO.needsView)\n\t\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\t\t}\n\n\t\tif (this._iShadowMethodVO)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);\n\n\t\treturn code;\n\t}\n\n\n\tpublic _iGetNormalVertexCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\treturn this._iNormalMethodVO.method.iGetVertexCode(shader, this._iNormalMethodVO, registerCache, sharedRegisters);\n\t}\n\n\tpublic _iGetNormalFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = this._iNormalMethodVO.method.iGetFragmentCode(shader, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);\n\n\t\tif (this._iNormalMethodVO.needsView)\n\t\t\tregisterCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);\n\n\t\tif (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)\n\t\t\tregisterCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetVertexCode(shader, methodVO, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)\n\t\t\t\t\tregCache.removeVertexTempUsage(sharedReg.globalPositionVertex);\n\t\t\t}\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetVertexCode(shader, this._iColorTransformMethodVO, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, regCache:ShaderRegisterCache, sharedReg:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\t\tvar alphaReg:ShaderRegisterElement;\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\talphaReg = regCache.getFreeFragmentSingleTemp();\n\t\t\tregCache.addFragmentTempUsages(alphaReg, 1);\n\t\t\tcode += \"mov \" + alphaReg + \", \" + sharedReg.shadedTarget + \".w\\n\";\n\t\t}\n\n\t\tvar methodVO:MethodVO;\n\t\tvar len:number = this._iMethodVOs.length;\n\t\tfor (var i:number = len - this._numEffectDependencies; i < len; i++) {\n\t\t\tmethodVO = this._iMethodVOs[i];\n\t\t\tif (methodVO.useMethod) {\n\t\t\t\tcode += methodVO.method.iGetFragmentCode(shader, methodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\t\t\tif (methodVO.needsNormals)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.normalFragment);\n\n\t\t\t\tif (methodVO.needsView)\n\t\t\t\t\tregCache.removeFragmentTempUsage(sharedReg.viewDirFragment);\n\n\t\t\t}\n\t\t}\n\n\t\tif (this.preserveAlpha && this._numEffectDependencies > 0) {\n\t\t\tcode += \"mov \" + sharedReg.shadedTarget + \".w, \" + alphaReg + \"\\n\";\n\t\t\tregCache.removeFragmentTempUsage(alphaReg);\n\t\t}\n\n\t\tif (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)\n\t\t\tcode += this._iColorTransformMethodVO.method.iGetFragmentCode(shader, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);\n\n\t\treturn code;\n\t}\n\t/**\n\t * Indicates whether the shader uses any shadows.\n\t */\n\tpublic _iUsesShadows(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iShadowMethodVO && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesSpecular(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iSpecularMethodVO);\n\t}\n\n\t/**\n\t * Indicates whether the shader uses any specular component.\n\t */\n\tpublic _iUsesDiffuse(shader:ShaderBase):boolean\n\t{\n\t\treturn Boolean(this._iDiffuseMethodVO);\n\t}\n\n\n\tprivate onLightsChange(event:AssetEvent):void\n\t{\n\t\tthis._updateLights();\n\t}\n\n\tprivate _updateLights():void\n\t{\n\t\tvar numDirectionalLightsOld:number = this.numDirectionalLights;\n\t\tvar numPointLightsOld:number = this.numPointLights;\n\t\tvar numLightProbesOld:number = this.numLightProbes;\n\n\t\tif (this._lightPicker && (this._mode & MethodPassMode.LIGHTING)) {\n\t\t\tthis.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);\n\t\t\tthis.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);\n\t\t\tthis.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);\n\n\t\t\tif (this._includeCasters) {\n\t\t\t\tthis.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;\n\t\t\t\tthis.numPointLights += this._lightPicker.numCastingPointLights;\n\t\t\t}\n\n\t\t} else {\n\t\t\tthis.numDirectionalLights = 0;\n\t\t\tthis.numPointLights = 0;\n\t\t\tthis.numLightProbes = 0;\n\t\t}\n\n\t\tif (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {\n\t\t\tthis._updateShader();\n\n\t\t\tthis.invalidate();\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the amount of directional lights this material will support.\n\t * @param numDirectionalLights The maximum amount of directional lights to support.\n\t * @return The amount of directional lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumDirectionalLights(numDirectionalLights:number):number\n\t{\n\t\treturn Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);\n\t}\n\n\t/**\n\t * Calculates the amount of point lights this material will support.\n\t * @param numDirectionalLights The maximum amount of point lights to support.\n\t * @return The amount of point lights this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumPointLights(numPointLights:number):number\n\t{\n\t\tvar numFree:number = this._maxLights - this.numDirectionalLights;\n\t\treturn Math.min(numPointLights - this.pointLightsOffset, numFree);\n\t}\n\n\t/**\n\t * Calculates the amount of light probes this material will support.\n\t * @param numDirectionalLights The maximum amount of light probes to support.\n\t * @return The amount of light probes this material will support, bounded by the amount necessary.\n\t */\n\tprivate calculateNumProbes(numLightProbes:number):number\n\t{\n\t\tvar numChannels:number = 0;\n\n\t\tif ((this.specularLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\tif ((this.diffuseLightSources & LightSources.PROBES) != 0)\n\t\t\t++numChannels;\n\n\t\t// 4 channels available\n\t\treturn Math.min(numLightProbes - this.lightProbesOffset, (4/numChannels) | 0);\n\t}\n}",
    "import {Image2D}\t\t\t\t\t\t\tfrom \"awayjs-core/lib/image/Image2D\";\nimport {Matrix3D}\t\t\t\t\t\t\tfrom \"awayjs-core/lib/geom/Matrix3D\";\n\nimport {LightBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/display/LightBase\";\nimport {Camera}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/display/Camera\";\nimport {MaterialBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/materials/MaterialBase\";\nimport {ISurface}\t\t\t\t\t\t\tfrom \"awayjs-display/lib/base/ISurface\";\nimport {Single2DTexture}\t\t\t\t\tfrom \"awayjs-display/lib/textures/Single2DTexture\";\nimport {TextureBase}\t\t\t\t\t\tfrom \"awayjs-display/lib/textures/TextureBase\";\nimport {TriangleElements}\t\t\t\t\tfrom \"awayjs-display/lib/graphics/TriangleElements\";\n\nimport {ContextGLDrawMode}\t\t\t\tfrom \"awayjs-stagegl/lib/base/ContextGLDrawMode\";\nimport {ContextGLProgramType}\t\t\t\tfrom \"awayjs-stagegl/lib/base/ContextGLProgramType\";\nimport {IContextGL}\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/IContextGL\";\nimport {Stage}\t\t\t\t\t\t\tfrom \"awayjs-stagegl/lib/base/Stage\";\n\nimport {RendererBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/RendererBase\";\nimport {ShaderBase}\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderBase\";\nimport {ShaderRegisterCache}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterCache\";\nimport {ShaderRegisterData}\t\t\t\tfrom \"awayjs-renderergl/lib/shaders/ShaderRegisterData\";\nimport {PassBase}\t\t\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/passes/PassBase\";\nimport {IElementsClassGL}\t\t\t\t\tfrom \"awayjs-renderergl/lib/elements/IElementsClassGL\";\nimport {GL_RenderableBase}\t\t\t\tfrom \"awayjs-renderergl/lib/renderables/GL_RenderableBase\";\nimport {GL_SurfaceBase}\t\t\t\t\tfrom \"awayjs-renderergl/lib/surfaces/GL_SurfaceBase\";\nimport {GL_ElementsBase}\t\t\t\t\tfrom \"awayjs-renderergl/lib/elements/GL_ElementsBase\";\n\n/**\n * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point\n * of view from a light.\n */\nexport class SingleObjectDepthPass extends PassBase\n{\n\tprivate _textures:Object;\n\tprivate _projections:Object;\n\tprivate _textureSize:number /*uint*/ = 512;\n\tprivate _polyOffset:Float32Array = new Float32Array([15, 0, 0, 0]);\n\tprivate _enc:Float32Array;\n\tprivate _projectionTexturesInvalid:Boolean = true;\n\n\t/**\n\t * The size of the depth map texture to render to.\n\t */\n\tpublic get textureSize():number\n\t{\n\t\treturn this._textureSize;\n\t}\n\n\tpublic set textureSize(value:number)\n\t{\n\t\tthis._textureSize = value;\n\t}\n\n\t/**\n\t * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.\n\t */\n\tpublic get polyOffset():number\n\t{\n\t\treturn this._polyOffset[0];\n\t}\n\n\tpublic set polyOffset(value:number)\n\t{\n\t\tthis._polyOffset[0] = value;\n\t}\n\n\t/**\n\t * Creates a new SingleObjectDepthPass object.\n\t */\n\tconstructor(render:GL_SurfaceBase, renderOwner:ISurface, elementsClass:IElementsClassGL, stage:Stage)\n\t{\n\t\tsuper(render, renderOwner, elementsClass, stage);\n\n\t\t//this._pNumUsedStreams = 2;\n\t\t//this._pNumUsedVertexConstants = 7;\n\t\t//this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);\n\t\t//\n\t\t//this._pAnimatableAttributes = Array<string>(\"va0\", \"va1\";\n\t\t//this._pAnimationTargetRegisters = Array<string>(\"vt0\", \"vt1\";\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic dispose():void\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t\tthis._textures = null;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the projection textures used to contain the depth renders.\n\t */\n\tprivate updateProjectionTextures():void\n\t{\n\t\tif (this._textures) {\n\t\t\tfor (var key in this._textures) {\n\t\t\t\tvar texture:TextureBase = this._textures[key];\n\t\t\t\ttexture.dispose();\n\t\t\t}\n\t\t}\n\n\t\tthis._textures = new Object();\n\t\tthis._projections = new Object();\n\t\tthis._projectionTexturesInvalid = false;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetVertexCode():string\n\t{\n\t\tvar code:string;\n\t\t// offset\n\t\tcode = \"mul vt7, vt1, vc4.x\t\\n\" +\n\t\t\t\t\"add vt7, vt7, vt0\\n\" +\n\t\t\t\t\"mov vt7.w, vt0.w\\n\";\n\t\t// project\n\t\tcode += \"m44 vt2, vt7, vc0\\n\" +\n\t\t\t\t\"mov op, vt2\\n\";\n\n\t\t// perspective divide\n\t\tcode += \"div v0, vt2, vt2.w\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iGetFragmentCode(shader:ShaderBase, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string\n\t{\n\t\tvar code:string = \"\";\n\n\t\t// encode float -> rgba\n\t\tcode += \"mul ft0, fc0, v0.z\\n\" +\n\t\t\t\t\"frc ft0, ft0\\n\" +\n\t\t\t\t\"mul ft1, ft0.yzww, fc1\\n\" +\n\t\t\t\t\"sub ft0, ft0, ft1\\n\" +\n\t\t\t\t\"mov oc, ft0\\n\";\n\n\t\treturn code;\n\t}\n\n\t/**\n\t * Gets the depth maps rendered for this object from all lights.\n\t * @param renderableGL The renderableGL for which to retrieve the depth maps.\n\t * @param stage3DProxy The Stage3DProxy object currently used for rendering.\n\t * @return A list of depth map textures for all supported lights.\n\t */\n\tpublic _iGetDepthMap(renderableGL:GL_RenderableBase):TextureBase\n\t{\n\t\treturn this._textures[renderableGL.renderable.id];\n\t}\n\n\t/**\n\t * Retrieves the depth map projection maps for all lights.\n\t * @param renderableGL The renderableGL for which to retrieve the projection maps.\n\t * @return A list of projection maps for all supported lights.\n\t */\n\tpublic _iGetProjection(renderableGL:GL_RenderableBase):Matrix3D\n\t{\n\t\treturn this._projections[renderableGL.renderable.id];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iRender(renderableGL:GL_RenderableBase, camera:Camera, viewProjection:Matrix3D):void\n\t{\n\t\tvar matrix:Matrix3D;\n\t\tvar context:IContextGL = this._stage.context;\n\t\tvar len:number /*uint*/;\n\t\tvar light:LightBase;\n\t\tvar lights:Array<LightBase> = this._surface.lightPicker.allPickedLights;\n\t\tvar rId:number = renderableGL.renderable.id;\n\n\t\tif (!this._textures[rId])\n\t\t\tthis._textures[rId] = new Single2DTexture(new Image2D(this._textureSize, this._textureSize));\n\n\t\tif (!this._projections[rId])\n\t\t\tthis._projections[rId] = new Matrix3D();\n\n\t\tlen = lights.length;\n\n\t\t// local position = enough\n\t\tlight = lights[0];\n\n\t\tmatrix = light.iGetObjectProjectionMatrix(renderableGL.sourceEntity, camera.sceneTransform, this._projections[rId]);\n\n\t\tthis._stage.setRenderTarget(this._textures[rId], true);\n\t\tcontext.clear(1.0, 1.0, 1.0);\n\t\t//context.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, matrix, true);\n\t\t//context.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, this._enc, 2);\n\t\t\n\t\tvar elementsGL:GL_ElementsBase = renderableGL.elementsGL;\n\n\t\t// elementsGL.activateVertexBufferVO(0, elements.positions);\n\t\t// elementsGL.activateVertexBufferVO(1, elements.normals);\n\t\t// elementsGL.getIndexBufferGL().draw(ContextGLDrawMode.TRIANGLES, 0, elements.numElements);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic _iActivate(camera:Camera):void\n\t{\n\t\tif (this._projectionTexturesInvalid)\n\t\t\tthis.updateProjectionTextures();\n\n\t\t// never scale\n\t\tsuper._iActivate(camera);\n\n\t\t//this._stage.context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);\n\t}\n}",
    "export {MethodPass}\t\t\t\t\t\tfrom \"./surfaces/passes/MethodPass\";\nexport {MethodPassMode}\t\t\t\t\tfrom \"./surfaces/passes/MethodPassMode\";\nexport {SingleObjectDepthPass}\t\t\tfrom \"./surfaces/passes/SingleObjectDepthPass\";\nexport {GL_MethodMaterialSurface}\t\tfrom \"./surfaces/GL_MethodMaterialSurface\";"
  ],
  "sourceRoot": ""
}